{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst metadata_1 = require(\"../models/transactions/metadata\");\nfunction ensureDecodedMeta(meta) {\n  if (typeof meta === 'string') {\n    return (0, ripple_binary_codec_1.decode)(meta);\n  }\n  return meta;\n}\nfunction getNFTokenID(meta) {\n  if (typeof meta !== 'string' && (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) === undefined) {\n    throw new TypeError(`Unable to parse the parameter given to getNFTokenID.\n      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta)} instead.`);\n  }\n  const decodedMeta = ensureDecodedMeta(meta);\n  const affectedNodes = decodedMeta.AffectedNodes.filter(node => {\n    var _a;\n    if ((0, metadata_1.isCreatedNode)(node)) {\n      return node.CreatedNode.LedgerEntryType === 'NFTokenPage';\n    }\n    if ((0, metadata_1.isModifiedNode)(node)) {\n      return node.ModifiedNode.LedgerEntryType === 'NFTokenPage' && Boolean((_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens);\n    }\n    return false;\n  });\n  const previousTokenIDSet = new Set(affectedNodes.flatMap(node => {\n    var _a;\n    const nftokens = (0, metadata_1.isModifiedNode)(node) ? (_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens : [];\n    return nftokens.map(token => token.NFToken.NFTokenID);\n  }).filter(id => Boolean(id)));\n  const finalTokenIDs = affectedNodes.flatMap(node => {\n    var _a, _b, _c, _d, _e, _f;\n    return ((_f = (_c = (_b = (_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens) !== null && _f !== void 0 ? _f : []).map(token => token.NFToken.NFTokenID);\n  }).filter(nftokenID => Boolean(nftokenID));\n  const nftokenID = finalTokenIDs.find(id => !previousTokenIDSet.has(id));\n  return nftokenID;\n}\nexports.default = getNFTokenID;","map":{"version":3,"names":["ripple_binary_codec_1","require","metadata_1","ensureDecodedMeta","meta","decode","getNFTokenID","AffectedNodes","undefined","TypeError","JSON","stringify","decodedMeta","affectedNodes","filter","node","isCreatedNode","CreatedNode","LedgerEntryType","isModifiedNode","ModifiedNode","Boolean","_a","PreviousFields","NFTokens","previousTokenIDSet","Set","flatMap","nftokens","map","token","NFToken","NFTokenID","id","finalTokenIDs","_f","_c","_b","FinalFields","_e","_d","NewFields","nftokenID","find","has","exports","default"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/utils/getNFTokenID.ts"],"sourcesContent":["import { decode } from 'ripple-binary-codec'\n\nimport { NFToken } from '../models/ledger/NFTokenPage'\nimport {\n  CreatedNode,\n  isCreatedNode,\n  isModifiedNode,\n  ModifiedNode,\n  TransactionMetadata,\n} from '../models/transactions/metadata'\n\n/**\n * Ensures that the metadata is in a deserialized format to parse.\n *\n * @param meta - the metadata from a `tx` method call. Can be in json format or binary format.\n * @returns the metadata in a deserialized format.\n */\nfunction ensureDecodedMeta(\n  meta: TransactionMetadata | string,\n): TransactionMetadata {\n  if (typeof meta === 'string') {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Meta is either metadata or serialized metadata.\n    return decode(meta) as unknown as TransactionMetadata\n  }\n  return meta\n}\n\n/**\n * Gets the NFTokenID for an NFT recently minted with NFTokenMint.\n *\n * @param meta - Metadata from the response to submitting and waiting for an NFTokenMint transaction or from a `tx` method call.\n * @returns The NFTokenID for the minted NFT.\n * @throws if meta is not TransactionMetadata.\n */\n// eslint-disable-next-line max-lines-per-function -- This function has a lot of documentation\nexport default function getNFTokenID(\n  meta: TransactionMetadata | string | undefined,\n): string | undefined {\n  if (typeof meta !== 'string' && meta?.AffectedNodes === undefined) {\n    throw new TypeError(`Unable to parse the parameter given to getNFTokenID.\n      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(\n        meta,\n      )} instead.`)\n  }\n\n  const decodedMeta = ensureDecodedMeta(meta)\n\n  /*\n   * When a mint results in splitting an existing page,\n   * it results in a created page and a modified node. Sometimes,\n   * the created node needs to be linked to a third page, resulting\n   * in modifying that third page's PreviousPageMin or NextPageMin\n   * field changing, but no NFTs within that page changing. In this\n   * case, there will be no previous NFTs and we need to skip.\n   * However, there will always be NFTs listed in the final fields,\n   * as rippled outputs all fields in final fields even if they were\n   * not changed. Thus why we add the additional condition to check\n   * if the PreviousFields contains NFTokens\n   */\n  const affectedNodes = decodedMeta.AffectedNodes.filter((node) => {\n    if (isCreatedNode(node)) {\n      return node.CreatedNode.LedgerEntryType === 'NFTokenPage'\n    }\n    if (isModifiedNode(node)) {\n      return (\n        node.ModifiedNode.LedgerEntryType === 'NFTokenPage' &&\n        Boolean(node.ModifiedNode.PreviousFields?.NFTokens)\n      )\n    }\n    return false\n  })\n  /* eslint-disable @typescript-eslint/consistent-type-assertions -- Necessary for parsing metadata */\n  const previousTokenIDSet = new Set(\n    affectedNodes\n      .flatMap((node) => {\n        const nftokens = isModifiedNode(node)\n          ? (node.ModifiedNode.PreviousFields?.NFTokens as NFToken[])\n          : []\n        return nftokens.map((token) => token.NFToken.NFTokenID)\n      })\n      .filter((id) => Boolean(id)),\n  )\n\n  /* eslint-disable @typescript-eslint/no-unnecessary-condition -- Cleaner to read */\n  const finalTokenIDs = affectedNodes\n    .flatMap((node) =>\n      (\n        (((node as ModifiedNode).ModifiedNode?.FinalFields?.NFTokens ??\n          (node as CreatedNode).CreatedNode?.NewFields\n            ?.NFTokens) as NFToken[]) ?? []\n      ).map((token) => token.NFToken.NFTokenID),\n    )\n    .filter((nftokenID) => Boolean(nftokenID))\n  /* eslint-enable @typescript-eslint/consistent-type-assertions -- Necessary for parsing metadata */\n  /* eslint-enable @typescript-eslint/no-unnecessary-condition -- Cleaner to read */\n  const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id))\n\n  return nftokenID\n}\n"],"mappings":";;;;;AAAA,MAAAA,qBAAA,GAAAC,OAAA;AAGA,MAAAC,UAAA,GAAAD,OAAA;AAcA,SAASE,iBAAiBA,CACxBC,IAAkC;EAElC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAE5B,OAAO,IAAAJ,qBAAA,CAAAK,MAAM,EAACD,IAAI,CAAmC;;EAEvD,OAAOA,IAAI;AACb;AAUA,SAAwBE,YAAYA,CAClCF,IAA8C;EAE9C,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,CAAAA,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEG,aAAa,MAAKC,SAAS,EAAE;IACjE,MAAM,IAAIC,SAAS,CAAC;8EACsDC,IAAI,CAACC,SAAS,CACpFP,IAAI,CACL,WAAW,CAAC;;EAGjB,MAAMQ,WAAW,GAAGT,iBAAiB,CAACC,IAAI,CAAC;EAc3C,MAAMS,aAAa,GAAGD,WAAW,CAACL,aAAa,CAACO,MAAM,CAAEC,IAAI,IAAI;;IAC9D,IAAI,IAAAb,UAAA,CAAAc,aAAa,EAACD,IAAI,CAAC,EAAE;MACvB,OAAOA,IAAI,CAACE,WAAW,CAACC,eAAe,KAAK,aAAa;;IAE3D,IAAI,IAAAhB,UAAA,CAAAiB,cAAc,EAACJ,IAAI,CAAC,EAAE;MACxB,OACEA,IAAI,CAACK,YAAY,CAACF,eAAe,KAAK,aAAa,IACnDG,OAAO,CAAC,CAAAC,EAAA,GAAAP,IAAI,CAACK,YAAY,CAACG,cAAc,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,QAAQ,CAAC;;IAGvD,OAAO,KAAK;EACd,CAAC,CAAC;EAEF,MAAMC,kBAAkB,GAAG,IAAIC,GAAG,CAChCb,aAAa,CACVc,OAAO,CAAEZ,IAAI,IAAI;;IAChB,MAAMa,QAAQ,GAAG,IAAA1B,UAAA,CAAAiB,cAAc,EAACJ,IAAI,CAAC,GAChC,CAAAO,EAAA,GAAAP,IAAI,CAACK,YAAY,CAACG,cAAc,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,QAAsB,GACzD,EAAE;IACN,OAAOI,QAAQ,CAACC,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACC,OAAO,CAACC,SAAS,CAAC;EACzD,CAAC,CAAC,CACDlB,MAAM,CAAEmB,EAAE,IAAKZ,OAAO,CAACY,EAAE,CAAC,CAAC,CAC/B;EAGD,MAAMC,aAAa,GAAGrB,aAAa,CAChCc,OAAO,CAAEZ,IAAI,IAAI;;IAChB,QACE,CAAAoB,EAAA,GAAE,CAAAC,EAAA,IAAAC,EAAA,IAAAf,EAAA,GAACP,IAAqB,CAACK,YAAY,cAAAE,EAAA,uBAAAA,EAAA,CAAEgB,WAAW,cAAAD,EAAA,uBAAAA,EAAA,CAAEb,QAAQ,cAAAY,EAAA,cAAAA,EAAA,GAC1D,CAAAG,EAAA,IAAAC,EAAA,GAACzB,IAAoB,CAACE,WAAW,cAAAuB,EAAA,uBAAAA,EAAA,CAAEC,SAAS,cAAAF,EAAA,uBAAAA,EAAA,CACxCf,QAAuB,cAAAW,EAAA,cAAAA,EAAA,GAAI,EAAE,EACnCN,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACC,OAAO,CAACC,SAAS,CAAC;GAAA,CAC1C,CACAlB,MAAM,CAAE4B,SAAS,IAAKrB,OAAO,CAACqB,SAAS,CAAC,CAAC;EAG5C,MAAMA,SAAS,GAAGR,aAAa,CAACS,IAAI,CAAEV,EAAE,IAAK,CAACR,kBAAkB,CAACmB,GAAG,CAACX,EAAE,CAAC,CAAC;EAEzE,OAAOS,SAAS;AAClB;AA/DAG,OAAA,CAAAC,OAAA,GAAAxC,YAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}