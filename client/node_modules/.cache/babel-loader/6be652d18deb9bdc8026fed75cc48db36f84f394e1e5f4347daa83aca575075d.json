{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concatArgs = exports.arrayEqual = void 0;\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nfunction arrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  return arr1.every((value, index) => value === arr2[index]);\n}\nexports.arrayEqual = arrayEqual;\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val) {\n  return typeof val === 'number';\n}\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\nfunction concatArgs(...args) {\n  return args.flatMap(arg => {\n    return isScalar(arg) ? [arg] : Array.from(arg);\n  });\n}\nexports.concatArgs = concatArgs;","map":{"version":3,"names":["arrayEqual","arr1","arr2","length","every","value","index","exports","isScalar","val","concatArgs","args","flatMap","arg","Array","from"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-address-codec/src/utils.ts"],"sourcesContent":["export type ByteArray = number[] | Uint8Array\n\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nexport function arrayEqual(arr1: ByteArray, arr2: ByteArray): boolean {\n  if (arr1.length !== arr2.length) {\n    return false\n  }\n  return arr1.every((value, index) => value === arr2[index])\n}\n\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val: ByteArray | number): val is number {\n  return typeof val === 'number'\n}\n\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\n\nexport function concatArgs(...args: Array<number | ByteArray>): number[] {\n  return args.flatMap((arg) => {\n    return isScalar(arg) ? [arg] : Array.from(arg)\n  })\n}\n"],"mappings":";;;;;;AAEA;;;;;;AAMA,SAAgBA,UAAUA,CAACC,IAAe,EAAEC,IAAe;EACzD,IAAID,IAAI,CAACE,MAAM,KAAKD,IAAI,CAACC,MAAM,EAAE;IAC/B,OAAO,KAAK;;EAEd,OAAOF,IAAI,CAACG,KAAK,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAKD,KAAK,KAAKH,IAAI,CAACI,KAAK,CAAC,CAAC;AAC5D;AALAC,OAAA,CAAAP,UAAA,GAAAA,UAAA;AAOA;;;;;AAKA,SAASQ,QAAQA,CAACC,GAAuB;EACvC,OAAO,OAAOA,GAAG,KAAK,QAAQ;AAChC;AAEA;;;;;;;;;;;AAYA,SAAgBC,UAAUA,CAAC,GAAGC,IAA+B;EAC3D,OAAOA,IAAI,CAACC,OAAO,CAAEC,GAAG,IAAI;IAC1B,OAAOL,QAAQ,CAACK,GAAG,CAAC,GAAG,CAACA,GAAG,CAAC,GAAGC,KAAK,CAACC,IAAI,CAACF,GAAG,CAAC;EAChD,CAAC,CAAC;AACJ;AAJAN,OAAA,CAAAG,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}