{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XChainBridge = void 0;\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst account_id_1 = require(\"./account-id\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst issue_1 = require(\"./issue\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * Type guard for XChainBridgeObject\n */\nfunction isXChainBridgeObject(arg) {\n  const keys = Object.keys(arg).sort();\n  return keys.length === 4 && keys[0] === 'IssuingChainDoor' && keys[1] === 'IssuingChainIssue' && keys[2] === 'LockingChainDoor' && keys[3] === 'LockingChainIssue';\n}\n/**\n * Class for serializing/deserializing XChainBridges\n */\nclass XChainBridge extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);\n  }\n  /**\n   * Construct a cross-chain bridge from a JSON\n   *\n   * @param value XChainBridge or JSON to parse into an XChainBridge\n   * @returns An XChainBridge object\n   */\n  static from(value) {\n    if (value instanceof XChainBridge) {\n      return value;\n    }\n    if (!isXChainBridgeObject(value)) {\n      throw new Error('Invalid type to construct an XChainBridge');\n    }\n    const bytes = [];\n    this.TYPE_ORDER.forEach(item => {\n      const {\n        name,\n        type\n      } = item;\n      if (type === account_id_1.AccountID) {\n        bytes.push(Uint8Array.from([0x14]));\n      }\n      const object = type.from(value[name]);\n      bytes.push(object.toBytes());\n    });\n    return new XChainBridge((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Read an XChainBridge from a BinaryParser\n   *\n   * @param parser BinaryParser to read the XChainBridge from\n   * @returns An XChainBridge object\n   */\n  static fromParser(parser) {\n    const bytes = [];\n    this.TYPE_ORDER.forEach(item => {\n      const {\n        type\n      } = item;\n      if (type === account_id_1.AccountID) {\n        parser.skip(1);\n        bytes.push(Uint8Array.from([0x14]));\n      }\n      const object = type.fromParser(parser);\n      bytes.push(object.toBytes());\n    });\n    return new XChainBridge((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Get the JSON representation of this XChainBridge\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON() {\n    const parser = new binary_parser_1.BinaryParser(this.toString());\n    const json = {};\n    XChainBridge.TYPE_ORDER.forEach(item => {\n      const {\n        name,\n        type\n      } = item;\n      if (type === account_id_1.AccountID) {\n        parser.skip(1);\n      }\n      const object = type.fromParser(parser).toJSON();\n      json[name] = object;\n    });\n    return json;\n  }\n}\nexports.XChainBridge = XChainBridge;\nXChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1.concat)([Uint8Array.from([0x14]), new Uint8Array(40), Uint8Array.from([0x14]), new Uint8Array(40)]));\nXChainBridge.TYPE_ORDER = [{\n  name: 'LockingChainDoor',\n  type: account_id_1.AccountID\n}, {\n  name: 'LockingChainIssue',\n  type: issue_1.Issue\n}, {\n  name: 'IssuingChainDoor',\n  type: account_id_1.AccountID\n}, {\n  name: 'IssuingChainIssue',\n  type: issue_1.Issue\n}];","map":{"version":3,"names":["binary_parser_1","require","account_id_1","serialized_type_1","issue_1","utils_1","isXChainBridgeObject","arg","keys","Object","sort","length","XChainBridge","SerializedType","constructor","bytes","ZERO_XCHAIN_BRIDGE","from","value","Error","TYPE_ORDER","forEach","item","name","type","AccountID","push","Uint8Array","object","toBytes","concat","fromParser","parser","skip","toJSON","BinaryParser","toString","json","exports","Issue"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/types/xchain-bridge.ts"],"sourcesContent":["import { BinaryParser } from '../serdes/binary-parser'\n\nimport { AccountID } from './account-id'\nimport { JsonObject, SerializedType } from './serialized-type'\nimport { Issue, IssueObject } from './issue'\nimport { concat } from '@xrplf/isomorphic/utils'\n\n/**\n * Interface for JSON objects that represent cross-chain bridges\n */\ninterface XChainBridgeObject extends JsonObject {\n  LockingChainDoor: string\n  LockingChainIssue: IssueObject | string\n  IssuingChainDoor: string\n  IssuingChainIssue: IssueObject | string\n}\n\n/**\n * Type guard for XChainBridgeObject\n */\nfunction isXChainBridgeObject(arg): arg is XChainBridgeObject {\n  const keys = Object.keys(arg).sort()\n  return (\n    keys.length === 4 &&\n    keys[0] === 'IssuingChainDoor' &&\n    keys[1] === 'IssuingChainIssue' &&\n    keys[2] === 'LockingChainDoor' &&\n    keys[3] === 'LockingChainIssue'\n  )\n}\n\n/**\n * Class for serializing/deserializing XChainBridges\n */\nclass XChainBridge extends SerializedType {\n  static readonly ZERO_XCHAIN_BRIDGE: XChainBridge = new XChainBridge(\n    concat([\n      Uint8Array.from([0x14]),\n      new Uint8Array(40),\n      Uint8Array.from([0x14]),\n      new Uint8Array(40),\n    ]),\n  )\n\n  static readonly TYPE_ORDER: { name: string; type: typeof SerializedType }[] =\n    [\n      { name: 'LockingChainDoor', type: AccountID },\n      { name: 'LockingChainIssue', type: Issue },\n      { name: 'IssuingChainDoor', type: AccountID },\n      { name: 'IssuingChainIssue', type: Issue },\n    ]\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? XChainBridge.ZERO_XCHAIN_BRIDGE.bytes)\n  }\n\n  /**\n   * Construct a cross-chain bridge from a JSON\n   *\n   * @param value XChainBridge or JSON to parse into an XChainBridge\n   * @returns An XChainBridge object\n   */\n  static from<T extends XChainBridge | XChainBridgeObject>(\n    value: T,\n  ): XChainBridge {\n    if (value instanceof XChainBridge) {\n      return value\n    }\n\n    if (!isXChainBridgeObject(value)) {\n      throw new Error('Invalid type to construct an XChainBridge')\n    }\n\n    const bytes: Array<Uint8Array> = []\n    this.TYPE_ORDER.forEach((item) => {\n      const { name, type } = item\n      if (type === AccountID) {\n        bytes.push(Uint8Array.from([0x14]))\n      }\n      const object = type.from(value[name])\n      bytes.push(object.toBytes())\n    })\n    return new XChainBridge(concat(bytes))\n  }\n\n  /**\n   * Read an XChainBridge from a BinaryParser\n   *\n   * @param parser BinaryParser to read the XChainBridge from\n   * @returns An XChainBridge object\n   */\n  static fromParser(parser: BinaryParser): XChainBridge {\n    const bytes: Array<Uint8Array> = []\n\n    this.TYPE_ORDER.forEach((item) => {\n      const { type } = item\n      if (type === AccountID) {\n        parser.skip(1)\n        bytes.push(Uint8Array.from([0x14]))\n      }\n      const object = type.fromParser(parser)\n      bytes.push(object.toBytes())\n    })\n\n    return new XChainBridge(concat(bytes))\n  }\n\n  /**\n   * Get the JSON representation of this XChainBridge\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON(): XChainBridgeObject {\n    const parser = new BinaryParser(this.toString())\n    const json = {}\n    XChainBridge.TYPE_ORDER.forEach((item) => {\n      const { name, type } = item\n      if (type === AccountID) {\n        parser.skip(1)\n      }\n      const object = type.fromParser(parser).toJSON()\n      json[name] = object\n    })\n    return json as XChainBridgeObject\n  }\n}\n\nexport { XChainBridge, XChainBridgeObject }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}