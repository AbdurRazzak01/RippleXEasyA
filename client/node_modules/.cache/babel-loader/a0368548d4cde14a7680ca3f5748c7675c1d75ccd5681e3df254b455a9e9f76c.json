{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\nconst secp256k1_1 = require(\"@noble/curves/secp256k1\");\nconst Sha512_1 = __importDefault(require(\"../../utils/Sha512\"));\nconst ZERO = BigInt(0);\nfunction deriveScalar(bytes, discrim) {\n  const order = secp256k1_1.secp256k1.CURVE.n;\n  for (let i = 0; i <= 4294967295; i++) {\n    // We hash the bytes to find a 256-bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512_1.default().add(bytes);\n    // If the optional discriminator index was passed in, update the hash.\n    if (discrim !== undefined) {\n      hasher.addU32(discrim);\n    }\n    hasher.addU32(i);\n    const key = hasher.first256BigInt();\n    /* istanbul ignore else */\n    if (key > ZERO && key < order) {\n      return key;\n    }\n  }\n  // This error is practically impossible to reach.\n  // The order of the curve describes the (finite) amount of points on the curve\n  // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n  // How often will an (essentially) random number generated by Sha512 be larger than that?\n  // There's 2^32 chances (the for loop) to get a number smaller than the order,\n  // and it's rare that you'll even get past the first loop iteration.\n  // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n  //\n  /* istanbul ignore next */\n  throw new Error('impossible unicorn ;)');\n}\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nfunction derivePrivateKey(seed, opts = {}) {\n  const root = opts.validator;\n  const order = secp256k1_1.secp256k1.CURVE.n;\n  // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n  const privateGen = deriveScalar(seed);\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen;\n  }\n  const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);\n  // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n  const accountIndex = opts.accountIndex || 0;\n  return (deriveScalar(publicGen, accountIndex) + privateGen) % order;\n}\nexports.derivePrivateKey = derivePrivateKey;\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n  const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);\n  const scalar = deriveScalar(publicGenBytes, 0);\n  const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);\n  const offset = rootPubPoint.add(point);\n  return offset.toRawBytes(true);\n}\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;","map":{"version":3,"names":["secp256k1_1","require","Sha512_1","__importDefault","ZERO","BigInt","deriveScalar","bytes","discrim","order","secp256k1","CURVE","n","i","hasher","default","add","undefined","addU32","key","first256BigInt","Error","derivePrivateKey","seed","opts","root","validator","privateGen","publicGen","ProjectivePoint","BASE","multiply","toRawBytes","accountIndex","exports","accountPublicFromPublicGenerator","publicGenBytes","rootPubPoint","fromHex","scalar","point","offset"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-keypairs/src/signing-schemes/secp256k1/utils.ts"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport Sha512 from '../../utils/Sha512'\n\nconst ZERO = BigInt(0)\n\nfunction deriveScalar(bytes: Uint8Array, discrim?: number): bigint {\n  const order = secp256k1.CURVE.n\n  for (let i = 0; i <= 0xffff_ffff; i++) {\n    // We hash the bytes to find a 256-bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512().add(bytes)\n    // If the optional discriminator index was passed in, update the hash.\n    if (discrim !== undefined) {\n      hasher.addU32(discrim)\n    }\n    hasher.addU32(i)\n    const key = hasher.first256BigInt()\n    /* istanbul ignore else */\n    if (key > ZERO && key < order) {\n      return key\n    }\n  }\n  // This error is practically impossible to reach.\n  // The order of the curve describes the (finite) amount of points on the curve\n  // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n  // How often will an (essentially) random number generated by Sha512 be larger than that?\n  // There's 2^32 chances (the for loop) to get a number smaller than the order,\n  // and it's rare that you'll even get past the first loop iteration.\n  // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n  //\n  /* istanbul ignore next */\n  throw new Error('impossible unicorn ;)')\n}\n\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nexport function derivePrivateKey(\n  seed: Uint8Array,\n  opts: {\n    validator?: boolean\n    accountIndex?: number\n  } = {},\n): bigint {\n  const root = opts.validator\n  const order = secp256k1.CURVE.n\n\n  // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n  const privateGen = deriveScalar(seed)\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen\n  }\n  const publicGen =\n    secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true)\n  // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n  const accountIndex = opts.accountIndex || 0\n  return (deriveScalar(publicGen, accountIndex) + privateGen) % order\n}\n\nexport function accountPublicFromPublicGenerator(publicGenBytes: Uint8Array) {\n  const rootPubPoint = secp256k1.ProjectivePoint.fromHex(publicGenBytes)\n  const scalar = deriveScalar(publicGenBytes, 0)\n  const point = secp256k1.ProjectivePoint.BASE.multiply(scalar)\n  const offset = rootPubPoint.add(point)\n  return offset.toRawBytes(true)\n}\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,WAAA,GAAAC,OAAA;AAEA,MAAAC,QAAA,GAAAC,eAAA,CAAAF,OAAA;AAEA,MAAMG,IAAI,GAAGC,MAAM,CAAC,CAAC,CAAC;AAEtB,SAASC,YAAYA,CAACC,KAAiB,EAAEC,OAAgB;EACvD,MAAMC,KAAK,GAAGT,WAAA,CAAAU,SAAS,CAACC,KAAK,CAACC,CAAC;EAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,UAAW,EAAEA,CAAC,EAAE,EAAE;IACrC;IACA;IACA,MAAMC,MAAM,GAAG,IAAIZ,QAAA,CAAAa,OAAM,EAAE,CAACC,GAAG,CAACT,KAAK,CAAC;IACtC;IACA,IAAIC,OAAO,KAAKS,SAAS,EAAE;MACzBH,MAAM,CAACI,MAAM,CAACV,OAAO,CAAC;;IAExBM,MAAM,CAACI,MAAM,CAACL,CAAC,CAAC;IAChB,MAAMM,GAAG,GAAGL,MAAM,CAACM,cAAc,EAAE;IACnC;IACA,IAAID,GAAG,GAAGf,IAAI,IAAIe,GAAG,GAAGV,KAAK,EAAE;MAC7B,OAAOU,GAAG;;;EAGd;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;AAC1C;AAEA;;;;;;;;;AASA,SAAgBC,gBAAgBA,CAC9BC,IAAgB,EAChBC,IAAA,GAGI,EAAE;EAEN,MAAMC,IAAI,GAAGD,IAAI,CAACE,SAAS;EAC3B,MAAMjB,KAAK,GAAGT,WAAA,CAAAU,SAAS,CAACC,KAAK,CAACC,CAAC;EAE/B;EACA;EACA,MAAMe,UAAU,GAAGrB,YAAY,CAACiB,IAAI,CAAC;EACrC,IAAIE,IAAI,EAAE;IACR;IACA,OAAOE,UAAU;;EAEnB,MAAMC,SAAS,GACb5B,WAAA,CAAAU,SAAS,CAACmB,eAAe,CAACC,IAAI,CAACC,QAAQ,CAACJ,UAAU,CAAC,CAACK,UAAU,CAAC,IAAI,CAAC;EACtE;EACA;EACA,MAAMC,YAAY,GAAGT,IAAI,CAACS,YAAY,IAAI,CAAC;EAC3C,OAAO,CAAC3B,YAAY,CAACsB,SAAS,EAAEK,YAAY,CAAC,GAAGN,UAAU,IAAIlB,KAAK;AACrE;AAvBAyB,OAAA,CAAAZ,gBAAA,GAAAA,gBAAA;AAyBA,SAAgBa,gCAAgCA,CAACC,cAA0B;EACzE,MAAMC,YAAY,GAAGrC,WAAA,CAAAU,SAAS,CAACmB,eAAe,CAACS,OAAO,CAACF,cAAc,CAAC;EACtE,MAAMG,MAAM,GAAGjC,YAAY,CAAC8B,cAAc,EAAE,CAAC,CAAC;EAC9C,MAAMI,KAAK,GAAGxC,WAAA,CAAAU,SAAS,CAACmB,eAAe,CAACC,IAAI,CAACC,QAAQ,CAACQ,MAAM,CAAC;EAC7D,MAAME,MAAM,GAAGJ,YAAY,CAACrB,GAAG,CAACwB,KAAK,CAAC;EACtC,OAAOC,MAAM,CAACT,UAAU,CAAC,IAAI,CAAC;AAChC;AANAE,OAAA,CAAAC,gCAAA,GAAAA,gCAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}