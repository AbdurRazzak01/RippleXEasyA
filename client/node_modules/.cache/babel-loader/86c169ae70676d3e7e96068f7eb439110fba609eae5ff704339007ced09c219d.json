{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryParser = void 0;\nconst enums_1 = require(\"../enums\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * BinaryParser is used to compute fields and values from a HexString\n */\nclass BinaryParser {\n  /**\n   * Initialize bytes to a hex string\n   *\n   * @param hexBytes a hex string\n   * @param definitions Rippled definitions used to parse the values of transaction types and such.\n   *                          Can be customized for sidechains and amendments.\n   */\n  constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {\n    this.bytes = (0, utils_1.hexToBytes)(hexBytes);\n    this.definitions = definitions;\n  }\n  /**\n   * Peek the first byte of the BinaryParser\n   *\n   * @returns The first byte of the BinaryParser\n   */\n  peek() {\n    if (this.bytes.byteLength === 0) {\n      throw new Error();\n    }\n    return this.bytes[0];\n  }\n  /**\n   * Consume the first n bytes of the BinaryParser\n   *\n   * @param n the number of bytes to skip\n   */\n  skip(n) {\n    if (n > this.bytes.byteLength) {\n      throw new Error();\n    }\n    this.bytes = this.bytes.slice(n);\n  }\n  /**\n   * read the first n bytes from the BinaryParser\n   *\n   * @param n The number of bytes to read\n   * @return The bytes\n   */\n  read(n) {\n    if (n > this.bytes.byteLength) {\n      throw new Error();\n    }\n    const slice = this.bytes.slice(0, n);\n    this.skip(n);\n    return slice;\n  }\n  /**\n   * Read an integer of given size\n   *\n   * @param n The number of bytes to read\n   * @return The number represented by those bytes\n   */\n  readUIntN(n) {\n    if (0 >= n || n > 4) {\n      throw new Error('invalid n');\n    }\n    return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;\n  }\n  readUInt8() {\n    return this.readUIntN(1);\n  }\n  readUInt16() {\n    return this.readUIntN(2);\n  }\n  readUInt32() {\n    return this.readUIntN(4);\n  }\n  size() {\n    return this.bytes.byteLength;\n  }\n  end(customEnd) {\n    const length = this.bytes.byteLength;\n    return length === 0 || customEnd !== undefined && length <= customEnd;\n  }\n  /**\n   * Reads variable length encoded bytes\n   *\n   * @return The variable length bytes\n   */\n  readVariableLength() {\n    return this.read(this.readVariableLengthLength());\n  }\n  /**\n   * Reads the length of the variable length encoded bytes\n   *\n   * @return The length of the variable length encoded bytes\n   */\n  readVariableLengthLength() {\n    const b1 = this.readUInt8();\n    if (b1 <= 192) {\n      return b1;\n    } else if (b1 <= 240) {\n      const b2 = this.readUInt8();\n      return 193 + (b1 - 193) * 256 + b2;\n    } else if (b1 <= 254) {\n      const b2 = this.readUInt8();\n      const b3 = this.readUInt8();\n      return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;\n    }\n    throw new Error('Invalid variable length indicator');\n  }\n  /**\n   * Reads the field ordinal from the BinaryParser\n   *\n   * @return Field ordinal\n   */\n  readFieldOrdinal() {\n    let type = this.readUInt8();\n    let nth = type & 15;\n    type >>= 4;\n    if (type === 0) {\n      type = this.readUInt8();\n      if (type === 0 || type < 16) {\n        throw new Error('Cannot read FieldOrdinal, type_code out of range');\n      }\n    }\n    if (nth === 0) {\n      nth = this.readUInt8();\n      if (nth === 0 || nth < 16) {\n        throw new Error('Cannot read FieldOrdinal, field_code out of range');\n      }\n    }\n    return type << 16 | nth;\n  }\n  /**\n   * Read the field from the BinaryParser\n   *\n   * @return The field represented by the bytes at the head of the BinaryParser\n   */\n  readField() {\n    return this.definitions.field.fromString(this.readFieldOrdinal().toString());\n  }\n  /**\n   * Read a given type from the BinaryParser\n   *\n   * @param type The type that you want to read from the BinaryParser\n   * @return The instance of that type read from the BinaryParser\n   */\n  readType(type) {\n    return type.fromParser(this);\n  }\n  /**\n   * Get the type associated with a given field\n   *\n   * @param field The field that you wan to get the type of\n   * @return The type associated with the given field\n   */\n  typeForField(field) {\n    return field.associatedType;\n  }\n  /**\n   * Read value of the type specified by field from the BinaryParser\n   *\n   * @param field The field that you want to get the associated value for\n   * @return The value associated with the given field\n   */\n  readFieldValue(field) {\n    const type = this.typeForField(field);\n    if (!type) {\n      throw new Error(`unsupported: (${field.name}, ${field.type.name})`);\n    }\n    const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : undefined;\n    const value = type.fromParser(this, sizeHint);\n    if (value === undefined) {\n      throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);\n    }\n    return value;\n  }\n  /**\n   * Get the next field and value from the BinaryParser\n   *\n   * @return The field and value\n   */\n  readFieldAndValue() {\n    const field = this.readField();\n    return [field, this.readFieldValue(field)];\n  }\n}\nexports.BinaryParser = BinaryParser;","map":{"version":3,"names":["enums_1","require","utils_1","BinaryParser","constructor","hexBytes","definitions","DEFAULT_DEFINITIONS","bytes","hexToBytes","peek","byteLength","Error","skip","n","slice","read","readUIntN","reduce","a","b","readUInt8","readUInt16","readUInt32","size","end","customEnd","length","undefined","readVariableLength","readVariableLengthLength","b1","b2","b3","readFieldOrdinal","type","nth","readField","field","fromString","toString","readType","fromParser","typeForField","associatedType","readFieldValue","name","sizeHint","isVariableLengthEncoded","value","readFieldAndValue","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/serdes/binary-parser.ts"],"sourcesContent":["import {\n  XrplDefinitionsBase,\n  DEFAULT_DEFINITIONS,\n  FieldInstance,\n} from '../enums'\nimport { type SerializedType } from '../types/serialized-type'\nimport { hexToBytes } from '@xrplf/isomorphic/utils'\n\n/**\n * BinaryParser is used to compute fields and values from a HexString\n */\nclass BinaryParser {\n  private bytes: Uint8Array\n  definitions: XrplDefinitionsBase\n\n  /**\n   * Initialize bytes to a hex string\n   *\n   * @param hexBytes a hex string\n   * @param definitions Rippled definitions used to parse the values of transaction types and such.\n   *                          Can be customized for sidechains and amendments.\n   */\n  constructor(\n    hexBytes: string,\n    definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n  ) {\n    this.bytes = hexToBytes(hexBytes)\n    this.definitions = definitions\n  }\n\n  /**\n   * Peek the first byte of the BinaryParser\n   *\n   * @returns The first byte of the BinaryParser\n   */\n  peek(): number {\n    if (this.bytes.byteLength === 0) {\n      throw new Error()\n    }\n    return this.bytes[0]\n  }\n\n  /**\n   * Consume the first n bytes of the BinaryParser\n   *\n   * @param n the number of bytes to skip\n   */\n  skip(n: number): void {\n    if (n > this.bytes.byteLength) {\n      throw new Error()\n    }\n    this.bytes = this.bytes.slice(n)\n  }\n\n  /**\n   * read the first n bytes from the BinaryParser\n   *\n   * @param n The number of bytes to read\n   * @return The bytes\n   */\n  read(n: number): Uint8Array {\n    if (n > this.bytes.byteLength) {\n      throw new Error()\n    }\n\n    const slice = this.bytes.slice(0, n)\n    this.skip(n)\n    return slice\n  }\n\n  /**\n   * Read an integer of given size\n   *\n   * @param n The number of bytes to read\n   * @return The number represented by those bytes\n   */\n  readUIntN(n: number): number {\n    if (0 >= n || n > 4) {\n      throw new Error('invalid n')\n    }\n    return this.read(n).reduce((a, b) => (a << 8) | b) >>> 0\n  }\n\n  readUInt8(): number {\n    return this.readUIntN(1)\n  }\n\n  readUInt16(): number {\n    return this.readUIntN(2)\n  }\n\n  readUInt32(): number {\n    return this.readUIntN(4)\n  }\n\n  size(): number {\n    return this.bytes.byteLength\n  }\n\n  end(customEnd?: number): boolean {\n    const length = this.bytes.byteLength\n    return length === 0 || (customEnd !== undefined && length <= customEnd)\n  }\n\n  /**\n   * Reads variable length encoded bytes\n   *\n   * @return The variable length bytes\n   */\n  readVariableLength(): Uint8Array {\n    return this.read(this.readVariableLengthLength())\n  }\n\n  /**\n   * Reads the length of the variable length encoded bytes\n   *\n   * @return The length of the variable length encoded bytes\n   */\n  readVariableLengthLength(): number {\n    const b1 = this.readUInt8()\n    if (b1 <= 192) {\n      return b1\n    } else if (b1 <= 240) {\n      const b2 = this.readUInt8()\n      return 193 + (b1 - 193) * 256 + b2\n    } else if (b1 <= 254) {\n      const b2 = this.readUInt8()\n      const b3 = this.readUInt8()\n      return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3\n    }\n    throw new Error('Invalid variable length indicator')\n  }\n\n  /**\n   * Reads the field ordinal from the BinaryParser\n   *\n   * @return Field ordinal\n   */\n  readFieldOrdinal(): number {\n    let type = this.readUInt8()\n    let nth = type & 15\n    type >>= 4\n\n    if (type === 0) {\n      type = this.readUInt8()\n      if (type === 0 || type < 16) {\n        throw new Error('Cannot read FieldOrdinal, type_code out of range')\n      }\n    }\n\n    if (nth === 0) {\n      nth = this.readUInt8()\n      if (nth === 0 || nth < 16) {\n        throw new Error('Cannot read FieldOrdinal, field_code out of range')\n      }\n    }\n\n    return (type << 16) | nth\n  }\n\n  /**\n   * Read the field from the BinaryParser\n   *\n   * @return The field represented by the bytes at the head of the BinaryParser\n   */\n  readField(): FieldInstance {\n    return this.definitions.field.fromString(this.readFieldOrdinal().toString())\n  }\n\n  /**\n   * Read a given type from the BinaryParser\n   *\n   * @param type The type that you want to read from the BinaryParser\n   * @return The instance of that type read from the BinaryParser\n   */\n  readType(type: typeof SerializedType): SerializedType {\n    return type.fromParser(this)\n  }\n\n  /**\n   * Get the type associated with a given field\n   *\n   * @param field The field that you wan to get the type of\n   * @return The type associated with the given field\n   */\n  typeForField(field: FieldInstance): typeof SerializedType {\n    return field.associatedType\n  }\n\n  /**\n   * Read value of the type specified by field from the BinaryParser\n   *\n   * @param field The field that you want to get the associated value for\n   * @return The value associated with the given field\n   */\n  readFieldValue(field: FieldInstance): SerializedType {\n    const type = this.typeForField(field)\n    if (!type) {\n      throw new Error(`unsupported: (${field.name}, ${field.type.name})`)\n    }\n    const sizeHint = field.isVariableLengthEncoded\n      ? this.readVariableLengthLength()\n      : undefined\n    const value = type.fromParser(this, sizeHint)\n    if (value === undefined) {\n      throw new Error(\n        `fromParser for (${field.name}, ${field.type.name}) -> undefined `,\n      )\n    }\n    return value\n  }\n\n  /**\n   * Get the next field and value from the BinaryParser\n   *\n   * @return The field and value\n   */\n  readFieldAndValue(): [FieldInstance, SerializedType] {\n    const field = this.readField()\n    return [field, this.readFieldValue(field)]\n  }\n}\n\nexport { BinaryParser }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}