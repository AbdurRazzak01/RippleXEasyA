{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst errors_1 = require(\"../../../errors\");\nconst HashPrefix_1 = __importDefault(require(\"../HashPrefix\"));\nconst sha512Half_1 = __importDefault(require(\"../sha512Half\"));\nconst LeafNode_1 = __importDefault(require(\"./LeafNode\"));\nconst node_1 = require(\"./node\");\nconst HEX_ZERO = '0000000000000000000000000000000000000000000000000000000000000000';\nconst SLOT_MAX = 15;\nconst HEX = 16;\nclass InnerNode extends node_1.Node {\n  constructor(depth = 0) {\n    super();\n    this.leaves = {};\n    this.type = node_1.NodeType.INNER;\n    this.depth = depth;\n    this.empty = true;\n  }\n  get hash() {\n    if (this.empty) {\n      return HEX_ZERO;\n    }\n    let hex = '';\n    for (let iter = 0; iter <= SLOT_MAX; iter++) {\n      const child = this.leaves[iter];\n      const hash = child == null ? HEX_ZERO : child.hash;\n      hex += hash;\n    }\n    const prefix = HashPrefix_1.default.INNER_NODE.toString(HEX);\n    return (0, sha512Half_1.default)(prefix + hex);\n  }\n  addItem(tag, node) {\n    const existingNode = this.getNode(parseInt(tag[this.depth], HEX));\n    if (existingNode === undefined) {\n      this.setNode(parseInt(tag[this.depth], HEX), node);\n      return;\n    }\n    if (existingNode instanceof InnerNode) {\n      existingNode.addItem(tag, node);\n    } else if (existingNode instanceof LeafNode_1.default) {\n      if (existingNode.tag === tag) {\n        throw new errors_1.XrplError('Tried to add a node to a SHAMap that was already in there.');\n      } else {\n        const newInnerNode = new InnerNode(this.depth + 1);\n        newInnerNode.addItem(existingNode.tag, existingNode);\n        newInnerNode.addItem(tag, node);\n        this.setNode(parseInt(tag[this.depth], HEX), newInnerNode);\n      }\n    }\n  }\n  setNode(slot, node) {\n    if (slot < 0 || slot > SLOT_MAX) {\n      throw new errors_1.XrplError('Invalid slot: slot must be between 0-15.');\n    }\n    this.leaves[slot] = node;\n    this.empty = false;\n  }\n  getNode(slot) {\n    if (slot < 0 || slot > SLOT_MAX) {\n      throw new errors_1.XrplError('Invalid slot: slot must be between 0-15.');\n    }\n    return this.leaves[slot];\n  }\n}\nexports.default = InnerNode;","map":{"version":3,"names":["errors_1","require","HashPrefix_1","__importDefault","sha512Half_1","LeafNode_1","node_1","HEX_ZERO","SLOT_MAX","HEX","InnerNode","Node","constructor","depth","leaves","type","NodeType","INNER","empty","hash","hex","iter","child","prefix","default","INNER_NODE","toString","addItem","tag","node","existingNode","getNode","parseInt","undefined","setNode","XrplError","newInnerNode","slot","exports"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/utils/hashes/SHAMap/InnerNode.ts"],"sourcesContent":["import { XrplError } from '../../../errors'\nimport HashPrefix from '../HashPrefix'\nimport sha512Half from '../sha512Half'\n\nimport LeafNode from './LeafNode'\nimport { NodeType, Node } from './node'\n\nconst HEX_ZERO =\n  '0000000000000000000000000000000000000000000000000000000000000000'\n\nconst SLOT_MAX = 15\nconst HEX = 16\n\n/**\n * Class for SHAMap InnerNode.\n */\nclass InnerNode extends Node {\n  public leaves: { [slot: number]: Node | undefined }\n  public type: NodeType\n  public depth: number\n  public empty: boolean\n\n  /**\n   * Define an Inner (non-leaf) node in a SHAMap tree.\n   *\n   * @param depth - I.e. How many parent inner nodes.\n   */\n  public constructor(depth = 0) {\n    super()\n    this.leaves = {}\n    this.type = NodeType.INNER\n    this.depth = depth\n    this.empty = true\n  }\n\n  /**\n   * Get the hash of a LeafNode.\n   *\n   * @returns Hash of the LeafNode.\n   */\n  public get hash(): string {\n    if (this.empty) {\n      return HEX_ZERO\n    }\n    let hex = ''\n    for (let iter = 0; iter <= SLOT_MAX; iter++) {\n      const child = this.leaves[iter]\n      const hash: string = child == null ? HEX_ZERO : child.hash\n      hex += hash\n    }\n\n    const prefix = HashPrefix.INNER_NODE.toString(HEX)\n    return sha512Half(prefix + hex)\n  }\n\n  /**\n   * Adds an item to the InnerNode.\n   *\n   * @param tag - Equates to a ledger entry `index`.\n   * @param node - Node to add.\n   * @throws If there is a index collision.\n   */\n  public addItem(tag: string, node: Node): void {\n    const existingNode = this.getNode(parseInt(tag[this.depth], HEX))\n\n    if (existingNode === undefined) {\n      this.setNode(parseInt(tag[this.depth], HEX), node)\n      return\n    }\n\n    // A node already exists in this slot\n    if (existingNode instanceof InnerNode) {\n      // There is an inner node, so we need to go deeper\n      existingNode.addItem(tag, node)\n    } else if (existingNode instanceof LeafNode) {\n      if (existingNode.tag === tag) {\n        // Collision\n        throw new XrplError(\n          'Tried to add a node to a SHAMap that was already in there.',\n        )\n      } else {\n        const newInnerNode = new InnerNode(this.depth + 1)\n\n        // Parent new and existing node\n        newInnerNode.addItem(existingNode.tag, existingNode)\n        newInnerNode.addItem(tag, node)\n\n        // And place the newly created inner node in the slot\n        this.setNode(parseInt(tag[this.depth], HEX), newInnerNode)\n      }\n    }\n  }\n\n  /**\n   * Overwrite the node that is currently in a given slot.\n   *\n   * @param slot - A number 0-15.\n   * @param node - To place.\n   * @throws If slot is out of range.\n   */\n  public setNode(slot: number, node: Node): void {\n    if (slot < 0 || slot > SLOT_MAX) {\n      throw new XrplError('Invalid slot: slot must be between 0-15.')\n    }\n    this.leaves[slot] = node\n    this.empty = false\n  }\n\n  /**\n   * Get the node that is currently in a given slot.\n   *\n   * @param slot - A number 0-15.\n   * @returns Node currently in a slot.\n   * @throws If slot is out of range.\n   */\n  public getNode(slot: number): Node | undefined {\n    if (slot < 0 || slot > SLOT_MAX) {\n      throw new XrplError('Invalid slot: slot must be between 0-15.')\n    }\n    return this.leaves[slot]\n  }\n}\n\nexport default InnerNode\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}