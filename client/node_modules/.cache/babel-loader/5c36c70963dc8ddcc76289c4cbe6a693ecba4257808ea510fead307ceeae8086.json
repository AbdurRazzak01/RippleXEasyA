{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;\nconst hash_prefixes_1 = require(\"./hash-prefixes\");\nconst types_1 = require(\"./types\");\nconst binary_serializer_1 = require(\"./serdes/binary-serializer\");\nconst sha512_1 = require(\"@xrplf/isomorphic/sha512\");\n/**\n * Class for hashing with SHA512\n * @extends BytesList So SerializedTypes can write bytes to a Sha512Half\n */\nclass Sha512Half extends binary_serializer_1.BytesList {\n  constructor() {\n    super(...arguments);\n    this.hash = sha512_1.sha512.create();\n  }\n  /**\n   * Construct a new Sha512Hash and write bytes this.hash\n   *\n   * @param bytes bytes to write to this.hash\n   * @returns the new Sha512Hash object\n   */\n  static put(bytes) {\n    return new Sha512Half().put(bytes);\n  }\n  /**\n   * Write bytes to an existing Sha512Hash\n   *\n   * @param bytes bytes to write to object\n   * @returns the Sha512 object\n   */\n  put(bytes) {\n    this.hash.update(bytes);\n    return this;\n  }\n  /**\n   * Compute SHA512 hash and slice in half\n   *\n   * @returns half of a SHA512 hash\n   */\n  finish256() {\n    return Uint8Array.from(this.hash.digest().slice(0, 32));\n  }\n  /**\n   * Constructs a Hash256 from the Sha512Half object\n   *\n   * @returns a Hash256 object\n   */\n  finish() {\n    return new types_1.Hash256(this.finish256());\n  }\n}\nexports.Sha512Half = Sha512Half;\n/**\n * compute SHA512 hash of a list of bytes\n *\n * @param args zero or more arguments to hash\n * @returns the sha512half hash of the arguments.\n */\nfunction sha512Half(...args) {\n  const hash = new Sha512Half();\n  args.forEach(a => hash.put(a));\n  return hash.finish256();\n}\nexports.sha512Half = sha512Half;\n/**\n * Construct a transactionID from a Serialized Transaction\n *\n * @param serialized bytes to hash\n * @returns a Hash256 object\n */\nfunction transactionID(serialized) {\n  return new types_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));\n}\nexports.transactionID = transactionID;","map":{"version":3,"names":["hash_prefixes_1","require","types_1","binary_serializer_1","sha512_1","Sha512Half","BytesList","constructor","hash","sha512","create","put","bytes","update","finish256","Uint8Array","from","digest","slice","finish","Hash256","exports","sha512Half","args","forEach","a","transactionID","serialized","HashPrefix"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/hashes.ts"],"sourcesContent":["import { HashPrefix } from './hash-prefixes'\nimport { Hash256 } from './types'\nimport { BytesList } from './serdes/binary-serializer'\nimport { sha512 } from '@xrplf/isomorphic/sha512'\n\n/**\n * Class for hashing with SHA512\n * @extends BytesList So SerializedTypes can write bytes to a Sha512Half\n */\nclass Sha512Half extends BytesList {\n  private hash = sha512.create()\n\n  /**\n   * Construct a new Sha512Hash and write bytes this.hash\n   *\n   * @param bytes bytes to write to this.hash\n   * @returns the new Sha512Hash object\n   */\n  static put(bytes: Uint8Array): Sha512Half {\n    return new Sha512Half().put(bytes)\n  }\n\n  /**\n   * Write bytes to an existing Sha512Hash\n   *\n   * @param bytes bytes to write to object\n   * @returns the Sha512 object\n   */\n  put(bytes: Uint8Array): Sha512Half {\n    this.hash.update(bytes)\n    return this\n  }\n\n  /**\n   * Compute SHA512 hash and slice in half\n   *\n   * @returns half of a SHA512 hash\n   */\n  finish256(): Uint8Array {\n    return Uint8Array.from(this.hash.digest().slice(0, 32))\n  }\n\n  /**\n   * Constructs a Hash256 from the Sha512Half object\n   *\n   * @returns a Hash256 object\n   */\n  finish(): Hash256 {\n    return new Hash256(this.finish256())\n  }\n}\n\n/**\n * compute SHA512 hash of a list of bytes\n *\n * @param args zero or more arguments to hash\n * @returns the sha512half hash of the arguments.\n */\nfunction sha512Half(...args: Uint8Array[]): Uint8Array {\n  const hash = new Sha512Half()\n  args.forEach((a) => hash.put(a))\n  return hash.finish256()\n}\n\n/**\n * Construct a transactionID from a Serialized Transaction\n *\n * @param serialized bytes to hash\n * @returns a Hash256 object\n */\nfunction transactionID(serialized: Uint8Array): Hash256 {\n  return new Hash256(sha512Half(HashPrefix.transactionID, serialized))\n}\n\nexport { Sha512Half, sha512Half, transactionID }\n"],"mappings":";;;;;;AAAA,MAAAA,eAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,mBAAA,GAAAF,OAAA;AACA,MAAAG,QAAA,GAAAH,OAAA;AAEA;;;;AAIA,MAAMI,UAAW,SAAQF,mBAAA,CAAAG,SAAS;EAAlCC,YAAA;;IACU,KAAAC,IAAI,GAAGJ,QAAA,CAAAK,MAAM,CAACC,MAAM,EAAE;EAwChC;EAtCE;;;;;;EAMA,OAAOC,GAAGA,CAACC,KAAiB;IAC1B,OAAO,IAAIP,UAAU,EAAE,CAACM,GAAG,CAACC,KAAK,CAAC;EACpC;EAEA;;;;;;EAMAD,GAAGA,CAACC,KAAiB;IACnB,IAAI,CAACJ,IAAI,CAACK,MAAM,CAACD,KAAK,CAAC;IACvB,OAAO,IAAI;EACb;EAEA;;;;;EAKAE,SAASA,CAAA;IACP,OAAOC,UAAU,CAACC,IAAI,CAAC,IAAI,CAACR,IAAI,CAACS,MAAM,EAAE,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACzD;EAEA;;;;;EAKAC,MAAMA,CAAA;IACJ,OAAO,IAAIjB,OAAA,CAAAkB,OAAO,CAAC,IAAI,CAACN,SAAS,EAAE,CAAC;EACtC;;AAyBOO,OAAA,CAAAhB,UAAA,GAAAA,UAAA;AAtBT;;;;;;AAMA,SAASiB,UAAUA,CAAC,GAAGC,IAAkB;EACvC,MAAMf,IAAI,GAAG,IAAIH,UAAU,EAAE;EAC7BkB,IAAI,CAACC,OAAO,CAAEC,CAAC,IAAKjB,IAAI,CAACG,GAAG,CAACc,CAAC,CAAC,CAAC;EAChC,OAAOjB,IAAI,CAACM,SAAS,EAAE;AACzB;AAYqBO,OAAA,CAAAC,UAAA,GAAAA,UAAA;AAVrB;;;;;;AAMA,SAASI,aAAaA,CAACC,UAAsB;EAC3C,OAAO,IAAIzB,OAAA,CAAAkB,OAAO,CAACE,UAAU,CAACtB,eAAA,CAAA4B,UAAU,CAACF,aAAa,EAAEC,UAAU,CAAC,CAAC;AACtE;AAEiCN,OAAA,CAAAK,aAAA,GAAAA,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}