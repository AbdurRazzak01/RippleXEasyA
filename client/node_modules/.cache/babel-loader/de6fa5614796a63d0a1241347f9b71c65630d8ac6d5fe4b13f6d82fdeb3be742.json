{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../errors\");\nconst LEDGER_CLOSE_TIME = 1000;\nfunction sleep(ms) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  });\n}\nfunction submitRequest(client, signedTransaction, failHard = false) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!isSigned(signedTransaction)) {\n      throw new errors_1.ValidationError('Transaction must be signed');\n    }\n    const signedTxEncoded = typeof signedTransaction === 'string' ? signedTransaction : (0, ripple_binary_codec_1.encode)(signedTransaction);\n    const request = {\n      command: 'submit',\n      tx_blob: signedTxEncoded,\n      fail_hard: isAccountDelete(signedTransaction) || failHard\n    };\n    return client.request(request);\n  });\n}\nexports.submitRequest = submitRequest;\nfunction waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sleep(LEDGER_CLOSE_TIME);\n    const latestLedger = yield client.getLedgerIndex();\n    if (lastLedger < latestLedger) {\n      throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).\\n` + `Preliminary result: ${submissionResult}`);\n    }\n    const txResponse = yield client.request({\n      command: 'tx',\n      transaction: txHash\n    }).catch(error => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const message = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;\n      if (message === 'txnNotFound') {\n        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n      }\n      throw new Error(`${message} \\n Preliminary result: ${submissionResult}.\\nFull error details: ${String(error)}`);\n    }));\n    if (txResponse.result.validated) {\n      return txResponse;\n    }\n    return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n  });\n}\nexports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;\nfunction isSigned(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  if (typeof tx === 'string') {\n    return false;\n  }\n  if (tx.Signers != null) {\n    const signers = tx.Signers;\n    for (const signer of signers) {\n      if (signer.Signer.SigningPubKey == null || signer.Signer.TxnSignature == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return tx.SigningPubKey != null && tx.TxnSignature != null;\n}\nfunction getSignedTx(client, transaction, {\n  autofill = true,\n  wallet\n} = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (isSigned(transaction)) {\n      return transaction;\n    }\n    if (!wallet) {\n      throw new errors_1.ValidationError('Wallet must be provided when submitting an unsigned transaction');\n    }\n    let tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n    if (autofill) {\n      tx = yield client.autofill(tx);\n    }\n    return wallet.sign(tx).tx_blob;\n  });\n}\nexports.getSignedTx = getSignedTx;\nfunction getLastLedgerSequence(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  return tx.LastLedgerSequence;\n}\nexports.getLastLedgerSequence = getLastLedgerSequence;\nfunction isAccountDelete(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  return tx.TransactionType === 'AccountDelete';\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","getLastLedgerSequence","getSignedTx","waitForFinalTransactionOutcome","submitRequest","ripple_binary_codec_1","require","errors_1","LEDGER_CLOSE_TIME","sleep","ms","setTimeout","client","signedTransaction","failHard","isSigned","ValidationError","signedTxEncoded","encode","request","command","tx_blob","fail_hard","isAccountDelete","txHash","lastLedger","submissionResult","latestLedger","getLedgerIndex","XrplError","txResponse","transaction","catch","error","_a","message","data","Error","String","validated","tx","decode","Signers","signers","signer","Signer","SigningPubKey","TxnSignature","autofill","wallet","sign","LastLedgerSequence","TransactionType"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/sugar/submit.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../errors\");\nconst LEDGER_CLOSE_TIME = 1000;\nfunction sleep(ms) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            setTimeout(resolve, ms);\n        });\n    });\n}\nfunction submitRequest(client, signedTransaction, failHard = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!isSigned(signedTransaction)) {\n            throw new errors_1.ValidationError('Transaction must be signed');\n        }\n        const signedTxEncoded = typeof signedTransaction === 'string'\n            ? signedTransaction\n            : (0, ripple_binary_codec_1.encode)(signedTransaction);\n        const request = {\n            command: 'submit',\n            tx_blob: signedTxEncoded,\n            fail_hard: isAccountDelete(signedTransaction) || failHard,\n        };\n        return client.request(request);\n    });\n}\nexports.submitRequest = submitRequest;\nfunction waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sleep(LEDGER_CLOSE_TIME);\n        const latestLedger = yield client.getLedgerIndex();\n        if (lastLedger < latestLedger) {\n            throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).\\n` +\n                `Preliminary result: ${submissionResult}`);\n        }\n        const txResponse = yield client\n            .request({\n            command: 'tx',\n            transaction: txHash,\n        })\n            .catch((error) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const message = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;\n            if (message === 'txnNotFound') {\n                return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n            }\n            throw new Error(`${message} \\n Preliminary result: ${submissionResult}.\\nFull error details: ${String(error)}`);\n        }));\n        if (txResponse.result.validated) {\n            return txResponse;\n        }\n        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n    });\n}\nexports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;\nfunction isSigned(transaction) {\n    const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n    if (typeof tx === 'string') {\n        return false;\n    }\n    if (tx.Signers != null) {\n        const signers = tx.Signers;\n        for (const signer of signers) {\n            if (signer.Signer.SigningPubKey == null ||\n                signer.Signer.TxnSignature == null) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return tx.SigningPubKey != null && tx.TxnSignature != null;\n}\nfunction getSignedTx(client, transaction, { autofill = true, wallet, } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (isSigned(transaction)) {\n            return transaction;\n        }\n        if (!wallet) {\n            throw new errors_1.ValidationError('Wallet must be provided when submitting an unsigned transaction');\n        }\n        let tx = typeof transaction === 'string'\n            ?\n                (0, ripple_binary_codec_1.decode)(transaction)\n            : transaction;\n        if (autofill) {\n            tx = yield client.autofill(tx);\n        }\n        return wallet.sign(tx).tx_blob;\n    });\n}\nexports.getSignedTx = getSignedTx;\nfunction getLastLedgerSequence(transaction) {\n    const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n    return tx.LastLedgerSequence;\n}\nexports.getLastLedgerSequence = getLastLedgerSequence;\nfunction isAccountDelete(transaction) {\n    const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n    return tx.TransactionType === 'AccountDelete';\n}\n//# sourceMappingURL=submit.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}