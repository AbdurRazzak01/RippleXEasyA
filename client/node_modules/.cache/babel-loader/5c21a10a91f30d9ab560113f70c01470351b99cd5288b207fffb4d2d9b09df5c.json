{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinarySerializer = exports.BytesList = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * Bytes list is a collection of Uint8Array objects\n */\nclass BytesList {\n  constructor() {\n    this.bytesArray = [];\n  }\n  /**\n   * Get the total number of bytes in the BytesList\n   *\n   * @return the number of bytes\n   */\n  getLength() {\n    return (0, utils_1.concat)(this.bytesArray).byteLength;\n  }\n  /**\n   * Put bytes in the BytesList\n   *\n   * @param bytesArg A Uint8Array\n   * @return this BytesList\n   */\n  put(bytesArg) {\n    const bytes = Uint8Array.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in\n    this.bytesArray.push(bytes);\n    return this;\n  }\n  /**\n   * Write this BytesList to the back of another bytes list\n   *\n   *  @param list The BytesList to write to\n   */\n  toBytesSink(list) {\n    list.put(this.toBytes());\n  }\n  toBytes() {\n    return (0, utils_1.concat)(this.bytesArray);\n  }\n  toHex() {\n    return (0, utils_1.bytesToHex)(this.toBytes());\n  }\n}\nexports.BytesList = BytesList;\n/**\n * BinarySerializer is used to write fields and values to Uint8Arrays\n */\nclass BinarySerializer {\n  constructor(sink) {\n    this.sink = new BytesList();\n    this.sink = sink;\n  }\n  /**\n   * Write a value to this BinarySerializer\n   *\n   * @param value a SerializedType value\n   */\n  write(value) {\n    value.toBytesSink(this.sink);\n  }\n  /**\n   * Write bytes to this BinarySerializer\n   *\n   * @param bytes the bytes to write\n   */\n  put(bytes) {\n    this.sink.put(bytes);\n  }\n  /**\n   * Write a value of a given type to this BinarySerializer\n   *\n   * @param type the type to write\n   * @param value a value of that type\n   */\n  writeType(type, value) {\n    this.write(type.from(value));\n  }\n  /**\n   * Write BytesList to this BinarySerializer\n   *\n   * @param bl BytesList to write to BinarySerializer\n   */\n  writeBytesList(bl) {\n    bl.toBytesSink(this.sink);\n  }\n  /**\n   * Calculate the header of Variable Length encoded bytes\n   *\n   * @param length the length of the bytes\n   */\n  encodeVariableLength(length) {\n    const lenBytes = new Uint8Array(3);\n    if (length <= 192) {\n      lenBytes[0] = length;\n      return lenBytes.slice(0, 1);\n    } else if (length <= 12480) {\n      length -= 193;\n      lenBytes[0] = 193 + (length >>> 8);\n      lenBytes[1] = length & 0xff;\n      return lenBytes.slice(0, 2);\n    } else if (length <= 918744) {\n      length -= 12481;\n      lenBytes[0] = 241 + (length >>> 16);\n      lenBytes[1] = length >> 8 & 0xff;\n      lenBytes[2] = length & 0xff;\n      return lenBytes.slice(0, 3);\n    }\n    throw new Error('Overflow error');\n  }\n  /**\n   * Write field and value to BinarySerializer\n   *\n   * @param field field to write to BinarySerializer\n   * @param value value to write to BinarySerializer\n   */\n  writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {\n    const associatedValue = field.associatedType.from(value);\n    if (associatedValue.toBytesSink === undefined || field.name === undefined) {\n      throw new Error();\n    }\n    this.sink.put(field.header);\n    if (field.isVariableLengthEncoded) {\n      this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);\n    } else {\n      associatedValue.toBytesSink(this.sink);\n    }\n  }\n  /**\n   * Write a variable length encoded value to the BinarySerializer\n   *\n   * @param value length encoded value to write to BytesList\n   */\n  writeLengthEncoded(value, isUnlModifyWorkaround = false) {\n    const bytes = new BytesList();\n    if (!isUnlModifyWorkaround) {\n      // this part doesn't happen for the Account field in a UNLModify transaction\n      value.toBytesSink(bytes);\n    }\n    this.put(this.encodeVariableLength(bytes.getLength()));\n    this.writeBytesList(bytes);\n  }\n}\nexports.BinarySerializer = BinarySerializer;","map":{"version":3,"names":["utils_1","require","BytesList","constructor","bytesArray","getLength","concat","byteLength","put","bytesArg","bytes","Uint8Array","from","push","toBytesSink","list","toBytes","toHex","bytesToHex","exports","BinarySerializer","sink","write","value","writeType","type","writeBytesList","bl","encodeVariableLength","length","lenBytes","slice","Error","writeFieldAndValue","field","isUnlModifyWorkaround","associatedValue","associatedType","undefined","name","header","isVariableLengthEncoded","writeLengthEncoded"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/serdes/binary-serializer.ts"],"sourcesContent":["import { FieldInstance } from '../enums'\nimport { type SerializedType } from '../types/serialized-type'\nimport { bytesToHex, concat } from '@xrplf/isomorphic/utils'\n\n/**\n * Bytes list is a collection of Uint8Array objects\n */\nclass BytesList {\n  private bytesArray: Array<Uint8Array> = []\n\n  /**\n   * Get the total number of bytes in the BytesList\n   *\n   * @return the number of bytes\n   */\n  public getLength(): number {\n    return concat(this.bytesArray).byteLength\n  }\n\n  /**\n   * Put bytes in the BytesList\n   *\n   * @param bytesArg A Uint8Array\n   * @return this BytesList\n   */\n  public put(bytesArg: Uint8Array): BytesList {\n    const bytes = Uint8Array.from(bytesArg) // Temporary, to catch instances of Uint8Array being passed in\n    this.bytesArray.push(bytes)\n    return this\n  }\n\n  /**\n   * Write this BytesList to the back of another bytes list\n   *\n   *  @param list The BytesList to write to\n   */\n  public toBytesSink(list: BytesList): void {\n    list.put(this.toBytes())\n  }\n\n  public toBytes(): Uint8Array {\n    return concat(this.bytesArray)\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes())\n  }\n}\n\n/**\n * BinarySerializer is used to write fields and values to Uint8Arrays\n */\nclass BinarySerializer {\n  private sink: BytesList = new BytesList()\n\n  constructor(sink: BytesList) {\n    this.sink = sink\n  }\n\n  /**\n   * Write a value to this BinarySerializer\n   *\n   * @param value a SerializedType value\n   */\n  write(value: SerializedType): void {\n    value.toBytesSink(this.sink)\n  }\n\n  /**\n   * Write bytes to this BinarySerializer\n   *\n   * @param bytes the bytes to write\n   */\n  put(bytes: Uint8Array): void {\n    this.sink.put(bytes)\n  }\n\n  /**\n   * Write a value of a given type to this BinarySerializer\n   *\n   * @param type the type to write\n   * @param value a value of that type\n   */\n  writeType(type: typeof SerializedType, value: SerializedType): void {\n    this.write(type.from(value))\n  }\n\n  /**\n   * Write BytesList to this BinarySerializer\n   *\n   * @param bl BytesList to write to BinarySerializer\n   */\n  writeBytesList(bl: BytesList): void {\n    bl.toBytesSink(this.sink)\n  }\n\n  /**\n   * Calculate the header of Variable Length encoded bytes\n   *\n   * @param length the length of the bytes\n   */\n  private encodeVariableLength(length: number): Uint8Array {\n    const lenBytes = new Uint8Array(3)\n    if (length <= 192) {\n      lenBytes[0] = length\n      return lenBytes.slice(0, 1)\n    } else if (length <= 12480) {\n      length -= 193\n      lenBytes[0] = 193 + (length >>> 8)\n      lenBytes[1] = length & 0xff\n      return lenBytes.slice(0, 2)\n    } else if (length <= 918744) {\n      length -= 12481\n      lenBytes[0] = 241 + (length >>> 16)\n      lenBytes[1] = (length >> 8) & 0xff\n      lenBytes[2] = length & 0xff\n      return lenBytes.slice(0, 3)\n    }\n    throw new Error('Overflow error')\n  }\n\n  /**\n   * Write field and value to BinarySerializer\n   *\n   * @param field field to write to BinarySerializer\n   * @param value value to write to BinarySerializer\n   */\n  writeFieldAndValue(\n    field: FieldInstance,\n    value: SerializedType,\n    isUnlModifyWorkaround = false,\n  ): void {\n    const associatedValue = field.associatedType.from(value)\n    if (associatedValue.toBytesSink === undefined || field.name === undefined) {\n      throw new Error()\n    }\n\n    this.sink.put(field.header)\n\n    if (field.isVariableLengthEncoded) {\n      this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround)\n    } else {\n      associatedValue.toBytesSink(this.sink)\n    }\n  }\n\n  /**\n   * Write a variable length encoded value to the BinarySerializer\n   *\n   * @param value length encoded value to write to BytesList\n   */\n  public writeLengthEncoded(\n    value: SerializedType,\n    isUnlModifyWorkaround = false,\n  ): void {\n    const bytes = new BytesList()\n    if (!isUnlModifyWorkaround) {\n      // this part doesn't happen for the Account field in a UNLModify transaction\n      value.toBytesSink(bytes)\n    }\n    this.put(this.encodeVariableLength(bytes.getLength()))\n    this.writeBytesList(bytes)\n  }\n}\n\nexport { BytesList, BinarySerializer }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}