{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../errors\");\nconst LEDGER_CLOSE_TIME = 1000;\nfunction sleep(ms) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  });\n}\nfunction submitRequest(client, signedTransaction, failHard = false) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!isSigned(signedTransaction)) {\n      throw new errors_1.ValidationError('Transaction must be signed');\n    }\n    const signedTxEncoded = typeof signedTransaction === 'string' ? signedTransaction : (0, ripple_binary_codec_1.encode)(signedTransaction);\n    const request = {\n      command: 'submit',\n      tx_blob: signedTxEncoded,\n      fail_hard: isAccountDelete(signedTransaction) || failHard\n    };\n    return client.request(request);\n  });\n}\nexports.submitRequest = submitRequest;\nfunction waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sleep(LEDGER_CLOSE_TIME);\n    const latestLedger = yield client.getLedgerIndex();\n    if (lastLedger < latestLedger) {\n      throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).\\n` + `Preliminary result: ${submissionResult}`);\n    }\n    const txResponse = yield client.request({\n      command: 'tx',\n      transaction: txHash\n    }).catch(error => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const message = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;\n      if (message === 'txnNotFound') {\n        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n      }\n      throw new Error(`${message} \\n Preliminary result: ${submissionResult}.\\nFull error details: ${String(error)}`);\n    }));\n    if (txResponse.result.validated) {\n      return txResponse;\n    }\n    return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);\n  });\n}\nexports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;\nfunction isSigned(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  if (typeof tx === 'string') {\n    return false;\n  }\n  if (tx.Signers != null) {\n    const signers = tx.Signers;\n    for (const signer of signers) {\n      if (signer.Signer.SigningPubKey == null || signer.Signer.TxnSignature == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return tx.SigningPubKey != null && tx.TxnSignature != null;\n}\nfunction getSignedTx(client, transaction, {\n  autofill = true,\n  wallet\n} = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (isSigned(transaction)) {\n      return transaction;\n    }\n    if (!wallet) {\n      throw new errors_1.ValidationError('Wallet must be provided when submitting an unsigned transaction');\n    }\n    let tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n    if (autofill) {\n      tx = yield client.autofill(tx);\n    }\n    return wallet.sign(tx).tx_blob;\n  });\n}\nexports.getSignedTx = getSignedTx;\nfunction getLastLedgerSequence(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  return tx.LastLedgerSequence;\n}\nexports.getLastLedgerSequence = getLastLedgerSequence;\nfunction isAccountDelete(transaction) {\n  const tx = typeof transaction === 'string' ? (0, ripple_binary_codec_1.decode)(transaction) : transaction;\n  return tx.TransactionType === 'AccountDelete';\n}","map":{"version":3,"names":["ripple_binary_codec_1","require","errors_1","LEDGER_CLOSE_TIME","sleep","ms","Promise","resolve","setTimeout","submitRequest","client","signedTransaction","failHard","isSigned","ValidationError","signedTxEncoded","encode","request","command","tx_blob","fail_hard","isAccountDelete","exports","waitForFinalTransactionOutcome","txHash","lastLedger","submissionResult","latestLedger","getLedgerIndex","XrplError","txResponse","transaction","catch","error","__awaiter","message","_a","data","Error","String","result","validated","tx","decode","Signers","signers","signer","Signer","SigningPubKey","TxnSignature","getSignedTx","autofill","wallet","sign","getLastLedgerSequence","LastLedgerSequence","TransactionType"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/sugar/submit.ts"],"sourcesContent":["import { decode, encode } from 'ripple-binary-codec'\n\nimport type {\n  Client,\n  SubmitRequest,\n  SubmitResponse,\n  SubmittableTransaction,\n  Transaction,\n  Wallet,\n} from '..'\nimport { ValidationError, XrplError } from '../errors'\nimport { Signer } from '../models/common'\nimport { TxRequest, TxResponse } from '../models/methods'\nimport { BaseTransaction } from '../models/transactions/common'\n\n/** Approximate time for a ledger to close, in milliseconds */\nconst LEDGER_CLOSE_TIME = 1000\n\nasync function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\n// Helper functions\n\n/**\n * Submits a request to the client with a signed transaction.\n *\n * @param client - The client to submit the request to.\n * @param signedTransaction - The signed transaction to submit. It can be either a Transaction object or a\n * string (encode from ripple-binary-codec) representation of the transaction.\n * @param [failHard=false] - Optional. Determines whether the submission should fail hard (true) or not (false). Default is false.\n * @returns A promise that resolves with the response from the client.\n * @throws {ValidationError} If the signed transaction is not valid (not signed).\n *\n * @example\n * import { Client } from \"xrpl\"\n * const client = new Client(\"wss://s.altnet.rippletest.net:51233\");\n * await client.connect();\n * const signedTransaction = createSignedTransaction();\n * // Example 1: Submitting a Transaction object\n * const response1 = await submitRequest(client, signedTransaction);\n *\n * // Example 2: Submitting a string representation of the transaction\n * const signedTransactionString = encode(signedTransaction);\n * const response2 = await submitRequest(client, signedTransactionString, true);\n */\nexport async function submitRequest(\n  client: Client,\n  signedTransaction: SubmittableTransaction | string,\n  failHard = false,\n): Promise<SubmitResponse> {\n  if (!isSigned(signedTransaction)) {\n    throw new ValidationError('Transaction must be signed')\n  }\n\n  const signedTxEncoded =\n    typeof signedTransaction === 'string'\n      ? signedTransaction\n      : encode(signedTransaction)\n  const request: SubmitRequest = {\n    command: 'submit',\n    tx_blob: signedTxEncoded,\n    fail_hard: isAccountDelete(signedTransaction) || failHard,\n  }\n  return client.request(request)\n}\n\n/**\n * Waits for the final outcome of a transaction by polling the ledger until the result can be considered final,\n * meaning it has either been included in a validated ledger, or the transaction's lastLedgerSequence has been\n * surpassed by the latest ledger sequence (meaning it will never be included in a validated ledger).\n *\n * @template T - The type of the transaction. Defaults to `Transaction`.\n * @param client - The client to use for requesting transaction information.\n * @param txHash - The hash of the transaction to wait for.\n * @param lastLedger - The last ledger sequence of the transaction.\n * @param submissionResult - The preliminary result of the transaction.\n * @returns A promise that resolves with the final transaction response.\n *\n * @throws {XrplError} If the latest ledger sequence surpasses the transaction's lastLedgerSequence.\n *\n * @example\n * import { hashes, Client } from \"xrpl\"\n * const client = new Client(\"wss://s.altnet.rippletest.net:51233\")\n * await client.connect()\n *\n * const transaction = createTransaction() // your transaction function\n *\n * const signedTx = await getSignedTx(this, transaction)\n *\n * const lastLedger = getLastLedgerSequence(signedTx)\n *\n * if (lastLedger == null) {\n *   throw new ValidationError(\n *     'Transaction must contain a LastLedgerSequence value for reliable submission.',\n *   )\n * }\n *\n * const response = await submitRequest(this, signedTx, opts?.failHard)\n *\n * const txHash = hashes.hashSignedTx(signedTx)\n * return waitForFinalTransactionOutcome(\n *   this,\n *   txHash,\n *   lastLedger,\n *   response.result.engine_result,\n * )\n */\n// eslint-disable-next-line max-params, max-lines-per-function -- this function needs to display and do with more information.\nexport async function waitForFinalTransactionOutcome<\n  T extends BaseTransaction = SubmittableTransaction,\n>(\n  client: Client,\n  txHash: string,\n  lastLedger: number,\n  submissionResult: string,\n): Promise<TxResponse<T>> {\n  await sleep(LEDGER_CLOSE_TIME)\n\n  const latestLedger = await client.getLedgerIndex()\n\n  if (lastLedger < latestLedger) {\n    throw new XrplError(\n      `The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).\\n` +\n        `Preliminary result: ${submissionResult}`,\n    )\n  }\n\n  const txResponse = await client\n    .request<TxRequest, TxResponse<T>>({\n      command: 'tx',\n      transaction: txHash,\n    })\n    .catch(async (error) => {\n      // error is of an unknown type and hence we assert type to extract the value we need.\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions,@typescript-eslint/no-unsafe-member-access -- ^\n      const message = error?.data?.error as string\n      if (message === 'txnNotFound') {\n        return waitForFinalTransactionOutcome<T>(\n          client,\n          txHash,\n          lastLedger,\n          submissionResult,\n        )\n      }\n      throw new Error(\n        `${message} \\n Preliminary result: ${submissionResult}.\\nFull error details: ${String(\n          error,\n        )}`,\n      )\n    })\n\n  if (txResponse.result.validated) {\n    return txResponse\n  }\n\n  return waitForFinalTransactionOutcome<T>(\n    client,\n    txHash,\n    lastLedger,\n    submissionResult,\n  )\n}\n\n// checks if the transaction has been signed\nfunction isSigned(transaction: SubmittableTransaction | string): boolean {\n  const tx = typeof transaction === 'string' ? decode(transaction) : transaction\n  if (typeof tx === 'string') {\n    return false\n  }\n  if (tx.Signers != null) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- we know that tx.Signers is an array of Signers\n    const signers = tx.Signers as Signer[]\n    for (const signer of signers) {\n      // eslint-disable-next-line max-depth -- necessary for checking if signer is signed\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- necessary check\n        signer.Signer.SigningPubKey == null ||\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- necessary check\n        signer.Signer.TxnSignature == null\n      ) {\n        return false\n      }\n    }\n    return true\n  }\n  return tx.SigningPubKey != null && tx.TxnSignature != null\n}\n\n/**\n * Updates a transaction with `autofill` then signs it if it is unsigned.\n *\n * @param client - The client from which to retrieve the signed transaction.\n * @param transaction - The transaction to retrieve. It can be either a Transaction object or\n * a string (encode from ripple-binary-codec) representation of the transaction.\n * @param [options={}] - Optional. Additional options for retrieving the signed transaction.\n * @param [options.autofill=true] - Optional. Determines whether the transaction should be autofilled (true)\n * or not (false). Default is true.\n * @param [options.wallet] - Optional. A wallet to sign the transaction. It must be provided when submitting\n * an unsigned transaction. Default is undefined.\n * @returns A promise that resolves with the signed transaction.\n *\n * @throws {ValidationError} If the transaction is not signed and no wallet is provided.\n *\n * @example\n * import { Client } from \"xrpl\"\n * import { encode } from \"ripple-binary-codec\"\n *\n * const client = new Client(\"wss://s.altnet.rippletest.net:51233\");\n * await client.connect():\n * const transaction = createTransaction(); // createTransaction is your function to create a transaction\n * const options = {\n *   autofill: true,\n *   wallet: myWallet,\n * };\n *\n * // Example 1: Retrieving a signed Transaction object\n * const signedTx1 = await getSignedTx(client, transaction, options);\n *\n * // Example 2: Retrieving a string representation of the signed transaction\n * const signedTxString = await getSignedTx(client, encode(transaction), options);\n */\nexport async function getSignedTx(\n  client: Client,\n  transaction: SubmittableTransaction | string,\n  {\n    autofill = true,\n    wallet,\n  }: {\n    // If true, autofill a transaction.\n    autofill?: boolean\n    // A wallet to sign a transaction. It must be provided when submitting an unsigned transaction.\n    wallet?: Wallet\n  } = {},\n): Promise<SubmittableTransaction | string> {\n  if (isSigned(transaction)) {\n    return transaction\n  }\n\n  if (!wallet) {\n    throw new ValidationError(\n      'Wallet must be provided when submitting an unsigned transaction',\n    )\n  }\n\n  let tx =\n    typeof transaction === 'string'\n      ? // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- converts JsonObject to correct Transaction type\n        (decode(transaction) as unknown as SubmittableTransaction)\n      : transaction\n\n  if (autofill) {\n    tx = await client.autofill(tx)\n  }\n\n  return wallet.sign(tx).tx_blob\n}\n\n// checks if there is a LastLedgerSequence as a part of the transaction\n/**\n * Retrieves the last ledger sequence from a transaction.\n *\n * @param transaction - The transaction to retrieve the last ledger sequence from. It can be either a Transaction object or\n * a string (encode from ripple-binary-codec) representation of the transaction.\n * @returns The last ledger sequence of the transaction, or null if not available.\n *\n * @example\n * const transaction = createTransaction(); // your function to create a transaction\n *\n * // Example 1: Retrieving the last ledger sequence from a Transaction object\n * const lastLedgerSequence1 = getLastLedgerSequence(transaction);\n * console.log(lastLedgerSequence1); // Output: 12345\n *\n * // Example 2: Retrieving the last ledger sequence from a string representation of the transaction\n * const transactionString = encode(transaction);\n * const lastLedgerSequence2 = getLastLedgerSequence(transactionString);\n * console.log(lastLedgerSequence2); // Output: 67890\n */\nexport function getLastLedgerSequence(\n  transaction: Transaction | string,\n): number | null {\n  const tx = typeof transaction === 'string' ? decode(transaction) : transaction\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- converts LastLedgSeq to number if present.\n  return tx.LastLedgerSequence as number | null\n}\n\n// checks if the transaction is an AccountDelete transaction\nfunction isAccountDelete(transaction: Transaction | string): boolean {\n  const tx = typeof transaction === 'string' ? decode(transaction) : transaction\n  return tx.TransactionType === 'AccountDelete'\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}