{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst defaultFaucets_1 = require(\"./defaultFaucets\");\nconst _1 = require(\".\");\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\nfunction generateWalletToFund(wallet) {\n  if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {\n    return wallet;\n  }\n  return _1.Wallet.generate();\n}\nexports.generateWalletToFund = generateWalletToFund;\nfunction getStartingBalance(client, classicAddress) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let startingBalance = 0;\n    try {\n      startingBalance = Number(yield client.getXrpBalance(classicAddress));\n    } catch (_a) {}\n    return startingBalance;\n  });\n}\nexports.getStartingBalance = getStartingBalance;\nfunction requestFunding(options, client, startingBalance, walletToFund, postBody) {\n  var _a, _b, _c;\n  return __awaiter(this, void 0, void 0, function* () {\n    const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);\n    if (!hostname) {\n      throw new errors_1.XRPLFaucetError('No faucet hostname could be derived');\n    }\n    const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);\n    const response = yield (0, cross_fetch_1.default)(`https://${hostname}${pathname}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(postBody)\n    });\n    const body = yield response.json();\n    if (response.ok && ((_c = response.headers.get('Content-Type')) === null || _c === void 0 ? void 0 : _c.startsWith('application/json'))) {\n      const classicAddress = body.account.classicAddress;\n      return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);\n    }\n    return processError(response, body);\n  });\n}\nexports.requestFunding = requestFunding;\nfunction processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!classicAddress) {\n      return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));\n    }\n    try {\n      const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);\n      if (updatedBalance > startingBalance) {\n        return {\n          wallet: walletToFund,\n          balance: updatedBalance\n        };\n      }\n      throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new errors_1.XRPLFaucetError(err.message);\n      }\n      throw err;\n    }\n  });\n}\nfunction processError(response, body) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify({\n      body: body || {},\n      contentType: response.headers.get('Content-Type'),\n      statusCode: response.status\n    })}`));\n  });\n}\nfunction getUpdatedBalance(client, address, originalBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let attempts = MAX_ATTEMPTS;\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        if (attempts < 0) {\n          clearInterval(interval);\n          resolve(originalBalance);\n        } else {\n          attempts -= 1;\n        }\n        try {\n          let newBalance;\n          try {\n            newBalance = Number(yield client.getXrpBalance(address));\n          } catch (_a) {}\n          if (newBalance > originalBalance) {\n            clearInterval(interval);\n            resolve(newBalance);\n          }\n        } catch (err) {\n          clearInterval(interval);\n          if (err instanceof Error) {\n            reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));\n          }\n          reject(err);\n        }\n      }), INTERVAL_SECONDS * 1000);\n    });\n  });\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","requestFunding","getStartingBalance","generateWalletToFund","cross_fetch_1","require","ripple_address_codec_1","errors_1","defaultFaucets_1","_1","INTERVAL_SECONDS","MAX_ATTEMPTS","wallet","isValidClassicAddress","classicAddress","Wallet","generate","client","startingBalance","Number","getXrpBalance","_a","options","walletToFund","postBody","_b","_c","hostname","faucetHost","getFaucetHost","XRPLFaucetError","pathname","faucetPath","getDefaultFaucetPath","response","default","method","headers","body","JSON","stringify","json","ok","get","startsWith","account","processSuccessfulResponse","processError","updatedBalance","getUpdatedBalance","balance","err","Error","message","contentType","statusCode","status","address","originalBalance","attempts","interval","setInterval","clearInterval","newBalance"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/Wallet/fundWallet.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst defaultFaucets_1 = require(\"./defaultFaucets\");\nconst _1 = require(\".\");\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\nfunction generateWalletToFund(wallet) {\n    if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {\n        return wallet;\n    }\n    return _1.Wallet.generate();\n}\nexports.generateWalletToFund = generateWalletToFund;\nfunction getStartingBalance(client, classicAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let startingBalance = 0;\n        try {\n            startingBalance = Number(yield client.getXrpBalance(classicAddress));\n        }\n        catch (_a) {\n        }\n        return startingBalance;\n    });\n}\nexports.getStartingBalance = getStartingBalance;\nfunction requestFunding(options, client, startingBalance, walletToFund, postBody) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n        const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);\n        if (!hostname) {\n            throw new errors_1.XRPLFaucetError('No faucet hostname could be derived');\n        }\n        const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);\n        const response = yield (0, cross_fetch_1.default)(`https://${hostname}${pathname}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(postBody),\n        });\n        const body = yield response.json();\n        if (response.ok &&\n            ((_c = response.headers.get('Content-Type')) === null || _c === void 0 ? void 0 : _c.startsWith('application/json'))) {\n            const classicAddress = body.account.classicAddress;\n            return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);\n        }\n        return processError(response, body);\n    });\n}\nexports.requestFunding = requestFunding;\nfunction processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!classicAddress) {\n            return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));\n        }\n        try {\n            const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);\n            if (updatedBalance > startingBalance) {\n                return {\n                    wallet: walletToFund,\n                    balance: updatedBalance,\n                };\n            }\n            throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new errors_1.XRPLFaucetError(err.message);\n            }\n            throw err;\n        }\n    });\n}\nfunction processError(response, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify({\n            body: body || {},\n            contentType: response.headers.get('Content-Type'),\n            statusCode: response.status,\n        })}`));\n    });\n}\nfunction getUpdatedBalance(client, address, originalBalance) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            let attempts = MAX_ATTEMPTS;\n            const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n                if (attempts < 0) {\n                    clearInterval(interval);\n                    resolve(originalBalance);\n                }\n                else {\n                    attempts -= 1;\n                }\n                try {\n                    let newBalance;\n                    try {\n                        newBalance = Number(yield client.getXrpBalance(address));\n                    }\n                    catch (_a) {\n                    }\n                    if (newBalance > originalBalance) {\n                        clearInterval(interval);\n                        resolve(newBalance);\n                    }\n                }\n                catch (err) {\n                    clearInterval(interval);\n                    if (err instanceof Error) {\n                        reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));\n                    }\n                    reject(err);\n                }\n            }), INTERVAL_SECONDS * 1000);\n        });\n    });\n}\n//# sourceMappingURL=fundWallet.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}