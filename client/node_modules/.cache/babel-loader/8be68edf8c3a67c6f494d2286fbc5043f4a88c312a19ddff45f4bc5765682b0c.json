{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Wallet = void 0;\nconst bip32_1 = require(\"@scure/bip32\");\nconst bip39_1 = require(\"@scure/bip39\");\nconst english_1 = require(\"@scure/bip39/wordlists/english\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst ECDSA_1 = __importDefault(require(\"../ECDSA\"));\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nconst utils_2 = require(\"../sugar/utils\");\nconst collections_1 = require(\"../utils/collections\");\nconst hashLedger_1 = require(\"../utils/hashes/hashLedger\");\nconst rfc1751_1 = require(\"./rfc1751\");\nconst signer_1 = require(\"./signer\");\nconst DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;\nconst DEFAULT_DERIVATION_PATH = \"m/44'/144'/0'/0/0\";\nfunction validateKey(node) {\n  if (!(node.privateKey instanceof Uint8Array)) {\n    throw new errors_1.ValidationError('Unable to derive privateKey from mnemonic input');\n  }\n  if (!(node.publicKey instanceof Uint8Array)) {\n    throw new errors_1.ValidationError('Unable to derive publicKey from mnemonic input');\n  }\n}\nclass Wallet {\n  constructor(publicKey, privateKey, opts = {}) {\n    this.publicKey = publicKey;\n    this.privateKey = privateKey;\n    this.classicAddress = opts.masterAddress ? (0, utils_2.ensureClassicAddress)(opts.masterAddress) : (0, ripple_keypairs_1.deriveAddress)(publicKey);\n    this.seed = opts.seed;\n  }\n  get address() {\n    return this.classicAddress;\n  }\n  static generate(algorithm = DEFAULT_ALGORITHM) {\n    if (!Object.values(ECDSA_1.default).includes(algorithm)) {\n      throw new errors_1.ValidationError('Invalid cryptographic signing algorithm');\n    }\n    const seed = (0, ripple_keypairs_1.generateSeed)({\n      algorithm\n    });\n    return Wallet.fromSeed(seed, {\n      algorithm\n    });\n  }\n  static fromSeed(seed, opts = {}) {\n    return Wallet.deriveWallet(seed, {\n      algorithm: opts.algorithm,\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromEntropy(entropy, opts = {}) {\n    var _a;\n    const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;\n    const options = {\n      entropy: Uint8Array.from(entropy),\n      algorithm\n    };\n    const seed = (0, ripple_keypairs_1.generateSeed)(options);\n    return Wallet.deriveWallet(seed, {\n      algorithm,\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromMnemonic(mnemonic, opts = {}) {\n    var _a;\n    if (opts.mnemonicEncoding === 'rfc1751') {\n      return Wallet.fromRFC1751Mnemonic(mnemonic, {\n        masterAddress: opts.masterAddress,\n        algorithm: opts.algorithm\n      });\n    }\n    if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {\n      throw new errors_1.ValidationError('Unable to parse the given mnemonic using bip39 encoding');\n    }\n    const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);\n    const masterNode = bip32_1.HDKey.fromMasterSeed(seed);\n    const node = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);\n    validateKey(node);\n    const publicKey = (0, utils_1.bytesToHex)(node.publicKey);\n    const privateKey = (0, utils_1.bytesToHex)(node.privateKey);\n    return new Wallet(publicKey, `00${privateKey}`, {\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromRFC1751Mnemonic(mnemonic, opts) {\n    const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);\n    let encodeAlgorithm;\n    if (opts.algorithm === ECDSA_1.default.ed25519) {\n      encodeAlgorithm = 'ed25519';\n    } else {\n      encodeAlgorithm = 'secp256k1';\n    }\n    const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(seed, encodeAlgorithm);\n    return Wallet.fromSeed(encodedSeed, {\n      masterAddress: opts.masterAddress,\n      algorithm: opts.algorithm\n    });\n  }\n  static deriveWallet(seed, opts = {}) {\n    var _a;\n    const {\n      publicKey,\n      privateKey\n    } = (0, ripple_keypairs_1.deriveKeypair)(seed, {\n      algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM\n    });\n    return new Wallet(publicKey, privateKey, {\n      seed,\n      masterAddress: opts.masterAddress\n    });\n  }\n  sign(transaction, multisign) {\n    let multisignAddress = false;\n    if (typeof multisign === 'string' && multisign.startsWith('X')) {\n      multisignAddress = multisign;\n    } else if (multisign) {\n      multisignAddress = this.classicAddress;\n    }\n    const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), value => value == null);\n    if (tx.TxnSignature || tx.Signers) {\n      throw new errors_1.ValidationError('txJSON must not contain \"TxnSignature\" or \"Signers\" properties');\n    }\n    removeTrailingZeros(tx);\n    (0, transactions_1.validate)(tx);\n    const txToSignAndEncode = Object.assign({}, tx);\n    txToSignAndEncode.SigningPubKey = multisignAddress ? '' : this.publicKey;\n    if (multisignAddress) {\n      const signer = {\n        Account: multisignAddress,\n        SigningPubKey: this.publicKey,\n        TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress)\n      };\n      txToSignAndEncode.Signers = [{\n        Signer: signer\n      }];\n    } else {\n      txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);\n    }\n    const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);\n    return {\n      tx_blob: serialized,\n      hash: (0, hashLedger_1.hashSignedTx)(serialized)\n    };\n  }\n  verifyTransaction(signedTransaction) {\n    return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);\n  }\n  getXAddress(tag = false, isTestnet = false) {\n    return (0, ripple_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);\n  }\n}\nexports.Wallet = Wallet;\nWallet.fromSecret = Wallet.fromSeed;\nfunction computeSignature(tx, privateKey, signAs) {\n  if (signAs) {\n    const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(signAs) ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress : signAs;\n    return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);\n  }\n  return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigning)(tx), privateKey);\n}\nfunction removeTrailingZeros(tx) {\n  if (tx.TransactionType === 'Payment' && typeof tx.Amount !== 'string' && tx.Amount.value.includes('.') && tx.Amount.value.endsWith('0')) {\n    tx.Amount = Object.assign({}, tx.Amount);\n    tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();\n  }\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Wallet","bip32_1","require","bip39_1","english_1","utils_1","bignumber_js_1","ripple_address_codec_1","ripple_binary_codec_1","ripple_keypairs_1","ECDSA_1","errors_1","transactions_1","utils_2","collections_1","hashLedger_1","rfc1751_1","signer_1","DEFAULT_ALGORITHM","default","ed25519","DEFAULT_DERIVATION_PATH","validateKey","node","privateKey","Uint8Array","ValidationError","publicKey","constructor","opts","classicAddress","masterAddress","ensureClassicAddress","deriveAddress","seed","address","generate","algorithm","values","includes","generateSeed","fromSeed","deriveWallet","fromEntropy","entropy","_a","options","from","fromMnemonic","mnemonic","mnemonicEncoding","fromRFC1751Mnemonic","validateMnemonic","wordlist","mnemonicToSeedSync","masterNode","HDKey","fromMasterSeed","derive","derivationPath","bytesToHex","rfc1751MnemonicToKey","encodeAlgorithm","encodedSeed","encodeSeed","deriveKeypair","sign","transaction","multisign","multisignAddress","startsWith","tx","omitBy","assign","TxnSignature","Signers","removeTrailingZeros","validate","txToSignAndEncode","SigningPubKey","signer","Account","computeSignature","Signer","serialized","encode","tx_blob","hash","hashSignedTx","verifyTransaction","signedTransaction","verifySignature","getXAddress","tag","isTestnet","classicAddressToXAddress","fromSecret","signAs","isValidXAddress","xAddressToClassicAddress","encodeForMultisigning","encodeForSigning","TransactionType","Amount","endsWith","toString"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/Wallet/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Wallet = void 0;\nconst bip32_1 = require(\"@scure/bip32\");\nconst bip39_1 = require(\"@scure/bip39\");\nconst english_1 = require(\"@scure/bip39/wordlists/english\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst ECDSA_1 = __importDefault(require(\"../ECDSA\"));\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nconst utils_2 = require(\"../sugar/utils\");\nconst collections_1 = require(\"../utils/collections\");\nconst hashLedger_1 = require(\"../utils/hashes/hashLedger\");\nconst rfc1751_1 = require(\"./rfc1751\");\nconst signer_1 = require(\"./signer\");\nconst DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;\nconst DEFAULT_DERIVATION_PATH = \"m/44'/144'/0'/0/0\";\nfunction validateKey(node) {\n    if (!(node.privateKey instanceof Uint8Array)) {\n        throw new errors_1.ValidationError('Unable to derive privateKey from mnemonic input');\n    }\n    if (!(node.publicKey instanceof Uint8Array)) {\n        throw new errors_1.ValidationError('Unable to derive publicKey from mnemonic input');\n    }\n}\nclass Wallet {\n    constructor(publicKey, privateKey, opts = {}) {\n        this.publicKey = publicKey;\n        this.privateKey = privateKey;\n        this.classicAddress = opts.masterAddress\n            ? (0, utils_2.ensureClassicAddress)(opts.masterAddress)\n            : (0, ripple_keypairs_1.deriveAddress)(publicKey);\n        this.seed = opts.seed;\n    }\n    get address() {\n        return this.classicAddress;\n    }\n    static generate(algorithm = DEFAULT_ALGORITHM) {\n        if (!Object.values(ECDSA_1.default).includes(algorithm)) {\n            throw new errors_1.ValidationError('Invalid cryptographic signing algorithm');\n        }\n        const seed = (0, ripple_keypairs_1.generateSeed)({ algorithm });\n        return Wallet.fromSeed(seed, { algorithm });\n    }\n    static fromSeed(seed, opts = {}) {\n        return Wallet.deriveWallet(seed, {\n            algorithm: opts.algorithm,\n            masterAddress: opts.masterAddress,\n        });\n    }\n    static fromEntropy(entropy, opts = {}) {\n        var _a;\n        const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;\n        const options = {\n            entropy: Uint8Array.from(entropy),\n            algorithm,\n        };\n        const seed = (0, ripple_keypairs_1.generateSeed)(options);\n        return Wallet.deriveWallet(seed, {\n            algorithm,\n            masterAddress: opts.masterAddress,\n        });\n    }\n    static fromMnemonic(mnemonic, opts = {}) {\n        var _a;\n        if (opts.mnemonicEncoding === 'rfc1751') {\n            return Wallet.fromRFC1751Mnemonic(mnemonic, {\n                masterAddress: opts.masterAddress,\n                algorithm: opts.algorithm,\n            });\n        }\n        if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {\n            throw new errors_1.ValidationError('Unable to parse the given mnemonic using bip39 encoding');\n        }\n        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);\n        const masterNode = bip32_1.HDKey.fromMasterSeed(seed);\n        const node = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);\n        validateKey(node);\n        const publicKey = (0, utils_1.bytesToHex)(node.publicKey);\n        const privateKey = (0, utils_1.bytesToHex)(node.privateKey);\n        return new Wallet(publicKey, `00${privateKey}`, {\n            masterAddress: opts.masterAddress,\n        });\n    }\n    static fromRFC1751Mnemonic(mnemonic, opts) {\n        const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);\n        let encodeAlgorithm;\n        if (opts.algorithm === ECDSA_1.default.ed25519) {\n            encodeAlgorithm = 'ed25519';\n        }\n        else {\n            encodeAlgorithm = 'secp256k1';\n        }\n        const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(seed, encodeAlgorithm);\n        return Wallet.fromSeed(encodedSeed, {\n            masterAddress: opts.masterAddress,\n            algorithm: opts.algorithm,\n        });\n    }\n    static deriveWallet(seed, opts = {}) {\n        var _a;\n        const { publicKey, privateKey } = (0, ripple_keypairs_1.deriveKeypair)(seed, {\n            algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM,\n        });\n        return new Wallet(publicKey, privateKey, {\n            seed,\n            masterAddress: opts.masterAddress,\n        });\n    }\n    sign(transaction, multisign) {\n        let multisignAddress = false;\n        if (typeof multisign === 'string' && multisign.startsWith('X')) {\n            multisignAddress = multisign;\n        }\n        else if (multisign) {\n            multisignAddress = this.classicAddress;\n        }\n        const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), (value) => value == null);\n        if (tx.TxnSignature || tx.Signers) {\n            throw new errors_1.ValidationError('txJSON must not contain \"TxnSignature\" or \"Signers\" properties');\n        }\n        removeTrailingZeros(tx);\n        (0, transactions_1.validate)(tx);\n        const txToSignAndEncode = Object.assign({}, tx);\n        txToSignAndEncode.SigningPubKey = multisignAddress ? '' : this.publicKey;\n        if (multisignAddress) {\n            const signer = {\n                Account: multisignAddress,\n                SigningPubKey: this.publicKey,\n                TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress),\n            };\n            txToSignAndEncode.Signers = [{ Signer: signer }];\n        }\n        else {\n            txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);\n        }\n        const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);\n        return {\n            tx_blob: serialized,\n            hash: (0, hashLedger_1.hashSignedTx)(serialized),\n        };\n    }\n    verifyTransaction(signedTransaction) {\n        return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);\n    }\n    getXAddress(tag = false, isTestnet = false) {\n        return (0, ripple_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);\n    }\n}\nexports.Wallet = Wallet;\nWallet.fromSecret = Wallet.fromSeed;\nfunction computeSignature(tx, privateKey, signAs) {\n    if (signAs) {\n        const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(signAs)\n            ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress\n            : signAs;\n        return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);\n    }\n    return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigning)(tx), privateKey);\n}\nfunction removeTrailingZeros(tx) {\n    if (tx.TransactionType === 'Payment' &&\n        typeof tx.Amount !== 'string' &&\n        tx.Amount.value.includes('.') &&\n        tx.Amount.value.endsWith('0')) {\n        tx.Amount = Object.assign({}, tx.Amount);\n        tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();\n    }\n}\n//# sourceMappingURL=index.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}