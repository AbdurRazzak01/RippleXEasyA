{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable func-style */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst types_1 = require(\"./types\");\nconst binary_parser_1 = require(\"./serdes/binary-parser\");\nObject.defineProperty(exports, \"BinaryParser\", {\n  enumerable: true,\n  get: function () {\n    return binary_parser_1.BinaryParser;\n  }\n});\nconst hash_prefixes_1 = require(\"./hash-prefixes\");\nconst binary_serializer_1 = require(\"./serdes/binary-serializer\");\nObject.defineProperty(exports, \"BinarySerializer\", {\n  enumerable: true,\n  get: function () {\n    return binary_serializer_1.BinarySerializer;\n  }\n});\nObject.defineProperty(exports, \"BytesList\", {\n  enumerable: true,\n  get: function () {\n    return binary_serializer_1.BytesList;\n  }\n});\nconst hashes_1 = require(\"./hashes\");\nObject.defineProperty(exports, \"sha512Half\", {\n  enumerable: true,\n  get: function () {\n    return hashes_1.sha512Half;\n  }\n});\nObject.defineProperty(exports, \"transactionID\", {\n  enumerable: true,\n  get: function () {\n    return hashes_1.transactionID;\n  }\n});\nconst enums_1 = require(\"./enums\");\n/**\n * Construct a BinaryParser\n *\n * @param bytes hex-string or Uint8Array to construct BinaryParser from\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns BinaryParser\n */\nconst makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes, definitions);\nexports.makeParser = makeParser;\n/**\n * Parse BinaryParser into JSON\n *\n * @param parser BinaryParser object\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON for the bytes in the BinaryParser\n */\nconst readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);\nexports.readJSON = readJSON;\n/**\n * Parse a hex-string into its JSON interpretation\n *\n * @param bytes hex-string to parse into JSON\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON\n */\nconst binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);\nexports.binaryToJSON = binaryToJSON;\n/**\n * Function to serialize JSON object representing a transaction\n *\n * @param object JSON object to serialize\n * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions\n * @returns A Uint8Array containing the serialized object\n */\nfunction serializeObject(object, opts = {}) {\n  const {\n    prefix,\n    suffix,\n    signingFieldsOnly = false,\n    definitions\n  } = opts;\n  const bytesList = new binary_serializer_1.BytesList();\n  if (prefix) {\n    bytesList.put(prefix);\n  }\n  const filter = signingFieldsOnly ? f => f.isSigningField : undefined;\n  types_1.coreTypes.STObject.from(object, filter, definitions).toBytesSink(bytesList);\n  if (suffix) {\n    bytesList.put(suffix);\n  }\n  return bytesList.toBytes();\n}\nexports.serializeObject = serializeObject;\n/**\n * Serialize an object for signing\n *\n * @param transaction Transaction to serialize\n * @param prefix Prefix bytes to put before the serialized object\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns A Uint8Array with the serialized object\n */\nfunction signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {\n  return serializeObject(transaction, {\n    prefix,\n    signingFieldsOnly: true,\n    definitions: opts.definitions\n  });\n}\nexports.signingData = signingData;\n/**\n * Serialize a signingClaim\n *\n * @param claim A claim object to serialize\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the serialized object with appropriate prefix\n */\nfunction signingClaimData(claim) {\n  const num = BigInt(String(claim.amount));\n  const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;\n  const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();\n  const amount = types_1.coreTypes.UInt64.from(num).toBytes();\n  const bytesList = new binary_serializer_1.BytesList();\n  bytesList.put(prefix);\n  bytesList.put(channel);\n  bytesList.put(amount);\n  return bytesList.toBytes();\n}\nexports.signingClaimData = signingClaimData;\n/**\n * Serialize a transaction object for multiSigning\n *\n * @param transaction transaction to serialize\n * @param signingAccount Account to sign the transaction with\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns serialized transaction with appropriate prefix and suffix\n */\nfunction multiSigningData(transaction, signingAccount, opts = {\n  definitions: enums_1.DEFAULT_DEFINITIONS\n}) {\n  const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;\n  const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();\n  return serializeObject(transaction, {\n    prefix,\n    suffix,\n    signingFieldsOnly: true,\n    definitions: opts.definitions\n  });\n}\nexports.multiSigningData = multiSigningData;","map":{"version":3,"names":["utils_1","require","types_1","binary_parser_1","Object","defineProperty","exports","enumerable","get","BinaryParser","hash_prefixes_1","binary_serializer_1","BinarySerializer","BytesList","hashes_1","sha512Half","transactionID","enums_1","makeParser","bytes","definitions","Uint8Array","bytesToHex","readJSON","parser","DEFAULT_DEFINITIONS","readType","coreTypes","STObject","toJSON","binaryToJSON","serializeObject","object","opts","prefix","suffix","signingFieldsOnly","bytesList","put","filter","f","isSigningField","undefined","from","toBytesSink","toBytes","signingData","transaction","HashPrefix","transactionSig","signingClaimData","claim","num","BigInt","String","amount","paymentChannelClaim","channel","Hash256","UInt64","multiSigningData","signingAccount","transactionMultiSig","AccountID"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/binary.ts"],"sourcesContent":["/* eslint-disable func-style */\n\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\nimport { coreTypes } from './types'\nimport { BinaryParser } from './serdes/binary-parser'\nimport { AccountID } from './types/account-id'\nimport { HashPrefix } from './hash-prefixes'\nimport { BinarySerializer, BytesList } from './serdes/binary-serializer'\nimport { sha512Half, transactionID } from './hashes'\nimport {\n  type XrplDefinitionsBase,\n  DEFAULT_DEFINITIONS,\n  type FieldInstance,\n} from './enums'\nimport { STObject } from './types/st-object'\nimport { JsonObject } from './types/serialized-type'\n\n/**\n * Construct a BinaryParser\n *\n * @param bytes hex-string or Uint8Array to construct BinaryParser from\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns BinaryParser\n */\nconst makeParser = (\n  bytes: string | Uint8Array,\n  definitions?: XrplDefinitionsBase,\n): BinaryParser =>\n  new BinaryParser(\n    bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes,\n    definitions,\n  )\n\n/**\n * Parse BinaryParser into JSON\n *\n * @param parser BinaryParser object\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON for the bytes in the BinaryParser\n */\nconst readJSON = (\n  parser: BinaryParser,\n  definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n): JsonObject =>\n  (parser.readType(coreTypes.STObject) as STObject).toJSON(definitions)\n\n/**\n * Parse a hex-string into its JSON interpretation\n *\n * @param bytes hex-string to parse into JSON\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON\n */\nconst binaryToJSON = (\n  bytes: string,\n  definitions?: XrplDefinitionsBase,\n): JsonObject => readJSON(makeParser(bytes, definitions), definitions)\n\n/**\n * Interface for passing parameters to SerializeObject\n *\n * @field set signingFieldOnly to true if you want to serialize only signing fields\n */\ninterface OptionObject {\n  prefix?: Uint8Array\n  suffix?: Uint8Array\n  signingFieldsOnly?: boolean\n  definitions?: XrplDefinitionsBase\n}\n\n/**\n * Function to serialize JSON object representing a transaction\n *\n * @param object JSON object to serialize\n * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions\n * @returns A Uint8Array containing the serialized object\n */\nfunction serializeObject(\n  object: JsonObject,\n  opts: OptionObject = {},\n): Uint8Array {\n  const { prefix, suffix, signingFieldsOnly = false, definitions } = opts\n  const bytesList = new BytesList()\n\n  if (prefix) {\n    bytesList.put(prefix)\n  }\n\n  const filter = signingFieldsOnly\n    ? (f: FieldInstance): boolean => f.isSigningField\n    : undefined\n  ;(coreTypes.STObject as typeof STObject)\n    .from(object, filter, definitions)\n    .toBytesSink(bytesList)\n\n  if (suffix) {\n    bytesList.put(suffix)\n  }\n\n  return bytesList.toBytes()\n}\n\n/**\n * Serialize an object for signing\n *\n * @param transaction Transaction to serialize\n * @param prefix Prefix bytes to put before the serialized object\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns A Uint8Array with the serialized object\n */\nfunction signingData(\n  transaction: JsonObject,\n  prefix: Uint8Array = HashPrefix.transactionSig,\n  opts: { definitions?: XrplDefinitionsBase } = {},\n): Uint8Array {\n  return serializeObject(transaction, {\n    prefix,\n    signingFieldsOnly: true,\n    definitions: opts.definitions,\n  })\n}\n\n/**\n * Interface describing fields required for a Claim\n */\ninterface ClaimObject extends JsonObject {\n  channel: string\n  amount: string | number\n}\n\n/**\n * Serialize a signingClaim\n *\n * @param claim A claim object to serialize\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the serialized object with appropriate prefix\n */\nfunction signingClaimData(claim: ClaimObject): Uint8Array {\n  const num = BigInt(String(claim.amount))\n  const prefix = HashPrefix.paymentChannelClaim\n  const channel = coreTypes.Hash256.from(claim.channel).toBytes()\n  const amount = coreTypes.UInt64.from(num).toBytes()\n\n  const bytesList = new BytesList()\n\n  bytesList.put(prefix)\n  bytesList.put(channel)\n  bytesList.put(amount)\n  return bytesList.toBytes()\n}\n\n/**\n * Serialize a transaction object for multiSigning\n *\n * @param transaction transaction to serialize\n * @param signingAccount Account to sign the transaction with\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns serialized transaction with appropriate prefix and suffix\n */\nfunction multiSigningData(\n  transaction: JsonObject,\n  signingAccount: string | AccountID,\n  opts: { definitions: XrplDefinitionsBase } = {\n    definitions: DEFAULT_DEFINITIONS,\n  },\n): Uint8Array {\n  const prefix = HashPrefix.transactionMultiSig\n  const suffix = coreTypes.AccountID.from(signingAccount).toBytes()\n  return serializeObject(transaction, {\n    prefix,\n    suffix,\n    signingFieldsOnly: true,\n    definitions: opts.definitions,\n  })\n}\n\nexport {\n  BinaryParser,\n  BinarySerializer,\n  BytesList,\n  ClaimObject,\n  makeParser,\n  serializeObject,\n  readJSON,\n  multiSigningData,\n  signingData,\n  signingClaimData,\n  binaryToJSON,\n  sha512Half,\n  transactionID,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}