{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst metadata_1 = require(\"../models/transactions/metadata\");\nfunction ensureDecodedMeta(meta) {\n  if (typeof meta === 'string') {\n    return (0, ripple_binary_codec_1.decode)(meta);\n  }\n  return meta;\n}\nfunction getNFTokenID(meta) {\n  if (typeof meta !== 'string' && (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) === undefined) {\n    throw new TypeError(`Unable to parse the parameter given to getNFTokenID.\n      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta)} instead.`);\n  }\n  const decodedMeta = ensureDecodedMeta(meta);\n  const affectedNodes = decodedMeta.AffectedNodes.filter(node => {\n    var _a;\n    if ((0, metadata_1.isCreatedNode)(node)) {\n      return node.CreatedNode.LedgerEntryType === 'NFTokenPage';\n    }\n    if ((0, metadata_1.isModifiedNode)(node)) {\n      return node.ModifiedNode.LedgerEntryType === 'NFTokenPage' && Boolean((_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens);\n    }\n    return false;\n  });\n  const previousTokenIDSet = new Set(affectedNodes.flatMap(node => {\n    var _a;\n    const nftokens = (0, metadata_1.isModifiedNode)(node) ? (_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens : [];\n    return nftokens.map(token => token.NFToken.NFTokenID);\n  }).filter(id => Boolean(id)));\n  const finalTokenIDs = affectedNodes.flatMap(node => {\n    var _a, _b, _c, _d, _e, _f;\n    return ((_f = (_c = (_b = (_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens) !== null && _f !== void 0 ? _f : []).map(token => token.NFToken.NFTokenID);\n  }).filter(nftokenID => Boolean(nftokenID));\n  const nftokenID = finalTokenIDs.find(id => !previousTokenIDSet.has(id));\n  return nftokenID;\n}\nexports.default = getNFTokenID;","map":{"version":3,"names":["Object","defineProperty","exports","value","ripple_binary_codec_1","require","metadata_1","ensureDecodedMeta","meta","decode","getNFTokenID","AffectedNodes","undefined","TypeError","JSON","stringify","decodedMeta","affectedNodes","filter","node","_a","isCreatedNode","CreatedNode","LedgerEntryType","isModifiedNode","ModifiedNode","Boolean","PreviousFields","NFTokens","previousTokenIDSet","Set","flatMap","nftokens","map","token","NFToken","NFTokenID","id","finalTokenIDs","_b","_c","_d","_e","_f","FinalFields","NewFields","nftokenID","find","has","default"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/utils/getNFTokenID.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst metadata_1 = require(\"../models/transactions/metadata\");\nfunction ensureDecodedMeta(meta) {\n    if (typeof meta === 'string') {\n        return (0, ripple_binary_codec_1.decode)(meta);\n    }\n    return meta;\n}\nfunction getNFTokenID(meta) {\n    if (typeof meta !== 'string' && (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) === undefined) {\n        throw new TypeError(`Unable to parse the parameter given to getNFTokenID.\n      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta)} instead.`);\n    }\n    const decodedMeta = ensureDecodedMeta(meta);\n    const affectedNodes = decodedMeta.AffectedNodes.filter((node) => {\n        var _a;\n        if ((0, metadata_1.isCreatedNode)(node)) {\n            return node.CreatedNode.LedgerEntryType === 'NFTokenPage';\n        }\n        if ((0, metadata_1.isModifiedNode)(node)) {\n            return (node.ModifiedNode.LedgerEntryType === 'NFTokenPage' &&\n                Boolean((_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens));\n        }\n        return false;\n    });\n    const previousTokenIDSet = new Set(affectedNodes\n        .flatMap((node) => {\n        var _a;\n        const nftokens = (0, metadata_1.isModifiedNode)(node)\n            ? (_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens\n            : [];\n        return nftokens.map((token) => token.NFToken.NFTokenID);\n    })\n        .filter((id) => Boolean(id)));\n    const finalTokenIDs = affectedNodes\n        .flatMap((node) => {\n        var _a, _b, _c, _d, _e, _f;\n        return ((_f = ((_c = (_b = (_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens)) !== null && _f !== void 0 ? _f : []).map((token) => token.NFToken.NFTokenID);\n    })\n        .filter((nftokenID) => Boolean(nftokenID));\n    const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id));\n    return nftokenID;\n}\nexports.default = getNFTokenID;\n//# sourceMappingURL=getNFTokenID.js.map"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC5D,MAAMC,UAAU,GAAGD,OAAO,CAAC,iCAAiC,CAAC;AAC7D,SAASE,iBAAiBA,CAACC,IAAI,EAAE;EAC7B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,OAAO,CAAC,CAAC,EAAEJ,qBAAqB,CAACK,MAAM,EAAED,IAAI,CAAC;EAClD;EACA,OAAOA,IAAI;AACf;AACA,SAASE,YAAYA,CAACF,IAAI,EAAE;EACxB,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,CAACA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACG,aAAa,MAAMC,SAAS,EAAE;IAC5G,MAAM,IAAIC,SAAS,CAAE;AAC7B,8EAA8EC,IAAI,CAACC,SAAS,CAACP,IAAI,CAAE,WAAU,CAAC;EAC1G;EACA,MAAMQ,WAAW,GAAGT,iBAAiB,CAACC,IAAI,CAAC;EAC3C,MAAMS,aAAa,GAAGD,WAAW,CAACL,aAAa,CAACO,MAAM,CAAEC,IAAI,IAAK;IAC7D,IAAIC,EAAE;IACN,IAAI,CAAC,CAAC,EAAEd,UAAU,CAACe,aAAa,EAAEF,IAAI,CAAC,EAAE;MACrC,OAAOA,IAAI,CAACG,WAAW,CAACC,eAAe,KAAK,aAAa;IAC7D;IACA,IAAI,CAAC,CAAC,EAAEjB,UAAU,CAACkB,cAAc,EAAEL,IAAI,CAAC,EAAE;MACtC,OAAQA,IAAI,CAACM,YAAY,CAACF,eAAe,KAAK,aAAa,IACvDG,OAAO,CAAC,CAACN,EAAE,GAAGD,IAAI,CAACM,YAAY,CAACE,cAAc,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACQ,QAAQ,CAAC;IACzG;IACA,OAAO,KAAK;EAChB,CAAC,CAAC;EACF,MAAMC,kBAAkB,GAAG,IAAIC,GAAG,CAACb,aAAa,CAC3Cc,OAAO,CAAEZ,IAAI,IAAK;IACnB,IAAIC,EAAE;IACN,MAAMY,QAAQ,GAAG,CAAC,CAAC,EAAE1B,UAAU,CAACkB,cAAc,EAAEL,IAAI,CAAC,GAC/C,CAACC,EAAE,GAAGD,IAAI,CAACM,YAAY,CAACE,cAAc,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACQ,QAAQ,GACxF,EAAE;IACR,OAAOI,QAAQ,CAACC,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACC,OAAO,CAACC,SAAS,CAAC;EAC3D,CAAC,CAAC,CACGlB,MAAM,CAAEmB,EAAE,IAAKX,OAAO,CAACW,EAAE,CAAC,CAAC,CAAC;EACjC,MAAMC,aAAa,GAAGrB,aAAa,CAC9Bc,OAAO,CAAEZ,IAAI,IAAK;IACnB,IAAIC,EAAE,EAAEmB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IAC1B,OAAO,CAAC,CAACA,EAAE,GAAI,CAACH,EAAE,GAAG,CAACD,EAAE,GAAG,CAACnB,EAAE,GAAGD,IAAI,CAACM,YAAY,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACwB,WAAW,MAAM,IAAI,IAAIL,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACX,QAAQ,MAAM,IAAI,IAAIY,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAACE,EAAE,GAAG,CAACD,EAAE,GAAGtB,IAAI,CAACG,WAAW,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,SAAS,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACd,QAAS,MAAM,IAAI,IAAIe,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE,EAAEV,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACC,OAAO,CAACC,SAAS,CAAC;EAChZ,CAAC,CAAC,CACGlB,MAAM,CAAE4B,SAAS,IAAKpB,OAAO,CAACoB,SAAS,CAAC,CAAC;EAC9C,MAAMA,SAAS,GAAGR,aAAa,CAACS,IAAI,CAAEV,EAAE,IAAK,CAACR,kBAAkB,CAACmB,GAAG,CAACX,EAAE,CAAC,CAAC;EACzE,OAAOS,SAAS;AACpB;AACA5C,OAAO,CAAC+C,OAAO,GAAGvC,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}