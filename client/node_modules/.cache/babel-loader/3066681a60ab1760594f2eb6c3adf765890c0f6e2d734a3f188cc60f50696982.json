{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkAccountDeleteBlockers = exports.setLatestValidatedLedgerSequence = exports.calculateFeePerTransactionType = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst getFeeXrp_1 = __importDefault(require(\"./getFeeXrp\"));\nconst LEDGER_OFFSET = 20;\nconst RESTRICTED_NETWORKS = 1024;\nconst REQUIRED_NETWORKID_VERSION = '1.11.0';\nconst HOOKS_TESTNET_ID = 21338;\nfunction isNotLaterRippledVersion(source, target) {\n  if (source === target) {\n    return true;\n  }\n  const sourceDecomp = source.split('.');\n  const targetDecomp = target.split('.');\n  const sourceMajor = parseInt(sourceDecomp[0], 10);\n  const sourceMinor = parseInt(sourceDecomp[1], 10);\n  const targetMajor = parseInt(targetDecomp[0], 10);\n  const targetMinor = parseInt(targetDecomp[1], 10);\n  if (sourceMajor !== targetMajor) {\n    return sourceMajor < targetMajor;\n  }\n  if (sourceMinor !== targetMinor) {\n    return sourceMinor < targetMinor;\n  }\n  const sourcePatch = sourceDecomp[2].split('-');\n  const targetPatch = targetDecomp[2].split('-');\n  const sourcePatchVersion = parseInt(sourcePatch[0], 10);\n  const targetPatchVersion = parseInt(targetPatch[0], 10);\n  if (sourcePatchVersion !== targetPatchVersion) {\n    return sourcePatchVersion < targetPatchVersion;\n  }\n  if (sourcePatch.length !== targetPatch.length) {\n    return sourcePatch.length > targetPatch.length;\n  }\n  if (sourcePatch.length === 2) {\n    if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {\n      return sourcePatch[1] < targetPatch[1];\n    }\n    if (sourcePatch[1].startsWith('b')) {\n      return parseInt(sourcePatch[1].slice(1), 10) < parseInt(targetPatch[1].slice(1), 10);\n    }\n    return parseInt(sourcePatch[1].slice(2), 10) < parseInt(targetPatch[1].slice(2), 10);\n  }\n  return false;\n}\nfunction txNeedsNetworkID(client) {\n  if (client.networkID !== undefined && client.networkID > RESTRICTED_NETWORKS) {\n    if (client.buildVersion && isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client.buildVersion) || client.networkID === HOOKS_TESTNET_ID) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.txNeedsNetworkID = txNeedsNetworkID;\nfunction setValidAddresses(tx) {\n  validateAccountAddress(tx, 'Account', 'SourceTag');\n  if (tx['Destination'] != null) {\n    validateAccountAddress(tx, 'Destination', 'DestinationTag');\n  }\n  convertToClassicAddress(tx, 'Authorize');\n  convertToClassicAddress(tx, 'Unauthorize');\n  convertToClassicAddress(tx, 'Owner');\n  convertToClassicAddress(tx, 'RegularKey');\n}\nexports.setValidAddresses = setValidAddresses;\nfunction validateAccountAddress(tx, accountField, tagField) {\n  const {\n    classicAccount,\n    tag\n  } = getClassicAccountAndTag(tx[accountField]);\n  tx[accountField] = classicAccount;\n  if (tag != null && tag !== false) {\n    if (tx[tagField] && tx[tagField] !== tag) {\n      throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);\n    }\n    tx[tagField] = tag;\n  }\n}\nfunction getClassicAccountAndTag(Account, expectedTag) {\n  if ((0, ripple_address_codec_1.isValidXAddress)(Account)) {\n    const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(Account);\n    if (expectedTag != null && classic.tag !== expectedTag) {\n      throw new errors_1.ValidationError('address includes a tag that does not match the tag specified in the transaction');\n    }\n    return {\n      classicAccount: classic.classicAddress,\n      tag: classic.tag\n    };\n  }\n  return {\n    classicAccount: Account,\n    tag: expectedTag\n  };\n}\nfunction convertToClassicAddress(tx, fieldName) {\n  const account = tx[fieldName];\n  if (typeof account === 'string') {\n    const {\n      classicAccount\n    } = getClassicAccountAndTag(account);\n    tx[fieldName] = classicAccount;\n  }\n}\nfunction setNextValidSequenceNumber(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const request = {\n      command: 'account_info',\n      account: tx.Account,\n      ledger_index: 'current'\n    };\n    const data = yield client.request(request);\n    tx.Sequence = data.result.account_data.Sequence;\n  });\n}\nexports.setNextValidSequenceNumber = setNextValidSequenceNumber;\nfunction fetchAccountDeleteFee(client) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const response = yield client.request({\n      command: 'server_state'\n    });\n    const fee = (_a = response.result.state.validated_ledger) === null || _a === void 0 ? void 0 : _a.reserve_inc;\n    if (fee == null) {\n      return Promise.reject(new Error('Could not fetch Owner Reserve.'));\n    }\n    return new bignumber_js_1.default(fee);\n  });\n}\nfunction calculateFeePerTransactionType(client, tx, signersCount = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const netFeeXRP = yield (0, getFeeXrp_1.default)(client);\n    const netFeeDrops = (0, utils_1.xrpToDrops)(netFeeXRP);\n    let baseFee = new bignumber_js_1.default(netFeeDrops);\n    if (tx.TransactionType === 'EscrowFinish' && tx.Fulfillment != null) {\n      const fulfillmentBytesSize = Math.ceil(tx.Fulfillment.length / 2);\n      const product = new bignumber_js_1.default(scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16));\n      baseFee = product.dp(0, bignumber_js_1.default.ROUND_CEIL);\n    }\n    if (tx.TransactionType === 'AccountDelete' || tx.TransactionType === 'AMMCreate') {\n      baseFee = yield fetchAccountDeleteFee(client);\n    }\n    if (signersCount > 0) {\n      baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, 1 + signersCount));\n    }\n    const maxFeeDrops = (0, utils_1.xrpToDrops)(client.maxFeeXRP);\n    const totalFee = tx.TransactionType === 'AccountDelete' ? baseFee : bignumber_js_1.default.min(baseFee, maxFeeDrops);\n    tx.Fee = totalFee.dp(0, bignumber_js_1.default.ROUND_CEIL).toString(10);\n  });\n}\nexports.calculateFeePerTransactionType = calculateFeePerTransactionType;\nfunction scaleValue(value, multiplier) {\n  return new bignumber_js_1.default(value).times(multiplier).toString();\n}\nfunction setLatestValidatedLedgerSequence(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ledgerSequence = yield client.getLedgerIndex();\n    tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;\n  });\n}\nexports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;\nfunction checkAccountDeleteBlockers(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const request = {\n      command: 'account_objects',\n      account: tx.Account,\n      ledger_index: 'validated',\n      deletion_blockers_only: true\n    };\n    const response = yield client.request(request);\n    return new Promise((resolve, reject) => {\n      if (response.result.account_objects.length > 0) {\n        reject(new errors_1.XrplError(`Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));\n      }\n      resolve();\n    });\n  });\n}\nexports.checkAccountDeleteBlockers = checkAccountDeleteBlockers;","map":{"version":3,"names":["bignumber_js_1","__importDefault","require","ripple_address_codec_1","errors_1","utils_1","getFeeXrp_1","LEDGER_OFFSET","RESTRICTED_NETWORKS","REQUIRED_NETWORKID_VERSION","HOOKS_TESTNET_ID","isNotLaterRippledVersion","source","target","sourceDecomp","split","targetDecomp","sourceMajor","parseInt","sourceMinor","targetMajor","targetMinor","sourcePatch","targetPatch","sourcePatchVersion","targetPatchVersion","length","startsWith","slice","txNeedsNetworkID","client","networkID","undefined","buildVersion","exports","setValidAddresses","tx","validateAccountAddress","convertToClassicAddress","accountField","tagField","classicAccount","tag","getClassicAccountAndTag","ValidationError","Account","expectedTag","isValidXAddress","classic","xAddressToClassicAddress","classicAddress","fieldName","account","setNextValidSequenceNumber","request","command","ledger_index","data","Sequence","result","account_data","fetchAccountDeleteFee","response","fee","_a","state","validated_ledger","reserve_inc","Promise","reject","Error","default","calculateFeePerTransactionType","signersCount","netFeeXRP","netFeeDrops","xrpToDrops","baseFee","TransactionType","Fulfillment","fulfillmentBytesSize","Math","ceil","product","scaleValue","dp","ROUND_CEIL","sum","maxFeeDrops","maxFeeXRP","totalFee","min","Fee","toString","value","multiplier","times","setLatestValidatedLedgerSequence","ledgerSequence","getLedgerIndex","LastLedgerSequence","checkAccountDeleteBlockers","deletion_blockers_only","resolve","account_objects","XrplError"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/sugar/autofill.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\nimport { xAddressToClassicAddress, isValidXAddress } from 'ripple-address-codec'\n\nimport type { Client } from '..'\nimport { ValidationError, XrplError } from '../errors'\nimport { AccountInfoRequest, AccountObjectsRequest } from '../models/methods'\nimport { Transaction } from '../models/transactions'\nimport { xrpToDrops } from '../utils'\n\nimport getFeeXrp from './getFeeXrp'\n\n// Expire unconfirmed transactions after 20 ledger versions, approximately 1 minute, by default\nconst LEDGER_OFFSET = 20\n// Sidechains are expected to have network IDs above this.\n// Networks with ID above this restricted number are expected specify an accurate NetworkID field\n// in every transaction to that chain to prevent replay attacks.\n// Mainnet and testnet are exceptions. More context: https://github.com/XRPLF/rippled/pull/4370\nconst RESTRICTED_NETWORKS = 1024\nconst REQUIRED_NETWORKID_VERSION = '1.11.0'\nconst HOOKS_TESTNET_ID = 21338\n\n/**\n * Determines whether the source rippled version is not later than the target rippled version.\n * Example usage: isNotLaterRippledVersion('1.10.0', '1.11.0') returns true.\n *                isNotLaterRippledVersion('1.10.0', '1.10.0-b1') returns false.\n *\n * @param source -- The source rippled version.\n * @param target -- The target rippled version.\n * @returns True if source is earlier than target, false otherwise.\n */\n// eslint-disable-next-line max-lines-per-function, max-statements -- Disable for this helper functions.\nfunction isNotLaterRippledVersion(source: string, target: string): boolean {\n  if (source === target) {\n    return true\n  }\n  const sourceDecomp = source.split('.')\n  const targetDecomp = target.split('.')\n  const sourceMajor = parseInt(sourceDecomp[0], 10)\n  const sourceMinor = parseInt(sourceDecomp[1], 10)\n  const targetMajor = parseInt(targetDecomp[0], 10)\n  const targetMinor = parseInt(targetDecomp[1], 10)\n  // Compare major version\n  if (sourceMajor !== targetMajor) {\n    return sourceMajor < targetMajor\n  }\n  // Compare minor version\n  if (sourceMinor !== targetMinor) {\n    return sourceMinor < targetMinor\n  }\n  const sourcePatch = sourceDecomp[2].split('-')\n  const targetPatch = targetDecomp[2].split('-')\n\n  const sourcePatchVersion = parseInt(sourcePatch[0], 10)\n  const targetPatchVersion = parseInt(targetPatch[0], 10)\n\n  // Compare patch version\n  if (sourcePatchVersion !== targetPatchVersion) {\n    return sourcePatchVersion < targetPatchVersion\n  }\n\n  // Compare release version\n  if (sourcePatch.length !== targetPatch.length) {\n    return sourcePatch.length > targetPatch.length\n  }\n\n  if (sourcePatch.length === 2) {\n    // Compare different release types\n    if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {\n      return sourcePatch[1] < targetPatch[1]\n    }\n    // Compare beta version\n    if (sourcePatch[1].startsWith('b')) {\n      return (\n        parseInt(sourcePatch[1].slice(1), 10) <\n        parseInt(targetPatch[1].slice(1), 10)\n      )\n    }\n    // Compare rc version\n    return (\n      parseInt(sourcePatch[1].slice(2), 10) <\n      parseInt(targetPatch[1].slice(2), 10)\n    )\n  }\n\n  return false\n}\n\n/**\n * Determine if the transaction required a networkID to be valid.\n * Transaction needs networkID if later than restricted ID and either the network is hooks testnet\n * or build version is >= 1.11.0\n *\n * @param client -- The connected client.\n * @returns True if required networkID, false otherwise.\n */\nexport function txNeedsNetworkID(client: Client): boolean {\n  if (\n    client.networkID !== undefined &&\n    client.networkID > RESTRICTED_NETWORKS\n  ) {\n    if (\n      (client.buildVersion &&\n        isNotLaterRippledVersion(\n          REQUIRED_NETWORKID_VERSION,\n          client.buildVersion,\n        )) ||\n      client.networkID === HOOKS_TESTNET_ID\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\ninterface ClassicAccountAndTag {\n  classicAccount: string\n  tag: number | false | undefined\n}\n\n/**\n * Sets valid addresses for the transaction.\n *\n * @param tx - The transaction object.\n */\nexport function setValidAddresses(tx: Transaction): void {\n  validateAccountAddress(tx, 'Account', 'SourceTag')\n  // eslint-disable-next-line @typescript-eslint/dot-notation -- Destination can exist on Transaction\n  if (tx['Destination'] != null) {\n    validateAccountAddress(tx, 'Destination', 'DestinationTag')\n  }\n\n  // DepositPreauth:\n  convertToClassicAddress(tx, 'Authorize')\n  convertToClassicAddress(tx, 'Unauthorize')\n  // EscrowCancel, EscrowFinish:\n  convertToClassicAddress(tx, 'Owner')\n  // SetRegularKey:\n  convertToClassicAddress(tx, 'RegularKey')\n}\n\n/**\n * Validates the account address in a transaction object.\n *\n * @param tx - The transaction object.\n * @param accountField - The field name for the account address in the transaction object.\n * @param tagField - The field name for the tag in the transaction object.\n * @throws {ValidationError} If the tag field does not match the tag of the account address.\n */\nfunction validateAccountAddress(\n  tx: Transaction,\n  accountField: string,\n  tagField: string,\n): void {\n  // if X-address is given, convert it to classic address\n  const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField])\n  // eslint-disable-next-line no-param-reassign -- param reassign is safe\n  tx[accountField] = classicAccount\n\n  if (tag != null && tag !== false) {\n    if (tx[tagField] && tx[tagField] !== tag) {\n      throw new ValidationError(\n        `The ${tagField}, if present, must match the tag of the ${accountField} X-address`,\n      )\n    }\n    // eslint-disable-next-line no-param-reassign -- param reassign is safe\n    tx[tagField] = tag\n  }\n}\n\n/**\n * Retrieves the classic account and tag from an account address.\n *\n * @param Account - The account address.\n * @param [expectedTag] - The expected tag for the account address.\n * @returns The classic account and tag.\n * @throws {ValidationError} If the address includes a tag that does not match the tag specified in the transaction.\n */\nfunction getClassicAccountAndTag(\n  Account: string,\n  expectedTag?: number,\n): ClassicAccountAndTag {\n  if (isValidXAddress(Account)) {\n    const classic = xAddressToClassicAddress(Account)\n    if (expectedTag != null && classic.tag !== expectedTag) {\n      throw new ValidationError(\n        'address includes a tag that does not match the tag specified in the transaction',\n      )\n    }\n    return {\n      classicAccount: classic.classicAddress,\n      tag: classic.tag,\n    }\n  }\n  return {\n    classicAccount: Account,\n    tag: expectedTag,\n  }\n}\n\n/**\n * Converts the specified field of a transaction object to a classic address format.\n *\n * @param tx - The transaction object.\n * @param fieldName - The name of the field to convert.export\n */\nfunction convertToClassicAddress(tx: Transaction, fieldName: string): void {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- assignment is safe\n  const account = tx[fieldName]\n  if (typeof account === 'string') {\n    const { classicAccount } = getClassicAccountAndTag(account)\n    // eslint-disable-next-line no-param-reassign -- param reassign is safe\n    tx[fieldName] = classicAccount\n  }\n}\n\n/**\n * Sets the next valid sequence number for a transaction.\n *\n * @param client - The client object used for making requests.\n * @param tx - The transaction object for which the sequence number needs to be set.\n * @returns A Promise that resolves when the sequence number is set.\n * @throws {Error} If there is an error retrieving the account information.\n */\nexport async function setNextValidSequenceNumber(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  const request: AccountInfoRequest = {\n    command: 'account_info',\n    account: tx.Account,\n    ledger_index: 'current',\n  }\n  const data = await client.request(request)\n  // eslint-disable-next-line no-param-reassign, require-atomic-updates -- param reassign is safe with no race condition\n  tx.Sequence = data.result.account_data.Sequence\n}\n\n/**\n * Fetches the account deletion fee from the server state using the provided client.\n *\n * @param client - The client object used to make the request.\n * @returns A Promise that resolves to the account deletion fee as a BigNumber.\n * @throws {Error} Throws an error if the account deletion fee cannot be fetched.\n */\nasync function fetchAccountDeleteFee(client: Client): Promise<BigNumber> {\n  const response = await client.request({ command: 'server_state' })\n  const fee = response.result.state.validated_ledger?.reserve_inc\n\n  if (fee == null) {\n    return Promise.reject(new Error('Could not fetch Owner Reserve.'))\n  }\n\n  return new BigNumber(fee)\n}\n\n/**\n * Calculates the fee per transaction type.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @param [signersCount=0] - The number of signers (default is 0). Only used for multisigning.\n * @returns A promise that resolves with void. Modifies the `tx` parameter to give it the calculated fee.\n */\nexport async function calculateFeePerTransactionType(\n  client: Client,\n  tx: Transaction,\n  signersCount = 0,\n): Promise<void> {\n  // netFee is usually 0.00001 XRP (10 drops)\n  const netFeeXRP = await getFeeXrp(client)\n  const netFeeDrops = xrpToDrops(netFeeXRP)\n  let baseFee = new BigNumber(netFeeDrops)\n\n  // EscrowFinish Transaction with Fulfillment\n  if (tx.TransactionType === 'EscrowFinish' && tx.Fulfillment != null) {\n    const fulfillmentBytesSize: number = Math.ceil(tx.Fulfillment.length / 2)\n    // 10 drops × (33 + (Fulfillment size in bytes / 16))\n    const product = new BigNumber(\n      // eslint-disable-next-line @typescript-eslint/no-magic-numbers -- expected use of magic numbers\n      scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16),\n    )\n    baseFee = product.dp(0, BigNumber.ROUND_CEIL)\n  }\n\n  if (\n    tx.TransactionType === 'AccountDelete' ||\n    tx.TransactionType === 'AMMCreate'\n  ) {\n    baseFee = await fetchAccountDeleteFee(client)\n  }\n\n  /*\n   * Multi-signed Transaction\n   * 10 drops × (1 + Number of Signatures Provided)\n   */\n  if (signersCount > 0) {\n    baseFee = BigNumber.sum(baseFee, scaleValue(netFeeDrops, 1 + signersCount))\n  }\n\n  const maxFeeDrops = xrpToDrops(client.maxFeeXRP)\n  const totalFee =\n    tx.TransactionType === 'AccountDelete'\n      ? baseFee\n      : BigNumber.min(baseFee, maxFeeDrops)\n\n  // Round up baseFee and return it as a string\n  // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-magic-numbers -- param reassign is safe, base 10 magic num\n  tx.Fee = totalFee.dp(0, BigNumber.ROUND_CEIL).toString(10)\n}\n\n/**\n * Scales the given value by multiplying it with the provided multiplier.\n *\n * @param value - The value to be scaled.\n * @param multiplier - The multiplier to scale the value.\n * @returns The scaled value as a string.\n */\nfunction scaleValue(value, multiplier): string {\n  return new BigNumber(value).times(multiplier).toString()\n}\n\n/**\n * Sets the latest validated ledger sequence for the transaction.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @returns A promise that resolves with void. Modifies the `tx` parameter setting `LastLedgerSequence`.\n */\nexport async function setLatestValidatedLedgerSequence(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  const ledgerSequence = await client.getLedgerIndex()\n  // eslint-disable-next-line no-param-reassign -- param reassign is safe\n  tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET\n}\n\n/**\n * Checks for any blockers that prevent the deletion of an account.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @returns A promise that resolves with void if there are no blockers, or rejects with an XrplError if there are blockers.\n */\nexport async function checkAccountDeleteBlockers(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  const request: AccountObjectsRequest = {\n    command: 'account_objects',\n    account: tx.Account,\n    ledger_index: 'validated',\n    deletion_blockers_only: true,\n  }\n  const response = await client.request(request)\n  return new Promise((resolve, reject) => {\n    if (response.result.account_objects.length > 0) {\n      reject(\n        new XrplError(\n          `Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`,\n          response.result.account_objects,\n        ),\n      )\n    }\n    resolve()\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}