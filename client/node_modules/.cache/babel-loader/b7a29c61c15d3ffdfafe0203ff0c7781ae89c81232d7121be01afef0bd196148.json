{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst errors_1 = require(\"../errors\");\nconst flags_1 = require(\"../models/utils/flags\");\nconst sugar_1 = require(\"../sugar\");\nconst autofill_1 = require(\"../sugar/autofill\");\nconst balances_1 = require(\"../sugar/balances\");\nconst getOrderbook_1 = require(\"../sugar/getOrderbook\");\nconst utils_1 = require(\"../utils\");\nconst Wallet_1 = require(\"../Wallet\");\nconst fundWallet_1 = require(\"../Wallet/fundWallet\");\nconst connection_1 = require(\"./connection\");\nconst partialPayment_1 = require(\"./partialPayment\");\nfunction getCollectKeyFromCommand(command) {\n  switch (command) {\n    case 'account_channels':\n      return 'channels';\n    case 'account_lines':\n      return 'lines';\n    case 'account_objects':\n      return 'account_objects';\n    case 'account_tx':\n      return 'transactions';\n    case 'account_offers':\n    case 'book_offers':\n      return 'offers';\n    case 'ledger_data':\n      return 'state';\n    default:\n      return null;\n  }\n}\nfunction clamp(value, min, max) {\n  if (min > max) {\n    throw new Error('Illegal clamp bounds');\n  }\n  return Math.min(Math.max(value, min), max);\n}\nconst DEFAULT_FEE_CUSHION = 1.2;\nconst DEFAULT_MAX_FEE_XRP = '2';\nconst MIN_LIMIT = 10;\nconst MAX_LIMIT = 400;\nconst NORMAL_DISCONNECT_CODE = 1000;\nclass Client extends eventemitter3_1.EventEmitter {\n  constructor(server, options = {}) {\n    var _a, _b;\n    super();\n    if (typeof server !== 'string' || !/wss?(?:\\+unix)?:\\/\\//u.exec(server)) {\n      throw new errors_1.ValidationError('server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.');\n    }\n    this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;\n    this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;\n    this.connection = new connection_1.Connection(server, options);\n    this.connection.on('error', (errorCode, errorMessage, data) => {\n      this.emit('error', errorCode, errorMessage, data);\n    });\n    this.connection.on('reconnect', () => {\n      this.connection.on('connected', () => this.emit('connected'));\n    });\n    this.connection.on('disconnected', code => {\n      let finalCode = code;\n      if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {\n        finalCode = NORMAL_DISCONNECT_CODE;\n      }\n      this.emit('disconnected', finalCode);\n    });\n    this.connection.on('ledgerClosed', ledger => {\n      this.emit('ledgerClosed', ledger);\n    });\n    this.connection.on('transaction', tx => {\n      (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);\n      this.emit('transaction', tx);\n    });\n    this.connection.on('validationReceived', validation => {\n      this.emit('validationReceived', validation);\n    });\n    this.connection.on('manifestReceived', manifest => {\n      this.emit('manifestReceived', manifest);\n    });\n    this.connection.on('peerStatusChange', status => {\n      this.emit('peerStatusChange', status);\n    });\n    this.connection.on('consensusPhase', consensus => {\n      this.emit('consensusPhase', consensus);\n    });\n    this.connection.on('path_find', path => {\n      this.emit('path_find', path);\n    });\n  }\n  get url() {\n    return this.connection.getUrl();\n  }\n  request(req) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.connection.request(Object.assign(Object.assign({}, req), {\n        account: req.account ? (0, sugar_1.ensureClassicAddress)(req.account) : undefined\n      }));\n      (0, partialPayment_1.handlePartialPayment)(req.command, response);\n      return response;\n    });\n  }\n  requestNextPage(req, resp) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!resp.result.marker) {\n        return Promise.reject(new errors_1.NotFoundError('response does not have a next page'));\n      }\n      const nextPageRequest = Object.assign(Object.assign({}, req), {\n        marker: resp.result.marker\n      });\n      return this.request(nextPageRequest);\n    });\n  }\n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  requestAll(request, collect) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);\n      if (!collectKey) {\n        throw new errors_1.ValidationError(`no collect key for command ${request.command}`);\n      }\n      const countTo = request.limit == null ? Infinity : request.limit;\n      let count = 0;\n      let marker = request.marker;\n      let lastBatchLength;\n      const results = [];\n      do {\n        const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);\n        const repeatProps = Object.assign(Object.assign({}, request), {\n          limit: countRemaining,\n          marker\n        });\n        const singleResponse = yield this.connection.request(repeatProps);\n        const singleResult = singleResponse.result;\n        if (!(collectKey in singleResult)) {\n          throw new errors_1.XrplError(`${collectKey} not in result`);\n        }\n        const collectedData = singleResult[collectKey];\n        marker = singleResult.marker;\n        results.push(singleResponse);\n        if (Array.isArray(collectedData)) {\n          count += collectedData.length;\n          lastBatchLength = collectedData.length;\n        } else {\n          lastBatchLength = 0;\n        }\n      } while (Boolean(marker) && count < countTo && lastBatchLength !== 0);\n      return results;\n    });\n  }\n  getServerInfo() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const response = yield this.request({\n          command: 'server_info'\n        });\n        this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : undefined;\n        this.buildVersion = response.result.info.build_version;\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.getServerInfo();\n        this.emit('connected');\n      }));\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connection.disconnect();\n    });\n  }\n  isConnected() {\n    return this.connection.isConnected();\n  }\n  autofill(transaction, signersCount) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = Object.assign({}, transaction);\n      (0, autofill_1.setValidAddresses)(tx);\n      (0, flags_1.setTransactionFlagsToNumber)(tx);\n      const promises = [];\n      if (tx.NetworkID == null) {\n        tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : undefined;\n      }\n      if (tx.Sequence == null) {\n        promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));\n      }\n      if (tx.Fee == null) {\n        promises.push((0, autofill_1.calculateFeePerTransactionType)(this, tx, signersCount));\n      }\n      if (tx.LastLedgerSequence == null) {\n        promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));\n      }\n      if (tx.TransactionType === 'AccountDelete') {\n        promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));\n      }\n      return Promise.all(promises).then(() => tx);\n    });\n  }\n  submit(transaction, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n      return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n    });\n  }\n  submitAndWait(transaction, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n      const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);\n      if (lastLedger == null) {\n        throw new errors_1.ValidationError('Transaction must contain a LastLedgerSequence value for reliable submission.');\n      }\n      const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n      const txHash = utils_1.hashes.hashSignedTx(signedTx);\n      return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);\n    });\n  }\n  prepareTransaction(transaction, signersCount) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.autofill(transaction, signersCount);\n    });\n  }\n  getXrpBalance(address, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const xrpRequest = {\n        command: 'account_info',\n        account: address,\n        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n        ledger_hash: options.ledger_hash\n      };\n      const response = yield this.request(xrpRequest);\n      return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);\n    });\n  }\n  getBalances(address, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const balances = [];\n      let xrpPromise = Promise.resolve(0);\n      if (!options.peer) {\n        xrpPromise = this.getXrpBalance(address, {\n          ledger_hash: options.ledger_hash,\n          ledger_index: options.ledger_index\n        });\n      }\n      const linesRequest = {\n        command: 'account_lines',\n        account: address,\n        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n        ledger_hash: options.ledger_hash,\n        peer: options.peer,\n        limit: options.limit\n      };\n      const linesPromise = this.requestAll(linesRequest);\n      yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {\n        const accountLinesBalance = linesResponses.flatMap(response => (0, balances_1.formatBalances)(response.result.lines));\n        if (xrpBalance !== 0) {\n          balances.push({\n            currency: 'XRP',\n            value: xrpBalance.toString()\n          });\n        }\n        balances.push(...accountLinesBalance);\n      });\n      return balances.slice(0, options.limit);\n    });\n  }\n  getOrderbook(currency1, currency2, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      (0, getOrderbook_1.validateOrderbookOptions)(options);\n      const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);\n      const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);\n      const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));\n      const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);\n      const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);\n      const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);\n      const {\n        buy,\n        sell\n      } = (0, getOrderbook_1.separateBuySellOrders)(orders);\n      return {\n        buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),\n        sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit)\n      };\n    });\n  }\n  getLedgerIndex() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ledgerResponse = yield this.request({\n        command: 'ledger',\n        ledger_index: 'validated'\n      });\n      return ledgerResponse.result.ledger_index;\n    });\n  }\n  fundWallet(wallet, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isConnected()) {\n        throw new errors_1.RippledError('Client not connected, cannot call faucet');\n      }\n      const existingWallet = Boolean(wallet);\n      const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress) ? wallet : Wallet_1.Wallet.generate();\n      const postBody = {\n        destination: walletToFund.classicAddress,\n        xrpAmount: options.amount,\n        usageContext: options.usageContext,\n        userAgent: 'xrpl.js'\n      };\n      let startingBalance = 0;\n      if (existingWallet) {\n        try {\n          startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));\n        } catch (_a) {}\n      }\n      return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);\n    });\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","Client","eventemitter3_1","require","errors_1","flags_1","sugar_1","autofill_1","balances_1","getOrderbook_1","utils_1","Wallet_1","fundWallet_1","connection_1","partialPayment_1","getCollectKeyFromCommand","command","clamp","min","max","Error","Math","DEFAULT_FEE_CUSHION","DEFAULT_MAX_FEE_XRP","MIN_LIMIT","MAX_LIMIT","NORMAL_DISCONNECT_CODE","EventEmitter","constructor","server","options","_a","_b","exec","ValidationError","feeCushion","maxFeeXRP","connection","Connection","on","errorCode","errorMessage","data","emit","code","finalCode","INTENTIONAL_DISCONNECT_CODE","ledger","tx","handleStreamPartialPayment","trace","validation","manifest","status","consensus","path","url","getUrl","request","req","response","assign","account","ensureClassicAddress","undefined","handlePartialPayment","requestNextPage","resp","marker","NotFoundError","nextPageRequest","eventName","listener","requestAll","collect","collectKey","countTo","limit","Infinity","count","lastBatchLength","results","countRemaining","repeatProps","singleResponse","singleResult","XrplError","collectedData","push","Array","isArray","length","Boolean","getServerInfo","networkID","info","network_id","buildVersion","build_version","error","console","connect","disconnect","isConnected","autofill","transaction","signersCount","setValidAddresses","setTransactionFlagsToNumber","promises","NetworkID","txNeedsNetworkID","Sequence","setNextValidSequenceNumber","Fee","calculateFeePerTransactionType","LastLedgerSequence","setLatestValidatedLedgerSequence","TransactionType","checkAccountDeleteBlockers","all","submit","opts","signedTx","getSignedTx","submitRequest","failHard","submitAndWait","lastLedger","getLastLedgerSequence","txHash","hashes","hashSignedTx","waitForFinalTransactionOutcome","engine_result","prepareTransaction","getXrpBalance","address","xrpRequest","ledger_index","ledger_hash","dropsToXrp","account_data","Balance","getBalances","balances","xrpPromise","peer","linesRequest","linesPromise","xrpBalance","linesResponses","accountLinesBalance","flatMap","formatBalances","lines","currency","toString","slice","getOrderbook","currency1","currency2","validateOrderbookOptions","createBookOffersRequest","directOfferResults","requestAllOffers","reverseOfferResults","reverseRequest","directOffers","extractOffers","reverseOffers","orders","combineOrders","buy","sell","separateBuySellOrders","sortAndLimitOffers","getLedgerIndex","ledgerResponse","fundWallet","wallet","RippledError","existingWallet","walletToFund","isValidClassicAddress","classicAddress","Wallet","generate","postBody","destination","xrpAmount","amount","usageContext","userAgent","startingBalance","Number","requestFunding"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/client/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst errors_1 = require(\"../errors\");\nconst flags_1 = require(\"../models/utils/flags\");\nconst sugar_1 = require(\"../sugar\");\nconst autofill_1 = require(\"../sugar/autofill\");\nconst balances_1 = require(\"../sugar/balances\");\nconst getOrderbook_1 = require(\"../sugar/getOrderbook\");\nconst utils_1 = require(\"../utils\");\nconst Wallet_1 = require(\"../Wallet\");\nconst fundWallet_1 = require(\"../Wallet/fundWallet\");\nconst connection_1 = require(\"./connection\");\nconst partialPayment_1 = require(\"./partialPayment\");\nfunction getCollectKeyFromCommand(command) {\n    switch (command) {\n        case 'account_channels':\n            return 'channels';\n        case 'account_lines':\n            return 'lines';\n        case 'account_objects':\n            return 'account_objects';\n        case 'account_tx':\n            return 'transactions';\n        case 'account_offers':\n        case 'book_offers':\n            return 'offers';\n        case 'ledger_data':\n            return 'state';\n        default:\n            return null;\n    }\n}\nfunction clamp(value, min, max) {\n    if (min > max) {\n        throw new Error('Illegal clamp bounds');\n    }\n    return Math.min(Math.max(value, min), max);\n}\nconst DEFAULT_FEE_CUSHION = 1.2;\nconst DEFAULT_MAX_FEE_XRP = '2';\nconst MIN_LIMIT = 10;\nconst MAX_LIMIT = 400;\nconst NORMAL_DISCONNECT_CODE = 1000;\nclass Client extends eventemitter3_1.EventEmitter {\n    constructor(server, options = {}) {\n        var _a, _b;\n        super();\n        if (typeof server !== 'string' || !/wss?(?:\\+unix)?:\\/\\//u.exec(server)) {\n            throw new errors_1.ValidationError('server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.');\n        }\n        this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;\n        this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;\n        this.connection = new connection_1.Connection(server, options);\n        this.connection.on('error', (errorCode, errorMessage, data) => {\n            this.emit('error', errorCode, errorMessage, data);\n        });\n        this.connection.on('reconnect', () => {\n            this.connection.on('connected', () => this.emit('connected'));\n        });\n        this.connection.on('disconnected', (code) => {\n            let finalCode = code;\n            if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {\n                finalCode = NORMAL_DISCONNECT_CODE;\n            }\n            this.emit('disconnected', finalCode);\n        });\n        this.connection.on('ledgerClosed', (ledger) => {\n            this.emit('ledgerClosed', ledger);\n        });\n        this.connection.on('transaction', (tx) => {\n            (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);\n            this.emit('transaction', tx);\n        });\n        this.connection.on('validationReceived', (validation) => {\n            this.emit('validationReceived', validation);\n        });\n        this.connection.on('manifestReceived', (manifest) => {\n            this.emit('manifestReceived', manifest);\n        });\n        this.connection.on('peerStatusChange', (status) => {\n            this.emit('peerStatusChange', status);\n        });\n        this.connection.on('consensusPhase', (consensus) => {\n            this.emit('consensusPhase', consensus);\n        });\n        this.connection.on('path_find', (path) => {\n            this.emit('path_find', path);\n        });\n    }\n    get url() {\n        return this.connection.getUrl();\n    }\n    request(req) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.connection.request(Object.assign(Object.assign({}, req), { account: req.account\n                    ?\n                        (0, sugar_1.ensureClassicAddress)(req.account)\n                    : undefined }));\n            (0, partialPayment_1.handlePartialPayment)(req.command, response);\n            return response;\n        });\n    }\n    requestNextPage(req, resp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!resp.result.marker) {\n                return Promise.reject(new errors_1.NotFoundError('response does not have a next page'));\n            }\n            const nextPageRequest = Object.assign(Object.assign({}, req), { marker: resp.result.marker });\n            return this.request(nextPageRequest);\n        });\n    }\n    on(eventName, listener) {\n        return super.on(eventName, listener);\n    }\n    requestAll(request, collect) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);\n            if (!collectKey) {\n                throw new errors_1.ValidationError(`no collect key for command ${request.command}`);\n            }\n            const countTo = request.limit == null ? Infinity : request.limit;\n            let count = 0;\n            let marker = request.marker;\n            let lastBatchLength;\n            const results = [];\n            do {\n                const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);\n                const repeatProps = Object.assign(Object.assign({}, request), { limit: countRemaining, marker });\n                const singleResponse = yield this.connection.request(repeatProps);\n                const singleResult = singleResponse.result;\n                if (!(collectKey in singleResult)) {\n                    throw new errors_1.XrplError(`${collectKey} not in result`);\n                }\n                const collectedData = singleResult[collectKey];\n                marker = singleResult.marker;\n                results.push(singleResponse);\n                if (Array.isArray(collectedData)) {\n                    count += collectedData.length;\n                    lastBatchLength = collectedData.length;\n                }\n                else {\n                    lastBatchLength = 0;\n                }\n            } while (Boolean(marker) && count < countTo && lastBatchLength !== 0);\n            return results;\n        });\n    }\n    getServerInfo() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.request({\n                    command: 'server_info',\n                });\n                this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : undefined;\n                this.buildVersion = response.result.info.build_version;\n            }\n            catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {\n                yield this.getServerInfo();\n                this.emit('connected');\n            }));\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connection.disconnect();\n        });\n    }\n    isConnected() {\n        return this.connection.isConnected();\n    }\n    autofill(transaction, signersCount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tx = Object.assign({}, transaction);\n            (0, autofill_1.setValidAddresses)(tx);\n            (0, flags_1.setTransactionFlagsToNumber)(tx);\n            const promises = [];\n            if (tx.NetworkID == null) {\n                tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : undefined;\n            }\n            if (tx.Sequence == null) {\n                promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));\n            }\n            if (tx.Fee == null) {\n                promises.push((0, autofill_1.calculateFeePerTransactionType)(this, tx, signersCount));\n            }\n            if (tx.LastLedgerSequence == null) {\n                promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));\n            }\n            if (tx.TransactionType === 'AccountDelete') {\n                promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));\n            }\n            return Promise.all(promises).then(() => tx);\n        });\n    }\n    submit(transaction, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n            return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n        });\n    }\n    submitAndWait(transaction, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n            const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);\n            if (lastLedger == null) {\n                throw new errors_1.ValidationError('Transaction must contain a LastLedgerSequence value for reliable submission.');\n            }\n            const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n            const txHash = utils_1.hashes.hashSignedTx(signedTx);\n            return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);\n        });\n    }\n    prepareTransaction(transaction, signersCount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.autofill(transaction, signersCount);\n        });\n    }\n    getXrpBalance(address, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const xrpRequest = {\n                command: 'account_info',\n                account: address,\n                ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n                ledger_hash: options.ledger_hash,\n            };\n            const response = yield this.request(xrpRequest);\n            return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);\n        });\n    }\n    getBalances(address, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const balances = [];\n            let xrpPromise = Promise.resolve(0);\n            if (!options.peer) {\n                xrpPromise = this.getXrpBalance(address, {\n                    ledger_hash: options.ledger_hash,\n                    ledger_index: options.ledger_index,\n                });\n            }\n            const linesRequest = {\n                command: 'account_lines',\n                account: address,\n                ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n                ledger_hash: options.ledger_hash,\n                peer: options.peer,\n                limit: options.limit,\n            };\n            const linesPromise = this.requestAll(linesRequest);\n            yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {\n                const accountLinesBalance = linesResponses.flatMap((response) => (0, balances_1.formatBalances)(response.result.lines));\n                if (xrpBalance !== 0) {\n                    balances.push({ currency: 'XRP', value: xrpBalance.toString() });\n                }\n                balances.push(...accountLinesBalance);\n            });\n            return balances.slice(0, options.limit);\n        });\n    }\n    getOrderbook(currency1, currency2, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, getOrderbook_1.validateOrderbookOptions)(options);\n            const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);\n            const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);\n            const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));\n            const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);\n            const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);\n            const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);\n            const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(orders);\n            return {\n                buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),\n                sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit),\n            };\n        });\n    }\n    getLedgerIndex() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ledgerResponse = yield this.request({\n                command: 'ledger',\n                ledger_index: 'validated',\n            });\n            return ledgerResponse.result.ledger_index;\n        });\n    }\n    fundWallet(wallet, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isConnected()) {\n                throw new errors_1.RippledError('Client not connected, cannot call faucet');\n            }\n            const existingWallet = Boolean(wallet);\n            const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress)\n                ? wallet\n                : Wallet_1.Wallet.generate();\n            const postBody = {\n                destination: walletToFund.classicAddress,\n                xrpAmount: options.amount,\n                usageContext: options.usageContext,\n                userAgent: 'xrpl.js',\n            };\n            let startingBalance = 0;\n            if (existingWallet) {\n                try {\n                    startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));\n                }\n                catch (_a) {\n                }\n            }\n            return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);\n        });\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=index.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}