{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;\nvar Prefix;\n(function (Prefix) {\n  Prefix[Prefix[\"NONE\"] = -1] = \"NONE\";\n  Prefix[Prefix[\"ED25519\"] = 237] = \"ED25519\";\n  Prefix[Prefix[\"SECP256K1_PUB_X\"] = 2] = \"SECP256K1_PUB_X\";\n  Prefix[Prefix[\"SECP256K1_PUB_X_ODD_Y\"] = 3] = \"SECP256K1_PUB_X_ODD_Y\";\n  Prefix[Prefix[\"SECP256K1_PUB_XY\"] = 4] = \"SECP256K1_PUB_XY\";\n  Prefix[Prefix[\"SECP256K1_PRIVATE\"] = 0] = \"SECP256K1_PRIVATE\";\n})(Prefix || (Prefix = {}));\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES = {\n  [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1'\n};\nfunction getKeyInfo(key) {\n  return {\n    prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n    len: key.length / 2\n  };\n}\nfunction prefixRepr(prefix) {\n  return prefix === Prefix.NONE ? 'None' : `0x${prefix.toString(16).padStart(2, '0')}`;\n}\nfunction getValidFormatsTable(type) {\n  // No need overkill with renderTable method\n  const padding = 2;\n  const colWidth = {\n    algorithm: 'ecdsa-secp256k1'.length + padding,\n    prefix: '0x00'.length + padding\n  };\n  return Object.entries(KEY_TYPES).filter(([key]) => key.startsWith(type)).map(([key, algorithm]) => {\n    const [, prefix, length] = key.split('_');\n    const paddedAlgo = algorithm.padEnd(colWidth.algorithm);\n    const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);\n    return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;\n  }).join('\\n');\n}\nfunction keyError({\n  key,\n  type,\n  prefix,\n  len\n}) {\n  const validFormats = getValidFormatsTable(type);\n  return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`;\n}\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nfunction getAlgorithmFromKey(key, type) {\n  const {\n    prefix,\n    len\n  } = getKeyInfo(key);\n  // Special case back compat support for no prefix\n  const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix;\n  const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];\n  if (!algorithm) {\n    throw new Error(keyError({\n      key,\n      type,\n      len,\n      prefix: usedPrefix\n    }));\n  }\n  return algorithm;\n}\nexports.getAlgorithmFromKey = getAlgorithmFromKey;\nfunction getAlgorithmFromPublicKey(key) {\n  return getAlgorithmFromKey(key, 'public');\n}\nexports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;\nfunction getAlgorithmFromPrivateKey(key) {\n  return getAlgorithmFromKey(key, 'private');\n}\nexports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;","map":{"version":3,"names":["Prefix","KEY_TYPES","NONE","SECP256K1_PRIVATE","ED25519","SECP256K1_PUB_X","SECP256K1_PUB_X_ODD_Y","SECP256K1_PUB_XY","getKeyInfo","key","prefix","length","parseInt","slice","len","prefixRepr","toString","padStart","getValidFormatsTable","type","padding","colWidth","algorithm","Object","entries","filter","startsWith","map","split","paddedAlgo","padEnd","paddedPrefix","Number","join","keyError","validFormats","getAlgorithmFromKey","usedPrefix","Error","exports","getAlgorithmFromPublicKey","getAlgorithmFromPrivateKey"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-keypairs/src/utils/getAlgorithmFromKey.ts"],"sourcesContent":["import type { Algorithm, HexString, KeyType } from '../types'\n\nenum Prefix {\n  NONE = -1,\n  ED25519 = 0xed,\n  SECP256K1_PUB_X = 0x02,\n  SECP256K1_PUB_X_ODD_Y = 0x03,\n  SECP256K1_PUB_XY = 0x04,\n  SECP256K1_PRIVATE = 0x00,\n}\n\ntype CompositeKey = `${KeyType}_${Prefix}_${number}`\n\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES: Record<CompositeKey, Algorithm> = {\n  [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',\n}\n\nfunction getKeyInfo(key: HexString) {\n  return {\n    prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n    len: key.length / 2,\n  }\n}\n\nfunction prefixRepr(prefix: Prefix): string {\n  return prefix === Prefix.NONE\n    ? 'None'\n    : `0x${prefix.toString(16).padStart(2, '0')}`\n}\n\nfunction getValidFormatsTable(type: KeyType) {\n  // No need overkill with renderTable method\n  const padding = 2\n  const colWidth = {\n    algorithm: 'ecdsa-secp256k1'.length + padding,\n    prefix: '0x00'.length + padding,\n  }\n\n  return Object.entries(KEY_TYPES)\n    .filter(([key]) => key.startsWith(type))\n    .map(([key, algorithm]) => {\n      const [, prefix, length] = key.split('_')\n      const paddedAlgo = algorithm.padEnd(colWidth.algorithm)\n      const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix)\n      return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`\n    })\n    .join('\\n')\n}\n\nfunction keyError({\n  key,\n  type,\n  prefix,\n  len,\n}: {\n  key: string\n  type: KeyType\n  prefix: number\n  len: number\n}) {\n  const validFormats = getValidFormatsTable(type)\n\n  return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`\n}\n\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nexport function getAlgorithmFromKey(key: HexString, type: KeyType): Algorithm {\n  const { prefix, len } = getKeyInfo(key)\n  // Special case back compat support for no prefix\n  const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix\n  const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`]\n\n  if (!algorithm) {\n    throw new Error(keyError({ key, type, len, prefix: usedPrefix }))\n  }\n  return algorithm\n}\n\nexport function getAlgorithmFromPublicKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'public')\n}\n\nexport function getAlgorithmFromPrivateKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'private')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}