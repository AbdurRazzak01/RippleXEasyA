{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountID = void 0;\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst hash_160_1 = require(\"./hash-160\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst HEX_REGEX = /^[A-F0-9]{40}$/;\n/**\n * Class defining how to encode and decode an AccountID\n */\nclass AccountID extends hash_160_1.Hash160 {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes);\n  }\n  /**\n   * Defines how to construct an AccountID\n   *\n   * @param value either an existing AccountID, a hex-string, or a base58 r-Address\n   * @returns an AccountID object\n   */\n  static from(value) {\n    if (value instanceof AccountID) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      if (value === '') {\n        return new AccountID();\n      }\n      return HEX_REGEX.test(value) ? new AccountID((0, utils_1.hexToBytes)(value)) : this.fromBase58(value);\n    }\n    throw new Error('Cannot construct AccountID from value given');\n  }\n  /**\n   * Defines how to build an AccountID from a base58 r-Address\n   *\n   * @param value a base58 r-Address\n   * @returns an AccountID object\n   */\n  static fromBase58(value) {\n    if ((0, ripple_address_codec_1.isValidXAddress)(value)) {\n      const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);\n      if (classic.tag !== false) throw new Error('Only allowed to have tag on Account or Destination');\n      value = classic.classicAddress;\n    }\n    return new AccountID(Uint8Array.from((0, ripple_address_codec_1.decodeAccountID)(value)));\n  }\n  /**\n   * Overload of toJSON\n   *\n   * @returns the base58 string for this AccountID\n   */\n  toJSON() {\n    return this.toBase58();\n  }\n  /**\n   * Defines how to encode AccountID into a base58 address\n   *\n   * @returns the base58 string defined by this.bytes\n   */\n  toBase58() {\n    return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);\n  }\n}\nexports.AccountID = AccountID;\nAccountID.defaultAccountID = new AccountID(new Uint8Array(20));","map":{"version":3,"names":["ripple_address_codec_1","require","hash_160_1","utils_1","HEX_REGEX","AccountID","Hash160","constructor","bytes","defaultAccountID","from","value","test","hexToBytes","fromBase58","Error","isValidXAddress","classic","xAddressToClassicAddress","tag","classicAddress","Uint8Array","decodeAccountID","toJSON","toBase58","encodeAccountID","exports"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/types/account-id.ts"],"sourcesContent":["import {\n  decodeAccountID,\n  encodeAccountID,\n  isValidXAddress,\n  xAddressToClassicAddress,\n} from 'ripple-address-codec'\nimport { Hash160 } from './hash-160'\nimport { hexToBytes } from '@xrplf/isomorphic/utils'\n\nconst HEX_REGEX = /^[A-F0-9]{40}$/\n\n/**\n * Class defining how to encode and decode an AccountID\n */\nclass AccountID extends Hash160 {\n  static readonly defaultAccountID: AccountID = new AccountID(\n    new Uint8Array(20),\n  )\n\n  constructor(bytes?: Uint8Array) {\n    super(bytes ?? AccountID.defaultAccountID.bytes)\n  }\n\n  /**\n   * Defines how to construct an AccountID\n   *\n   * @param value either an existing AccountID, a hex-string, or a base58 r-Address\n   * @returns an AccountID object\n   */\n  static from<T extends Hash160 | string>(value: T): AccountID {\n    if (value instanceof AccountID) {\n      return value\n    }\n\n    if (typeof value === 'string') {\n      if (value === '') {\n        return new AccountID()\n      }\n\n      return HEX_REGEX.test(value)\n        ? new AccountID(hexToBytes(value))\n        : this.fromBase58(value)\n    }\n\n    throw new Error('Cannot construct AccountID from value given')\n  }\n\n  /**\n   * Defines how to build an AccountID from a base58 r-Address\n   *\n   * @param value a base58 r-Address\n   * @returns an AccountID object\n   */\n  static fromBase58(value: string): AccountID {\n    if (isValidXAddress(value)) {\n      const classic = xAddressToClassicAddress(value)\n\n      if (classic.tag !== false)\n        throw new Error('Only allowed to have tag on Account or Destination')\n\n      value = classic.classicAddress\n    }\n\n    return new AccountID(Uint8Array.from(decodeAccountID(value)))\n  }\n\n  /**\n   * Overload of toJSON\n   *\n   * @returns the base58 string for this AccountID\n   */\n  toJSON(): string {\n    return this.toBase58()\n  }\n\n  /**\n   * Defines how to encode AccountID into a base58 address\n   *\n   * @returns the base58 string defined by this.bytes\n   */\n  toBase58(): string {\n    return encodeAccountID(this.bytes)\n  }\n}\n\nexport { AccountID }\n"],"mappings":";;;;;;AAAA,MAAAA,sBAAA,GAAAC,OAAA;AAMA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAEA,MAAMG,SAAS,GAAG,gBAAgB;AAElC;;;AAGA,MAAMC,SAAU,SAAQH,UAAA,CAAAI,OAAO;EAK7BC,YAAYC,KAAkB;IAC5B,KAAK,CAACA,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIH,SAAS,CAACI,gBAAgB,CAACD,KAAK,CAAC;EAClD;EAEA;;;;;;EAMA,OAAOE,IAAIA,CAA6BC,KAAQ;IAC9C,IAAIA,KAAK,YAAYN,SAAS,EAAE;MAC9B,OAAOM,KAAK;;IAGd,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,IAAIA,KAAK,KAAK,EAAE,EAAE;QAChB,OAAO,IAAIN,SAAS,EAAE;;MAGxB,OAAOD,SAAS,CAACQ,IAAI,CAACD,KAAK,CAAC,GACxB,IAAIN,SAAS,CAAC,IAAAF,OAAA,CAAAU,UAAU,EAACF,KAAK,CAAC,CAAC,GAChC,IAAI,CAACG,UAAU,CAACH,KAAK,CAAC;;IAG5B,MAAM,IAAII,KAAK,CAAC,6CAA6C,CAAC;EAChE;EAEA;;;;;;EAMA,OAAOD,UAAUA,CAACH,KAAa;IAC7B,IAAI,IAAAX,sBAAA,CAAAgB,eAAe,EAACL,KAAK,CAAC,EAAE;MAC1B,MAAMM,OAAO,GAAG,IAAAjB,sBAAA,CAAAkB,wBAAwB,EAACP,KAAK,CAAC;MAE/C,IAAIM,OAAO,CAACE,GAAG,KAAK,KAAK,EACvB,MAAM,IAAIJ,KAAK,CAAC,oDAAoD,CAAC;MAEvEJ,KAAK,GAAGM,OAAO,CAACG,cAAc;;IAGhC,OAAO,IAAIf,SAAS,CAACgB,UAAU,CAACX,IAAI,CAAC,IAAAV,sBAAA,CAAAsB,eAAe,EAACX,KAAK,CAAC,CAAC,CAAC;EAC/D;EAEA;;;;;EAKAY,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACC,QAAQ,EAAE;EACxB;EAEA;;;;;EAKAA,QAAQA,CAAA;IACN,OAAO,IAAAxB,sBAAA,CAAAyB,eAAe,EAAC,IAAI,CAACjB,KAAK,CAAC;EACpC;;AAGOkB,OAAA,CAAArB,SAAA,GAAAA,SAAA;AAtESA,SAAA,CAAAI,gBAAgB,GAAc,IAAIJ,SAAS,CACzD,IAAIgB,UAAU,CAAC,EAAE,CAAC,CACnB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}