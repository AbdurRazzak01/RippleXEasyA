{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathSet = void 0;\nconst account_id_1 = require(\"./account-id\");\nconst currency_1 = require(\"./currency\");\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * Constants for separating Paths in a PathSet\n */\nconst PATHSET_END_BYTE = 0x00;\nconst PATH_SEPARATOR_BYTE = 0xff;\n/**\n * Constant for masking types of a Hop\n */\nconst TYPE_ACCOUNT = 0x01;\nconst TYPE_CURRENCY = 0x10;\nconst TYPE_ISSUER = 0x20;\n/**\n * TypeGuard for HopObject\n */\nfunction isHopObject(arg) {\n  return arg.issuer !== undefined || arg.account !== undefined || arg.currency !== undefined;\n}\n/**\n * TypeGuard for PathSet\n */\nfunction isPathSet(arg) {\n  return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);\n}\n/**\n * Serialize and Deserialize a Hop\n */\nclass Hop extends serialized_type_1.SerializedType {\n  /**\n   * Create a Hop from a HopObject\n   *\n   * @param value Either a hop or HopObject to create a hop with\n   * @returns a Hop\n   */\n  static from(value) {\n    if (value instanceof Hop) {\n      return value;\n    }\n    const bytes = [Uint8Array.from([0])];\n    if (value.account) {\n      bytes.push(account_id_1.AccountID.from(value.account).toBytes());\n      bytes[0][0] |= TYPE_ACCOUNT;\n    }\n    if (value.currency) {\n      bytes.push(currency_1.Currency.from(value.currency).toBytes());\n      bytes[0][0] |= TYPE_CURRENCY;\n    }\n    if (value.issuer) {\n      bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());\n      bytes[0][0] |= TYPE_ISSUER;\n    }\n    return new Hop((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Construct a Hop from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Hop from\n   * @returns a Hop\n   */\n  static fromParser(parser) {\n    const type = parser.readUInt8();\n    const bytes = [Uint8Array.from([type])];\n    if (type & TYPE_ACCOUNT) {\n      bytes.push(parser.read(account_id_1.AccountID.width));\n    }\n    if (type & TYPE_CURRENCY) {\n      bytes.push(parser.read(currency_1.Currency.width));\n    }\n    if (type & TYPE_ISSUER) {\n      bytes.push(parser.read(account_id_1.AccountID.width));\n    }\n    return new Hop((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Get the JSON interpretation of this hop\n   *\n   * @returns a HopObject, an JS object with optional account, issuer, and currency\n   */\n  toJSON() {\n    const hopParser = new binary_parser_1.BinaryParser((0, utils_1.bytesToHex)(this.bytes));\n    const type = hopParser.readUInt8();\n    let account, currency, issuer;\n    if (type & TYPE_ACCOUNT) {\n      account = account_id_1.AccountID.fromParser(hopParser).toJSON();\n    }\n    if (type & TYPE_CURRENCY) {\n      currency = currency_1.Currency.fromParser(hopParser).toJSON();\n    }\n    if (type & TYPE_ISSUER) {\n      issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();\n    }\n    const result = {};\n    if (account) {\n      result.account = account;\n    }\n    if (issuer) {\n      result.issuer = issuer;\n    }\n    if (currency) {\n      result.currency = currency;\n    }\n    return result;\n  }\n  /**\n   * get a number representing the type of this hop\n   *\n   * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop\n   */\n  type() {\n    return this.bytes[0];\n  }\n}\n/**\n * Class for serializing/deserializing Paths\n */\nclass Path extends serialized_type_1.SerializedType {\n  /**\n   * construct a Path from an array of Hops\n   *\n   * @param value Path or array of HopObjects to construct a Path\n   * @returns the Path\n   */\n  static from(value) {\n    if (value instanceof Path) {\n      return value;\n    }\n    const bytes = [];\n    value.forEach(hop => {\n      bytes.push(Hop.from(hop).toBytes());\n    });\n    return new Path((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Read a Path from a BinaryParser\n   *\n   * @param parser BinaryParser to read Path from\n   * @returns the Path represented by the bytes read from the BinaryParser\n   */\n  static fromParser(parser) {\n    const bytes = [];\n    while (!parser.end()) {\n      bytes.push(Hop.fromParser(parser).toBytes());\n      if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {\n        break;\n      }\n    }\n    return new Path((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Get the JSON representation of this Path\n   *\n   * @returns an Array of HopObject constructed from this.bytes\n   */\n  toJSON() {\n    const json = [];\n    const pathParser = new binary_parser_1.BinaryParser(this.toString());\n    while (!pathParser.end()) {\n      json.push(Hop.fromParser(pathParser).toJSON());\n    }\n    return json;\n  }\n}\n/**\n * Deserialize and Serialize the PathSet type\n */\nclass PathSet extends serialized_type_1.SerializedType {\n  /**\n   * Construct a PathSet from an Array of Arrays representing paths\n   *\n   * @param value A PathSet or Array of Array of HopObjects\n   * @returns the PathSet constructed from value\n   */\n  static from(value) {\n    if (value instanceof PathSet) {\n      return value;\n    }\n    if (isPathSet(value)) {\n      const bytes = [];\n      value.forEach(path => {\n        bytes.push(Path.from(path).toBytes());\n        bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));\n      });\n      bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);\n      return new PathSet((0, utils_1.concat)(bytes));\n    }\n    throw new Error('Cannot construct PathSet from given value');\n  }\n  /**\n   * Construct a PathSet from a BinaryParser\n   *\n   * @param parser A BinaryParser to read PathSet from\n   * @returns the PathSet read from parser\n   */\n  static fromParser(parser) {\n    const bytes = [];\n    while (!parser.end()) {\n      bytes.push(Path.fromParser(parser).toBytes());\n      bytes.push(parser.read(1));\n      if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {\n        break;\n      }\n    }\n    return new PathSet((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Get the JSON representation of this PathSet\n   *\n   * @returns an Array of Array of HopObjects, representing this PathSet\n   */\n  toJSON() {\n    const json = [];\n    const pathParser = new binary_parser_1.BinaryParser(this.toString());\n    while (!pathParser.end()) {\n      json.push(Path.fromParser(pathParser).toJSON());\n      pathParser.skip(1);\n    }\n    return json;\n  }\n}\nexports.PathSet = PathSet;","map":{"version":3,"names":["account_id_1","require","currency_1","binary_parser_1","serialized_type_1","utils_1","PATHSET_END_BYTE","PATH_SEPARATOR_BYTE","TYPE_ACCOUNT","TYPE_CURRENCY","TYPE_ISSUER","isHopObject","arg","issuer","undefined","account","currency","isPathSet","Array","isArray","length","Hop","SerializedType","from","value","bytes","Uint8Array","push","AccountID","toBytes","Currency","concat","fromParser","parser","type","readUInt8","read","width","toJSON","hopParser","BinaryParser","bytesToHex","result","Path","forEach","hop","end","peek","json","pathParser","toString","PathSet","path","Error","skip","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/types/path-set.ts"],"sourcesContent":["import { AccountID } from './account-id'\nimport { Currency } from './currency'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { SerializedType, JsonObject } from './serialized-type'\nimport { bytesToHex, concat } from '@xrplf/isomorphic/utils'\n\n/**\n * Constants for separating Paths in a PathSet\n */\nconst PATHSET_END_BYTE = 0x00\nconst PATH_SEPARATOR_BYTE = 0xff\n\n/**\n * Constant for masking types of a Hop\n */\nconst TYPE_ACCOUNT = 0x01\nconst TYPE_CURRENCY = 0x10\nconst TYPE_ISSUER = 0x20\n\n/**\n * The object representation of a Hop, an issuer AccountID, an account AccountID, and a Currency\n */\ninterface HopObject extends JsonObject {\n  issuer?: string\n  account?: string\n  currency?: string\n}\n\n/**\n * TypeGuard for HopObject\n */\nfunction isHopObject(arg): arg is HopObject {\n  return (\n    arg.issuer !== undefined ||\n    arg.account !== undefined ||\n    arg.currency !== undefined\n  )\n}\n\n/**\n * TypeGuard for PathSet\n */\nfunction isPathSet(arg): arg is Array<Array<HopObject>> {\n  return (\n    (Array.isArray(arg) && arg.length === 0) ||\n    (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||\n    (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]))\n  )\n}\n\n/**\n * Serialize and Deserialize a Hop\n */\nclass Hop extends SerializedType {\n  /**\n   * Create a Hop from a HopObject\n   *\n   * @param value Either a hop or HopObject to create a hop with\n   * @returns a Hop\n   */\n  static from(value: Hop | HopObject): Hop {\n    if (value instanceof Hop) {\n      return value\n    }\n\n    const bytes: Array<Uint8Array> = [Uint8Array.from([0])]\n\n    if (value.account) {\n      bytes.push(AccountID.from(value.account).toBytes())\n      bytes[0][0] |= TYPE_ACCOUNT\n    }\n\n    if (value.currency) {\n      bytes.push(Currency.from(value.currency).toBytes())\n      bytes[0][0] |= TYPE_CURRENCY\n    }\n\n    if (value.issuer) {\n      bytes.push(AccountID.from(value.issuer).toBytes())\n      bytes[0][0] |= TYPE_ISSUER\n    }\n\n    return new Hop(concat(bytes))\n  }\n\n  /**\n   * Construct a Hop from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Hop from\n   * @returns a Hop\n   */\n  static fromParser(parser: BinaryParser): Hop {\n    const type = parser.readUInt8()\n    const bytes: Array<Uint8Array> = [Uint8Array.from([type])]\n\n    if (type & TYPE_ACCOUNT) {\n      bytes.push(parser.read(AccountID.width))\n    }\n\n    if (type & TYPE_CURRENCY) {\n      bytes.push(parser.read(Currency.width))\n    }\n\n    if (type & TYPE_ISSUER) {\n      bytes.push(parser.read(AccountID.width))\n    }\n\n    return new Hop(concat(bytes))\n  }\n\n  /**\n   * Get the JSON interpretation of this hop\n   *\n   * @returns a HopObject, an JS object with optional account, issuer, and currency\n   */\n  toJSON(): HopObject {\n    const hopParser = new BinaryParser(bytesToHex(this.bytes))\n    const type = hopParser.readUInt8()\n\n    let account, currency, issuer\n    if (type & TYPE_ACCOUNT) {\n      account = (AccountID.fromParser(hopParser) as AccountID).toJSON()\n    }\n\n    if (type & TYPE_CURRENCY) {\n      currency = (Currency.fromParser(hopParser) as Currency).toJSON()\n    }\n\n    if (type & TYPE_ISSUER) {\n      issuer = (AccountID.fromParser(hopParser) as AccountID).toJSON()\n    }\n\n    const result: HopObject = {}\n    if (account) {\n      result.account = account\n    }\n\n    if (issuer) {\n      result.issuer = issuer\n    }\n\n    if (currency) {\n      result.currency = currency\n    }\n\n    return result\n  }\n\n  /**\n   * get a number representing the type of this hop\n   *\n   * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop\n   */\n  type(): number {\n    return this.bytes[0]\n  }\n}\n\n/**\n * Class for serializing/deserializing Paths\n */\nclass Path extends SerializedType {\n  /**\n   * construct a Path from an array of Hops\n   *\n   * @param value Path or array of HopObjects to construct a Path\n   * @returns the Path\n   */\n  static from(value: Path | Array<HopObject>): Path {\n    if (value instanceof Path) {\n      return value\n    }\n\n    const bytes: Array<Uint8Array> = []\n    value.forEach((hop: HopObject) => {\n      bytes.push(Hop.from(hop).toBytes())\n    })\n\n    return new Path(concat(bytes))\n  }\n\n  /**\n   * Read a Path from a BinaryParser\n   *\n   * @param parser BinaryParser to read Path from\n   * @returns the Path represented by the bytes read from the BinaryParser\n   */\n  static fromParser(parser: BinaryParser): Path {\n    const bytes: Array<Uint8Array> = []\n    while (!parser.end()) {\n      bytes.push(Hop.fromParser(parser).toBytes())\n\n      if (\n        parser.peek() === PATHSET_END_BYTE ||\n        parser.peek() === PATH_SEPARATOR_BYTE\n      ) {\n        break\n      }\n    }\n    return new Path(concat(bytes))\n  }\n\n  /**\n   * Get the JSON representation of this Path\n   *\n   * @returns an Array of HopObject constructed from this.bytes\n   */\n  toJSON(): Array<HopObject> {\n    const json: Array<HopObject> = []\n    const pathParser = new BinaryParser(this.toString())\n\n    while (!pathParser.end()) {\n      json.push(Hop.fromParser(pathParser).toJSON())\n    }\n\n    return json\n  }\n}\n\n/**\n * Deserialize and Serialize the PathSet type\n */\nclass PathSet extends SerializedType {\n  /**\n   * Construct a PathSet from an Array of Arrays representing paths\n   *\n   * @param value A PathSet or Array of Array of HopObjects\n   * @returns the PathSet constructed from value\n   */\n  static from<T extends PathSet | Array<Array<HopObject>>>(value: T): PathSet {\n    if (value instanceof PathSet) {\n      return value\n    }\n\n    if (isPathSet(value)) {\n      const bytes: Array<Uint8Array> = []\n\n      value.forEach((path: Array<HopObject>) => {\n        bytes.push(Path.from(path).toBytes())\n        bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]))\n      })\n\n      bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE])\n\n      return new PathSet(concat(bytes))\n    }\n\n    throw new Error('Cannot construct PathSet from given value')\n  }\n\n  /**\n   * Construct a PathSet from a BinaryParser\n   *\n   * @param parser A BinaryParser to read PathSet from\n   * @returns the PathSet read from parser\n   */\n  static fromParser(parser: BinaryParser): PathSet {\n    const bytes: Array<Uint8Array> = []\n\n    while (!parser.end()) {\n      bytes.push(Path.fromParser(parser).toBytes())\n      bytes.push(parser.read(1))\n\n      if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {\n        break\n      }\n    }\n\n    return new PathSet(concat(bytes))\n  }\n\n  /**\n   * Get the JSON representation of this PathSet\n   *\n   * @returns an Array of Array of HopObjects, representing this PathSet\n   */\n  toJSON(): Array<Array<HopObject>> {\n    const json: Array<Array<HopObject>> = []\n    const pathParser = new BinaryParser(this.toString())\n\n    while (!pathParser.end()) {\n      json.push(Path.fromParser(pathParser).toJSON())\n      pathParser.skip(1)\n    }\n\n    return json\n  }\n}\n\nexport { PathSet }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}