{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.stringToHex = exports.hexToString = exports.hexToBytes = exports.bytesToHex = void 0;\nconst utils_1 = require(\"@noble/hashes/utils\");\n/* eslint-disable func-style -- Typed to ensure uniformity between node and browser implementations and docs */\nconst bytesToHex = bytes => {\n  const hex = (0, utils_1.bytesToHex)(bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes));\n  return hex.toUpperCase();\n};\nexports.bytesToHex = bytesToHex;\n// A clone of hexToBytes from @noble/hashes without the length checks. This allows us to do our own checks.\nconst hexToBytes = hex => {\n  const len = hex.length;\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) {\n      throw new Error('Invalid byte sequence');\n    }\n    array[i] = byte;\n  }\n  return array;\n};\nexports.hexToBytes = hexToBytes;\nconst hexToString = (hex, encoding = 'utf8') => {\n  return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));\n};\nexports.hexToString = hexToString;\nconst stringToHex = string => {\n  return (0, exports.bytesToHex)(new TextEncoder().encode(string));\n};\nexports.stringToHex = stringToHex;\n/* eslint-enable func-style */\nexports.randomBytes = utils_1.randomBytes;\n__exportStar(require(\"./shared\"), exports);","map":{"version":3,"names":["utils_1","require","bytesToHex","bytes","hex","Uint8Array","from","toUpperCase","exports","hexToBytes","len","length","array","i","j","hexByte","slice","byte","Number","parseInt","isNaN","Error","hexToString","encoding","TextDecoder","decode","stringToHex","string","TextEncoder","encode","randomBytes","__exportStar"],"sources":["/Users/mdabdurrazzak/node_modules/@xrplf/isomorphic/src/utils/browser.ts"],"sourcesContent":["import {\n  bytesToHex as nobleBytesToHex,\n  randomBytes as nobleRandomBytes,\n} from '@noble/hashes/utils'\nimport type {\n  BytesToHexFn,\n  HexToBytesFn,\n  HexToStringFn,\n  RandomBytesFn,\n  StringToHexFn,\n} from './types'\n\n/* eslint-disable func-style -- Typed to ensure uniformity between node and browser implementations and docs */\nexport const bytesToHex: typeof BytesToHexFn = (bytes) => {\n  const hex = nobleBytesToHex(\n    bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes),\n  )\n  return hex.toUpperCase()\n}\n\n// A clone of hexToBytes from @noble/hashes without the length checks. This allows us to do our own checks.\nexport const hexToBytes: typeof HexToBytesFn = (hex): Uint8Array => {\n  const len = hex.length\n  const array = new Uint8Array(len / 2)\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2\n    const hexByte = hex.slice(j, j + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0) {\n      throw new Error('Invalid byte sequence')\n    }\n    array[i] = byte\n  }\n  return array\n}\n\nexport const hexToString: typeof HexToStringFn = (\n  hex: string,\n  encoding = 'utf8',\n): string => {\n  return new TextDecoder(encoding).decode(hexToBytes(hex))\n}\n\nexport const stringToHex: typeof StringToHexFn = (string: string): string => {\n  return bytesToHex(new TextEncoder().encode(string))\n}\n/* eslint-enable func-style */\n\nexport const randomBytes: typeof RandomBytesFn = nobleRandomBytes\nexport * from './shared'\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AAYA;AACO,MAAMC,UAAU,GAAyBC,KAAK,IAAI;EACvD,MAAMC,GAAG,GAAG,IAAAJ,OAAA,CAAAE,UAAe,EACzBC,KAAK,YAAYE,UAAU,GAAGF,KAAK,GAAGE,UAAU,CAACC,IAAI,CAACH,KAAK,CAAC,CAC7D;EACD,OAAOC,GAAG,CAACG,WAAW,EAAE;AAC1B,CAAC;AALYC,OAAA,CAAAN,UAAU,GAAAA,UAAA;AAOvB;AACO,MAAMO,UAAU,GAAyBL,GAAG,IAAgB;EACjE,MAAMM,GAAG,GAAGN,GAAG,CAACO,MAAM;EACtB,MAAMC,KAAK,GAAG,IAAIP,UAAU,CAACK,GAAG,GAAG,CAAC,CAAC;EACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACD,MAAM,EAAEE,CAAC,EAAE,EAAE;IACrC,MAAMC,CAAC,GAAGD,CAAC,GAAG,CAAC;IACf,MAAME,OAAO,GAAGX,GAAG,CAACY,KAAK,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IACnC,MAAMG,IAAI,GAAGC,MAAM,CAACC,QAAQ,CAACJ,OAAO,EAAE,EAAE,CAAC;IACzC,IAAIG,MAAM,CAACE,KAAK,CAACH,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EAAE;MAClC,MAAM,IAAII,KAAK,CAAC,uBAAuB,CAAC;;IAE1CT,KAAK,CAACC,CAAC,CAAC,GAAGI,IAAI;;EAEjB,OAAOL,KAAK;AACd,CAAC;AAbYJ,OAAA,CAAAC,UAAU,GAAAA,UAAA;AAehB,MAAMa,WAAW,GAAyBA,CAC/ClB,GAAW,EACXmB,QAAQ,GAAG,MAAM,KACP;EACV,OAAO,IAAIC,WAAW,CAACD,QAAQ,CAAC,CAACE,MAAM,CAAC,IAAAjB,OAAA,CAAAC,UAAU,EAACL,GAAG,CAAC,CAAC;AAC1D,CAAC;AALYI,OAAA,CAAAc,WAAW,GAAAA,WAAA;AAOjB,MAAMI,WAAW,GAA0BC,MAAc,IAAY;EAC1E,OAAO,IAAAnB,OAAA,CAAAN,UAAU,EAAC,IAAI0B,WAAW,EAAE,CAACC,MAAM,CAACF,MAAM,CAAC,CAAC;AACrD,CAAC;AAFYnB,OAAA,CAAAkB,WAAW,GAAAA,WAAA;AAGxB;AAEalB,OAAA,CAAAsB,WAAW,GAAyB9B,OAAA,CAAA8B,WAAgB;AACjEC,YAAA,CAAA9B,OAAA,cAAAO,OAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}