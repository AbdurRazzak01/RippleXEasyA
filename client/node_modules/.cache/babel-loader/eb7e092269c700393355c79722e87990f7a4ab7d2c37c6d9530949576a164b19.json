{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;\nconst shamap_1 = require(\"./shamap\");\nconst hash_prefixes_1 = require(\"./hash-prefixes\");\nconst hashes_1 = require(\"./hashes\");\nconst binary_1 = require(\"./binary\");\nconst hash_256_1 = require(\"./types/hash-256\");\nconst st_object_1 = require(\"./types/st-object\");\nconst uint_64_1 = require(\"./types/uint-64\");\nconst uint_32_1 = require(\"./types/uint-32\");\nconst uint_8_1 = require(\"./types/uint-8\");\nconst binary_parser_1 = require(\"./serdes/binary-parser\");\n/**\n * Computes the hash of a list of objects\n *\n * @param itemizer Converts an item into a format that can be added to SHAMap\n * @param itemsJson Array of items to add to a SHAMap\n * @returns the hash of the SHAMap\n */\nfunction computeHash(itemizer, itemsJson) {\n  const map = new shamap_1.ShaMap();\n  itemsJson.forEach(item => map.addItem(...itemizer(item)));\n  return map.hash();\n}\n/**\n * Convert a transaction into an index and an item\n *\n * @param json transaction with metadata\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction transactionItemizer(json) {\n  if (!json.hash) {\n    throw new Error();\n  }\n  const index = hash_256_1.Hash256.from(json.hash);\n  const item = {\n    hashPrefix() {\n      return hash_prefixes_1.HashPrefix.transaction;\n    },\n    toBytesSink(sink) {\n      const serializer = new binary_1.BinarySerializer(sink);\n      serializer.writeLengthEncoded(st_object_1.STObject.from(json));\n      serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));\n    }\n  };\n  return [index, item, undefined];\n}\n/**\n * Convert an entry to a pair Hash256 and ShaMapNode\n *\n * @param json JSON describing a ledger entry item\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction entryItemizer(json) {\n  const index = hash_256_1.Hash256.from(json.index);\n  const bytes = (0, binary_1.serializeObject)(json);\n  const item = {\n    hashPrefix() {\n      return hash_prefixes_1.HashPrefix.accountStateEntry;\n    },\n    toBytesSink(sink) {\n      sink.put(bytes);\n    }\n  };\n  return [index, item, undefined];\n}\n/**\n * Function computing the hash of a transaction tree\n *\n * @param param An array of transaction objects to hash\n * @returns A Hash256 object\n */\nfunction transactionTreeHash(param) {\n  const itemizer = transactionItemizer;\n  return computeHash(itemizer, param);\n}\nexports.transactionTreeHash = transactionTreeHash;\n/**\n * Function computing the hash of accountState\n *\n * @param param A list of accountStates hash\n * @returns A Hash256 object\n */\nfunction accountStateHash(param) {\n  const itemizer = entryItemizer;\n  return computeHash(itemizer, param);\n}\nexports.accountStateHash = accountStateHash;\n/**\n * Serialize and hash a ledger header\n *\n * @param header a ledger header\n * @returns the hash of header\n */\nfunction ledgerHash(header) {\n  const hash = new hashes_1.Sha512Half();\n  hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);\n  if (header.parent_close_time === undefined || header.close_flags === undefined) {\n    throw new Error();\n  }\n  uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);\n  uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash);\n  hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);\n  hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);\n  hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);\n  uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);\n  uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);\n  uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);\n  uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);\n  return hash.finish();\n}\nexports.ledgerHash = ledgerHash;\n/**\n * Decodes a serialized ledger header\n *\n * @param binary A serialized ledger header\n * @param definitions Type definitions to parse the ledger objects.\n *      Used if there are non-default ledger objects to decode.\n * @returns A JSON object describing a ledger header\n */\nfunction decodeLedgerData(binary, definitions) {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string');\n  }\n  const parser = new binary_parser_1.BinaryParser(binary, definitions);\n  return {\n    ledger_index: parser.readUInt32(),\n    total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),\n    parent_hash: parser.readType(hash_256_1.Hash256).toHex(),\n    transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),\n    account_hash: parser.readType(hash_256_1.Hash256).toHex(),\n    parent_close_time: parser.readUInt32(),\n    close_time: parser.readUInt32(),\n    close_time_resolution: parser.readUInt8(),\n    close_flags: parser.readUInt8()\n  };\n}\nexports.decodeLedgerData = decodeLedgerData;","map":{"version":3,"names":["shamap_1","require","hash_prefixes_1","hashes_1","binary_1","hash_256_1","st_object_1","uint_64_1","uint_32_1","uint_8_1","binary_parser_1","computeHash","itemizer","itemsJson","map","ShaMap","forEach","item","addItem","hash","transactionItemizer","json","Error","index","Hash256","from","hashPrefix","HashPrefix","transaction","toBytesSink","sink","serializer","BinarySerializer","writeLengthEncoded","STObject","metaData","undefined","entryItemizer","bytes","serializeObject","accountStateEntry","put","transactionTreeHash","param","exports","accountStateHash","ledgerHash","header","Sha512Half","ledgerHeader","parent_close_time","close_flags","UInt32","ledger_index","UInt64","BigInt","String","total_coins","parent_hash","transaction_hash","account_hash","close_time","UInt8","close_time_resolution","finish","decodeLedgerData","binary","definitions","parser","BinaryParser","readUInt32","readType","valueOf","toString","toHex","readUInt8"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/ledger-hashes.ts"],"sourcesContent":["import { ShaMap, ShaMapNode, ShaMapLeaf } from './shamap'\nimport { HashPrefix } from './hash-prefixes'\nimport { Sha512Half } from './hashes'\nimport { BinarySerializer, serializeObject } from './binary'\nimport { Hash256 } from './types/hash-256'\nimport { STObject } from './types/st-object'\nimport { UInt64 } from './types/uint-64'\nimport { UInt32 } from './types/uint-32'\nimport { UInt8 } from './types/uint-8'\nimport { BinaryParser } from './serdes/binary-parser'\nimport { JsonObject } from './types/serialized-type'\nimport { XrplDefinitionsBase } from './enums'\n\n/**\n * Computes the hash of a list of objects\n *\n * @param itemizer Converts an item into a format that can be added to SHAMap\n * @param itemsJson Array of items to add to a SHAMap\n * @returns the hash of the SHAMap\n */\nfunction computeHash(\n  itemizer: (item: JsonObject) => [Hash256?, ShaMapNode?, ShaMapLeaf?],\n  itemsJson: Array<JsonObject>,\n): Hash256 {\n  const map = new ShaMap()\n  itemsJson.forEach((item) => map.addItem(...itemizer(item)))\n  return map.hash()\n}\n\n/**\n * Interface describing a transaction item\n */\ninterface transactionItemObject extends JsonObject {\n  hash: string\n  metaData: JsonObject\n}\n\n/**\n * Convert a transaction into an index and an item\n *\n * @param json transaction with metadata\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction transactionItemizer(\n  json: transactionItemObject,\n): [Hash256, ShaMapNode, undefined] {\n  if (!json.hash) {\n    throw new Error()\n  }\n  const index = Hash256.from(json.hash)\n  const item = {\n    hashPrefix() {\n      return HashPrefix.transaction\n    },\n    toBytesSink(sink) {\n      const serializer = new BinarySerializer(sink)\n      serializer.writeLengthEncoded(STObject.from(json))\n      serializer.writeLengthEncoded(STObject.from(json.metaData))\n    },\n  } as ShaMapNode\n  return [index, item, undefined]\n}\n\n/**\n * Interface describing an entry item\n */\ninterface entryItemObject extends JsonObject {\n  index: string\n}\n\n/**\n * Convert an entry to a pair Hash256 and ShaMapNode\n *\n * @param json JSON describing a ledger entry item\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction entryItemizer(\n  json: entryItemObject,\n): [Hash256, ShaMapNode, undefined] {\n  const index = Hash256.from(json.index)\n  const bytes = serializeObject(json)\n  const item = {\n    hashPrefix() {\n      return HashPrefix.accountStateEntry\n    },\n    toBytesSink(sink) {\n      sink.put(bytes)\n    },\n  } as ShaMapNode\n  return [index, item, undefined]\n}\n\n/**\n * Function computing the hash of a transaction tree\n *\n * @param param An array of transaction objects to hash\n * @returns A Hash256 object\n */\nfunction transactionTreeHash(param: Array<JsonObject>): Hash256 {\n  const itemizer = transactionItemizer as (\n    json: JsonObject,\n  ) => [Hash256, ShaMapNode, undefined]\n  return computeHash(itemizer, param)\n}\n\n/**\n * Function computing the hash of accountState\n *\n * @param param A list of accountStates hash\n * @returns A Hash256 object\n */\nfunction accountStateHash(param: Array<JsonObject>): Hash256 {\n  const itemizer = entryItemizer as (\n    json: JsonObject,\n  ) => [Hash256, ShaMapNode, undefined]\n  return computeHash(itemizer, param)\n}\n\n/**\n * Interface describing a ledger header\n */\ninterface ledgerObject {\n  ledger_index: number\n  total_coins: string | number | bigint\n  parent_hash: string\n  transaction_hash: string\n  account_hash: string\n  parent_close_time: number\n  close_time: number\n  close_time_resolution: number\n  close_flags: number\n}\n\n/**\n * Serialize and hash a ledger header\n *\n * @param header a ledger header\n * @returns the hash of header\n */\nfunction ledgerHash(header: ledgerObject): Hash256 {\n  const hash = new Sha512Half()\n  hash.put(HashPrefix.ledgerHeader)\n  if (\n    header.parent_close_time === undefined ||\n    header.close_flags === undefined\n  ) {\n    throw new Error()\n  }\n\n  UInt32.from<number>(header.ledger_index).toBytesSink(hash)\n  UInt64.from<bigint>(BigInt(String(header.total_coins))).toBytesSink(hash)\n  Hash256.from<string>(header.parent_hash).toBytesSink(hash)\n  Hash256.from<string>(header.transaction_hash).toBytesSink(hash)\n  Hash256.from<string>(header.account_hash).toBytesSink(hash)\n  UInt32.from<number>(header.parent_close_time).toBytesSink(hash)\n  UInt32.from<number>(header.close_time).toBytesSink(hash)\n  UInt8.from<number>(header.close_time_resolution).toBytesSink(hash)\n  UInt8.from<number>(header.close_flags).toBytesSink(hash)\n  return hash.finish()\n}\n\n/**\n * Decodes a serialized ledger header\n *\n * @param binary A serialized ledger header\n * @param definitions Type definitions to parse the ledger objects.\n *      Used if there are non-default ledger objects to decode.\n * @returns A JSON object describing a ledger header\n */\nfunction decodeLedgerData(\n  binary: string,\n  definitions?: XrplDefinitionsBase,\n): object {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string')\n  }\n  const parser = new BinaryParser(binary, definitions)\n  return {\n    ledger_index: parser.readUInt32(),\n    total_coins: parser.readType(UInt64).valueOf().toString(),\n    parent_hash: parser.readType(Hash256).toHex(),\n    transaction_hash: parser.readType(Hash256).toHex(),\n    account_hash: parser.readType(Hash256).toHex(),\n    parent_close_time: parser.readUInt32(),\n    close_time: parser.readUInt32(),\n    close_time_resolution: parser.readUInt8(),\n    close_flags: parser.readUInt8(),\n  }\n}\n\nexport { accountStateHash, transactionTreeHash, ledgerHash, decodeLedgerData }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}