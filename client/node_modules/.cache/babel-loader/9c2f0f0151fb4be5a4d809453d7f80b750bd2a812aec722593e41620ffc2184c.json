{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STArray = void 0;\nconst enums_1 = require(\"../enums\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst st_object_1 = require(\"./st-object\");\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst ARRAY_END_MARKER = Uint8Array.from([0xf1]);\nconst ARRAY_END_MARKER_NAME = 'ArrayEndMarker';\nconst OBJECT_END_MARKER = Uint8Array.from([0xe1]);\n/**\n * TypeGuard for Array<JsonObject>\n */\nfunction isObjects(args) {\n  return Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object');\n}\n/**\n * Class for serializing and deserializing Arrays of Objects\n */\nclass STArray extends serialized_type_1.SerializedType {\n  /**\n   * Construct an STArray from a BinaryParser\n   *\n   * @param parser BinaryParser to parse an STArray from\n   * @returns An STArray Object\n   */\n  static fromParser(parser) {\n    const bytes = [];\n    while (!parser.end()) {\n      const field = parser.readField();\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break;\n      }\n      bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);\n    }\n    bytes.push(ARRAY_END_MARKER);\n    return new STArray((0, utils_1.concat)(bytes));\n  }\n  /**\n   * Construct an STArray from an Array of JSON Objects\n   *\n   * @param value STArray or Array of Objects to parse into an STArray\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns An STArray object\n   */\n  static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {\n    if (value instanceof STArray) {\n      return value;\n    }\n    if (isObjects(value)) {\n      const bytes = [];\n      value.forEach(obj => {\n        bytes.push(st_object_1.STObject.from(obj, undefined, definitions).toBytes());\n      });\n      bytes.push(ARRAY_END_MARKER);\n      return new STArray((0, utils_1.concat)(bytes));\n    }\n    throw new Error('Cannot construct STArray from value given');\n  }\n  /**\n   * Return the JSON representation of this.bytes\n   *\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns An Array of JSON objects\n   */\n  toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {\n    const result = [];\n    const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);\n    while (!arrayParser.end()) {\n      const field = arrayParser.readField();\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break;\n      }\n      const outer = {};\n      outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);\n      result.push(outer);\n    }\n    return result;\n  }\n}\nexports.STArray = STArray;","map":{"version":3,"names":["enums_1","require","serialized_type_1","st_object_1","binary_parser_1","utils_1","ARRAY_END_MARKER","Uint8Array","from","ARRAY_END_MARKER_NAME","OBJECT_END_MARKER","isObjects","args","Array","isArray","length","STArray","SerializedType","fromParser","parser","bytes","end","field","readField","name","push","header","readFieldValue","toBytes","concat","value","definitions","DEFAULT_DEFINITIONS","forEach","obj","STObject","undefined","Error","toJSON","result","arrayParser","BinaryParser","toString","outer","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/types/st-array.ts"],"sourcesContent":["import { DEFAULT_DEFINITIONS, XrplDefinitionsBase } from '../enums'\nimport { SerializedType, JsonObject } from './serialized-type'\nimport { STObject } from './st-object'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { concat } from '@xrplf/isomorphic/utils'\n\nconst ARRAY_END_MARKER = Uint8Array.from([0xf1])\nconst ARRAY_END_MARKER_NAME = 'ArrayEndMarker'\n\nconst OBJECT_END_MARKER = Uint8Array.from([0xe1])\n\n/**\n * TypeGuard for Array<JsonObject>\n */\nfunction isObjects(args): args is Array<JsonObject> {\n  return (\n    Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object')\n  )\n}\n\n/**\n * Class for serializing and deserializing Arrays of Objects\n */\nclass STArray extends SerializedType {\n  /**\n   * Construct an STArray from a BinaryParser\n   *\n   * @param parser BinaryParser to parse an STArray from\n   * @returns An STArray Object\n   */\n  static fromParser(parser: BinaryParser): STArray {\n    const bytes: Array<Uint8Array> = []\n\n    while (!parser.end()) {\n      const field = parser.readField()\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break\n      }\n\n      bytes.push(\n        field.header,\n        parser.readFieldValue(field).toBytes(),\n        OBJECT_END_MARKER,\n      )\n    }\n\n    bytes.push(ARRAY_END_MARKER)\n    return new STArray(concat(bytes))\n  }\n\n  /**\n   * Construct an STArray from an Array of JSON Objects\n   *\n   * @param value STArray or Array of Objects to parse into an STArray\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns An STArray object\n   */\n  static from<T extends STArray | Array<JsonObject>>(\n    value: T,\n    definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n  ): STArray {\n    if (value instanceof STArray) {\n      return value\n    }\n\n    if (isObjects(value)) {\n      const bytes: Array<Uint8Array> = []\n      value.forEach((obj) => {\n        bytes.push(STObject.from(obj, undefined, definitions).toBytes())\n      })\n\n      bytes.push(ARRAY_END_MARKER)\n      return new STArray(concat(bytes))\n    }\n\n    throw new Error('Cannot construct STArray from value given')\n  }\n\n  /**\n   * Return the JSON representation of this.bytes\n   *\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns An Array of JSON objects\n   */\n  toJSON(\n    definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n  ): Array<JsonObject> {\n    const result: Array<JsonObject> = []\n\n    const arrayParser = new BinaryParser(this.toString(), definitions)\n\n    while (!arrayParser.end()) {\n      const field = arrayParser.readField()\n      if (field.name === ARRAY_END_MARKER_NAME) {\n        break\n      }\n\n      const outer = {}\n      outer[field.name] = STObject.fromParser(arrayParser).toJSON(definitions)\n      result.push(outer)\n    }\n\n    return result\n  }\n}\n\nexport { STArray }\n"],"mappings":";;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,eAAA,GAAAH,OAAA;AACA,MAAAI,OAAA,GAAAJ,OAAA;AAEA,MAAMK,gBAAgB,GAAGC,UAAU,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAChD,MAAMC,qBAAqB,GAAG,gBAAgB;AAE9C,MAAMC,iBAAiB,GAAGH,UAAU,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAEjD;;;AAGA,SAASG,SAASA,CAACC,IAAI;EACrB,OACEC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,KAAKA,IAAI,CAACG,MAAM,KAAK,CAAC,IAAI,OAAOH,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC;AAE7E;AAEA;;;AAGA,MAAMI,OAAQ,SAAQd,iBAAA,CAAAe,cAAc;EAClC;;;;;;EAMA,OAAOC,UAAUA,CAACC,MAAoB;IACpC,MAAMC,KAAK,GAAsB,EAAE;IAEnC,OAAO,CAACD,MAAM,CAACE,GAAG,EAAE,EAAE;MACpB,MAAMC,KAAK,GAAGH,MAAM,CAACI,SAAS,EAAE;MAChC,IAAID,KAAK,CAACE,IAAI,KAAKf,qBAAqB,EAAE;QACxC;;MAGFW,KAAK,CAACK,IAAI,CACRH,KAAK,CAACI,MAAM,EACZP,MAAM,CAACQ,cAAc,CAACL,KAAK,CAAC,CAACM,OAAO,EAAE,EACtClB,iBAAiB,CAClB;;IAGHU,KAAK,CAACK,IAAI,CAACnB,gBAAgB,CAAC;IAC5B,OAAO,IAAIU,OAAO,CAAC,IAAAX,OAAA,CAAAwB,MAAM,EAACT,KAAK,CAAC,CAAC;EACnC;EAEA;;;;;;;EAOA,OAAOZ,IAAIA,CACTsB,KAAQ,EACRC,WAAA,GAAmC/B,OAAA,CAAAgC,mBAAmB;IAEtD,IAAIF,KAAK,YAAYd,OAAO,EAAE;MAC5B,OAAOc,KAAK;;IAGd,IAAInB,SAAS,CAACmB,KAAK,CAAC,EAAE;MACpB,MAAMV,KAAK,GAAsB,EAAE;MACnCU,KAAK,CAACG,OAAO,CAAEC,GAAG,IAAI;QACpBd,KAAK,CAACK,IAAI,CAACtB,WAAA,CAAAgC,QAAQ,CAAC3B,IAAI,CAAC0B,GAAG,EAAEE,SAAS,EAAEL,WAAW,CAAC,CAACH,OAAO,EAAE,CAAC;MAClE,CAAC,CAAC;MAEFR,KAAK,CAACK,IAAI,CAACnB,gBAAgB,CAAC;MAC5B,OAAO,IAAIU,OAAO,CAAC,IAAAX,OAAA,CAAAwB,MAAM,EAACT,KAAK,CAAC,CAAC;;IAGnC,MAAM,IAAIiB,KAAK,CAAC,2CAA2C,CAAC;EAC9D;EAEA;;;;;;EAMAC,MAAMA,CACJP,WAAA,GAAmC/B,OAAA,CAAAgC,mBAAmB;IAEtD,MAAMO,MAAM,GAAsB,EAAE;IAEpC,MAAMC,WAAW,GAAG,IAAIpC,eAAA,CAAAqC,YAAY,CAAC,IAAI,CAACC,QAAQ,EAAE,EAAEX,WAAW,CAAC;IAElE,OAAO,CAACS,WAAW,CAACnB,GAAG,EAAE,EAAE;MACzB,MAAMC,KAAK,GAAGkB,WAAW,CAACjB,SAAS,EAAE;MACrC,IAAID,KAAK,CAACE,IAAI,KAAKf,qBAAqB,EAAE;QACxC;;MAGF,MAAMkC,KAAK,GAAG,EAAE;MAChBA,KAAK,CAACrB,KAAK,CAACE,IAAI,CAAC,GAAGrB,WAAA,CAAAgC,QAAQ,CAACjB,UAAU,CAACsB,WAAW,CAAC,CAACF,MAAM,CAACP,WAAW,CAAC;MACxEQ,MAAM,CAACd,IAAI,CAACkB,KAAK,CAAC;;IAGpB,OAAOJ,MAAM;EACf;;AAGOK,OAAA,CAAA5B,OAAA,GAAAA,OAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}