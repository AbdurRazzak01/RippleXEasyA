{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Currency = void 0;\nconst hash_160_1 = require(\"./hash-160\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst XRP_HEX_REGEX = /^0{40}$/;\nconst ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\\]|]{3}$/;\nconst HEX_REGEX = /^[A-F0-9]{40}$/;\n// eslint-disable-next-line no-control-regex\nconst STANDARD_FORMAT_HEX_REGEX = /^0{24}[\\x00-\\x7F]{6}0{10}$/;\n/**\n * Convert an ISO code to a currency bytes representation\n */\nfunction isoToBytes(iso) {\n  const bytes = new Uint8Array(20);\n  if (iso !== 'XRP') {\n    const isoBytes = iso.split('').map(c => c.charCodeAt(0));\n    bytes.set(isoBytes, 12);\n  }\n  return bytes;\n}\n/**\n * Tests if ISO is a valid iso code\n */\nfunction isIsoCode(iso) {\n  return ISO_REGEX.test(iso);\n}\nfunction isoCodeFromHex(code) {\n  const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));\n  if (iso === 'XRP') {\n    return null;\n  }\n  if (isIsoCode(iso)) {\n    return iso;\n  }\n  return null;\n}\n/**\n * Tests if hex is a valid hex-string\n */\nfunction isHex(hex) {\n  return HEX_REGEX.test(hex);\n}\n/**\n * Tests if a string is a valid representation of a currency\n */\nfunction isStringRepresentation(input) {\n  return input.length === 3 || isHex(input);\n}\n/**\n * Tests if a Uint8Array is a valid representation of a currency\n */\nfunction isBytesArray(bytes) {\n  return bytes.byteLength === 20;\n}\n/**\n * Ensures that a value is a valid representation of a currency\n */\nfunction isValidRepresentation(input) {\n  return input instanceof Uint8Array ? isBytesArray(input) : isStringRepresentation(input);\n}\n/**\n * Generate bytes from a string or UInt8Array representation of a currency\n */\nfunction bytesFromRepresentation(input) {\n  if (!isValidRepresentation(input)) {\n    throw new Error(`Unsupported Currency representation: ${input}`);\n  }\n  return input.length === 3 ? isoToBytes(input) : (0, utils_1.hexToBytes)(input);\n}\n/**\n * Class defining how to encode and decode Currencies\n */\nclass Currency extends hash_160_1.Hash160 {\n  constructor(byteBuf) {\n    super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XRP.bytes);\n    const hex = (0, utils_1.bytesToHex)(this.bytes);\n    if (XRP_HEX_REGEX.test(hex)) {\n      this._iso = 'XRP';\n    } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {\n      this._iso = isoCodeFromHex(this.bytes.slice(12, 15));\n    } else {\n      this._iso = null;\n    }\n  }\n  /**\n   * Return the ISO code of this currency\n   *\n   * @returns ISO code if it exists, else null\n   */\n  iso() {\n    return this._iso;\n  }\n  /**\n   * Constructs a Currency object\n   *\n   * @param val Currency object or a string representation of a currency\n   */\n  static from(value) {\n    if (value instanceof Currency) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      return new Currency(bytesFromRepresentation(value));\n    }\n    throw new Error('Cannot construct Currency from value given');\n  }\n  /**\n   * Gets the JSON representation of a currency\n   *\n   * @returns JSON representation\n   */\n  toJSON() {\n    const iso = this.iso();\n    if (iso !== null) {\n      return iso;\n    }\n    return (0, utils_1.bytesToHex)(this.bytes);\n  }\n}\nexports.Currency = Currency;\nCurrency.XRP = new Currency(new Uint8Array(20));","map":{"version":3,"names":["hash_160_1","require","utils_1","XRP_HEX_REGEX","ISO_REGEX","HEX_REGEX","STANDARD_FORMAT_HEX_REGEX","isoToBytes","iso","bytes","Uint8Array","isoBytes","split","map","c","charCodeAt","set","isIsoCode","test","isoCodeFromHex","code","hexToString","bytesToHex","isHex","hex","isStringRepresentation","input","length","isBytesArray","byteLength","isValidRepresentation","bytesFromRepresentation","Error","hexToBytes","Currency","Hash160","constructor","byteBuf","XRP","_iso","slice","from","value","toJSON","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/types/currency.ts"],"sourcesContent":["import { Hash160 } from './hash-160'\nimport { bytesToHex, hexToBytes, hexToString } from '@xrplf/isomorphic/utils'\n\nconst XRP_HEX_REGEX = /^0{40}$/\nconst ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\\]|]{3}$/\nconst HEX_REGEX = /^[A-F0-9]{40}$/\n// eslint-disable-next-line no-control-regex\nconst STANDARD_FORMAT_HEX_REGEX = /^0{24}[\\x00-\\x7F]{6}0{10}$/\n\n/**\n * Convert an ISO code to a currency bytes representation\n */\nfunction isoToBytes(iso: string): Uint8Array {\n  const bytes = new Uint8Array(20)\n  if (iso !== 'XRP') {\n    const isoBytes = iso.split('').map((c) => c.charCodeAt(0))\n    bytes.set(isoBytes, 12)\n  }\n  return bytes\n}\n\n/**\n * Tests if ISO is a valid iso code\n */\nfunction isIsoCode(iso: string): boolean {\n  return ISO_REGEX.test(iso)\n}\n\nfunction isoCodeFromHex(code: Uint8Array): string | null {\n  const iso = hexToString(bytesToHex(code))\n  if (iso === 'XRP') {\n    return null\n  }\n  if (isIsoCode(iso)) {\n    return iso\n  }\n  return null\n}\n\n/**\n * Tests if hex is a valid hex-string\n */\nfunction isHex(hex: string): boolean {\n  return HEX_REGEX.test(hex)\n}\n\n/**\n * Tests if a string is a valid representation of a currency\n */\nfunction isStringRepresentation(input: string): boolean {\n  return input.length === 3 || isHex(input)\n}\n\n/**\n * Tests if a Uint8Array is a valid representation of a currency\n */\nfunction isBytesArray(bytes: Uint8Array): boolean {\n  return bytes.byteLength === 20\n}\n\n/**\n * Ensures that a value is a valid representation of a currency\n */\nfunction isValidRepresentation(input: Uint8Array | string): boolean {\n  return input instanceof Uint8Array\n    ? isBytesArray(input)\n    : isStringRepresentation(input)\n}\n\n/**\n * Generate bytes from a string or UInt8Array representation of a currency\n */\nfunction bytesFromRepresentation(input: string): Uint8Array {\n  if (!isValidRepresentation(input)) {\n    throw new Error(`Unsupported Currency representation: ${input}`)\n  }\n  return input.length === 3 ? isoToBytes(input) : hexToBytes(input)\n}\n\n/**\n * Class defining how to encode and decode Currencies\n */\nclass Currency extends Hash160 {\n  static readonly XRP = new Currency(new Uint8Array(20))\n  private readonly _iso: string | null\n\n  constructor(byteBuf: Uint8Array) {\n    super(byteBuf ?? Currency.XRP.bytes)\n    const hex = bytesToHex(this.bytes)\n\n    if (XRP_HEX_REGEX.test(hex)) {\n      this._iso = 'XRP'\n    } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {\n      this._iso = isoCodeFromHex(this.bytes.slice(12, 15))\n    } else {\n      this._iso = null\n    }\n  }\n\n  /**\n   * Return the ISO code of this currency\n   *\n   * @returns ISO code if it exists, else null\n   */\n  iso(): string | null {\n    return this._iso\n  }\n\n  /**\n   * Constructs a Currency object\n   *\n   * @param val Currency object or a string representation of a currency\n   */\n  static from<T extends Hash160 | string>(value: T): Currency {\n    if (value instanceof Currency) {\n      return value\n    }\n\n    if (typeof value === 'string') {\n      return new Currency(bytesFromRepresentation(value))\n    }\n\n    throw new Error('Cannot construct Currency from value given')\n  }\n\n  /**\n   * Gets the JSON representation of a currency\n   *\n   * @returns JSON representation\n   */\n  toJSON(): string {\n    const iso = this.iso()\n    if (iso !== null) {\n      return iso\n    }\n    return bytesToHex(this.bytes)\n  }\n}\n\nexport { Currency }\n"],"mappings":";;;;;;AAAA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AAEA,MAAME,aAAa,GAAG,SAAS;AAC/B,MAAMC,SAAS,GAAG,mCAAmC;AACrD,MAAMC,SAAS,GAAG,gBAAgB;AAClC;AACA,MAAMC,yBAAyB,GAAG,4BAA4B;AAE9D;;;AAGA,SAASC,UAAUA,CAACC,GAAW;EAC7B,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;EAChC,IAAIF,GAAG,KAAK,KAAK,EAAE;IACjB,MAAMG,QAAQ,GAAGH,GAAG,CAACI,KAAK,CAAC,EAAE,CAAC,CAACC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC1DN,KAAK,CAACO,GAAG,CAACL,QAAQ,EAAE,EAAE,CAAC;;EAEzB,OAAOF,KAAK;AACd;AAEA;;;AAGA,SAASQ,SAASA,CAACT,GAAW;EAC5B,OAAOJ,SAAS,CAACc,IAAI,CAACV,GAAG,CAAC;AAC5B;AAEA,SAASW,cAAcA,CAACC,IAAgB;EACtC,MAAMZ,GAAG,GAAG,IAAAN,OAAA,CAAAmB,WAAW,EAAC,IAAAnB,OAAA,CAAAoB,UAAU,EAACF,IAAI,CAAC,CAAC;EACzC,IAAIZ,GAAG,KAAK,KAAK,EAAE;IACjB,OAAO,IAAI;;EAEb,IAAIS,SAAS,CAACT,GAAG,CAAC,EAAE;IAClB,OAAOA,GAAG;;EAEZ,OAAO,IAAI;AACb;AAEA;;;AAGA,SAASe,KAAKA,CAACC,GAAW;EACxB,OAAOnB,SAAS,CAACa,IAAI,CAACM,GAAG,CAAC;AAC5B;AAEA;;;AAGA,SAASC,sBAAsBA,CAACC,KAAa;EAC3C,OAAOA,KAAK,CAACC,MAAM,KAAK,CAAC,IAAIJ,KAAK,CAACG,KAAK,CAAC;AAC3C;AAEA;;;AAGA,SAASE,YAAYA,CAACnB,KAAiB;EACrC,OAAOA,KAAK,CAACoB,UAAU,KAAK,EAAE;AAChC;AAEA;;;AAGA,SAASC,qBAAqBA,CAACJ,KAA0B;EACvD,OAAOA,KAAK,YAAYhB,UAAU,GAC9BkB,YAAY,CAACF,KAAK,CAAC,GACnBD,sBAAsB,CAACC,KAAK,CAAC;AACnC;AAEA;;;AAGA,SAASK,uBAAuBA,CAACL,KAAa;EAC5C,IAAI,CAACI,qBAAqB,CAACJ,KAAK,CAAC,EAAE;IACjC,MAAM,IAAIM,KAAK,CAAC,wCAAwCN,KAAK,EAAE,CAAC;;EAElE,OAAOA,KAAK,CAACC,MAAM,KAAK,CAAC,GAAGpB,UAAU,CAACmB,KAAK,CAAC,GAAG,IAAAxB,OAAA,CAAA+B,UAAU,EAACP,KAAK,CAAC;AACnE;AAEA;;;AAGA,MAAMQ,QAAS,SAAQlC,UAAA,CAAAmC,OAAO;EAI5BC,YAAYC,OAAmB;IAC7B,KAAK,CAACA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAIH,QAAQ,CAACI,GAAG,CAAC7B,KAAK,CAAC;IACpC,MAAMe,GAAG,GAAG,IAAAtB,OAAA,CAAAoB,UAAU,EAAC,IAAI,CAACb,KAAK,CAAC;IAElC,IAAIN,aAAa,CAACe,IAAI,CAACM,GAAG,CAAC,EAAE;MAC3B,IAAI,CAACe,IAAI,GAAG,KAAK;KAClB,MAAM,IAAIjC,yBAAyB,CAACY,IAAI,CAACM,GAAG,CAAC,EAAE;MAC9C,IAAI,CAACe,IAAI,GAAGpB,cAAc,CAAC,IAAI,CAACV,KAAK,CAAC+B,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;KACrD,MAAM;MACL,IAAI,CAACD,IAAI,GAAG,IAAI;;EAEpB;EAEA;;;;;EAKA/B,GAAGA,CAAA;IACD,OAAO,IAAI,CAAC+B,IAAI;EAClB;EAEA;;;;;EAKA,OAAOE,IAAIA,CAA6BC,KAAQ;IAC9C,IAAIA,KAAK,YAAYR,QAAQ,EAAE;MAC7B,OAAOQ,KAAK;;IAGd,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,OAAO,IAAIR,QAAQ,CAACH,uBAAuB,CAACW,KAAK,CAAC,CAAC;;IAGrD,MAAM,IAAIV,KAAK,CAAC,4CAA4C,CAAC;EAC/D;EAEA;;;;;EAKAW,MAAMA,CAAA;IACJ,MAAMnC,GAAG,GAAG,IAAI,CAACA,GAAG,EAAE;IACtB,IAAIA,GAAG,KAAK,IAAI,EAAE;MAChB,OAAOA,GAAG;;IAEZ,OAAO,IAAAN,OAAA,CAAAoB,UAAU,EAAC,IAAI,CAACb,KAAK,CAAC;EAC/B;;AAGOmC,OAAA,CAAAV,QAAA,GAAAA,QAAA;AAxDSA,QAAA,CAAAI,GAAG,GAAG,IAAIJ,QAAQ,CAAC,IAAIxB,UAAU,CAAC,EAAE,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}