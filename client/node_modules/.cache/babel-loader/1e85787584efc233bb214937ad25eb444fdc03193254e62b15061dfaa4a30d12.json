{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keyToRFC1751Mnemonic = exports.rfc1751MnemonicToKey = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst rfc1751Words_json_1 = __importDefault(require(\"./rfc1751Words.json\"));\nconst rfc1751WordList = rfc1751Words_json_1.default;\nconst BINARY = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];\nfunction keyToBinary(key) {\n  let res = '';\n  for (const num of key) {\n    res += BINARY[num >> 4] + BINARY[num & 0x0f];\n  }\n  return res;\n}\nfunction extract(key, start, length) {\n  const subKey = key.substring(start, start + length);\n  let acc = 0;\n  for (let index = 0; index < subKey.length; index++) {\n    acc = acc * 2 + subKey.charCodeAt(index) - 48;\n  }\n  return acc;\n}\nfunction keyToRFC1751Mnemonic(hex_key) {\n  const buf = (0, utils_1.hexToBytes)(hex_key.replace(/\\s+/gu, ''));\n  let key = bufferToArray(swap128(buf));\n  const padding = [];\n  for (let index = 0; index < (8 - key.length % 8) % 8; index++) {\n    padding.push(0);\n  }\n  key = padding.concat(key);\n  const english = [];\n  for (let index = 0; index < key.length; index += 8) {\n    const subKey = key.slice(index, index + 8);\n    let skbin = keyToBinary(subKey);\n    let parity = 0;\n    for (let j = 0; j < 64; j += 2) {\n      parity += extract(skbin, j, 2);\n    }\n    subKey.push(parity << 6 & 0xff);\n    skbin = keyToBinary(subKey);\n    for (let j = 0; j < 64; j += 11) {\n      english.push(rfc1751WordList[extract(skbin, j, 11)]);\n    }\n  }\n  return english.join(' ');\n}\nexports.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;\nfunction rfc1751MnemonicToKey(english) {\n  const words = english.split(' ');\n  let key = [];\n  for (let index = 0; index < words.length; index += 6) {\n    const {\n      subKey,\n      word\n    } = getSubKey(words, index);\n    const skbin = keyToBinary(subKey);\n    let parity = 0;\n    for (let j = 0; j < 64; j += 2) {\n      parity += extract(skbin, j, 2);\n    }\n    const cs0 = extract(skbin, 64, 2);\n    const cs1 = parity & 3;\n    if (cs0 !== cs1) {\n      throw new Error(`Parity error at ${word}`);\n    }\n    key = key.concat(subKey.slice(0, 8));\n  }\n  const bufferKey = swap128(Uint8Array.from(key));\n  return bufferKey;\n}\nexports.rfc1751MnemonicToKey = rfc1751MnemonicToKey;\nfunction getSubKey(words, index) {\n  const sublist = words.slice(index, index + 6);\n  let bits = 0;\n  const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let word = '';\n  for (word of sublist) {\n    const idx = rfc1751WordList.indexOf(word.toUpperCase());\n    if (idx === -1) {\n      throw new TypeError(`Expected an RFC1751 word, but received '${word}'. ` + `For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`);\n    }\n    const shift = (8 - (bits + 11) % 8) % 8;\n    const y = idx << shift;\n    const cl = y >> 16;\n    const cc = y >> 8 & 0xff;\n    const cr = y & 0xff;\n    const t = Math.floor(bits / 8);\n    if (shift > 5) {\n      ch[t] |= cl;\n      ch[t + 1] |= cc;\n      ch[t + 2] |= cr;\n    } else if (shift > -3) {\n      ch[t] |= cc;\n      ch[t + 1] |= cr;\n    } else {\n      ch[t] |= cr;\n    }\n    bits += 11;\n  }\n  const subKey = ch.slice();\n  return {\n    subKey,\n    word\n  };\n}\nfunction bufferToArray(buf) {\n  return Array.prototype.slice.call(buf);\n}\nfunction swap(arr, n, m) {\n  const i = arr[n];\n  arr[n] = arr[m];\n  arr[m] = i;\n}\nfunction swap64(arr) {\n  const len = arr.length;\n  for (let i = 0; i < len; i += 8) {\n    swap(arr, i, i + 7);\n    swap(arr, i + 1, i + 6);\n    swap(arr, i + 2, i + 5);\n    swap(arr, i + 3, i + 4);\n  }\n  return arr;\n}\nfunction swap128(arr) {\n  const reversedBytes = swap64(arr);\n  return (0, utils_1.concat)([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)]);\n}","map":{"version":3,"names":["utils_1","require","rfc1751Words_json_1","__importDefault","rfc1751WordList","default","BINARY","keyToBinary","key","res","num","extract","start","length","subKey","substring","acc","index","charCodeAt","keyToRFC1751Mnemonic","hex_key","buf","hexToBytes","replace","bufferToArray","swap128","padding","push","concat","english","slice","skbin","parity","j","join","exports","rfc1751MnemonicToKey","words","split","word","getSubKey","cs0","cs1","Error","bufferKey","Uint8Array","from","sublist","bits","ch","idx","indexOf","toUpperCase","TypeError","shift","y","cl","cc","cr","t","Math","floor","Array","prototype","call","swap","arr","n","m","i","swap64","len","reversedBytes"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/Wallet/rfc1751.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-magic-numbers -- Doing many bitwise operations which need specific numbers */\n/* eslint-disable no-bitwise -- Bitwise operators are required for this encoding/decoding */\n/* eslint-disable id-length -- Bitwise math uses shorthand terms */\n/*\n *rfc1751.ts : Converts between 128-bit strings and a human-readable\n *sequence of words, as defined in RFC1751: \"A Convention for\n *Human-Readable 128-bit Keys\", by Daniel L. McDonald.\n *Ported from rfc1751.py / Python Cryptography Toolkit (public domain).\n *Copied from https://github.com/bip32/bip32.github.io/blob/master/js/rfc1751.js which\n *is part of the public domain.\n */\n\nimport { hexToBytes, concat } from '@xrplf/isomorphic/utils'\n\nimport rfc1751Words from './rfc1751Words.json'\n\nconst rfc1751WordList: string[] = rfc1751Words\n\n// Added prettier-ignore to allow _BINARY to be on two lines, instead of one entry per line.\n\n// prettier-ignore\nconst BINARY = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',\n                '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];\n\n/**\n * Convert a number array into a binary string.\n *\n * @param key - An array of numbers in base 10.\n * @returns A binary string.\n */\nfunction keyToBinary(key: number[]): string {\n  let res = ''\n  for (const num of key) {\n    res += BINARY[num >> 4] + BINARY[num & 0x0f]\n  }\n  return res\n}\n\n/**\n * Converts a substring of an encoded secret to its numeric value.\n *\n * @param key - The encoded secret.\n * @param start - The start index to parse from.\n * @param length - The number of digits to parse after the start index.\n * @returns The binary value of the substring.\n */\nfunction extract(key: string, start: number, length: number): number {\n  const subKey = key.substring(start, start + length)\n  let acc = 0\n  for (let index = 0; index < subKey.length; index++) {\n    acc = acc * 2 + subKey.charCodeAt(index) - 48\n  }\n  return acc\n}\n\n/**\n * Generates a modified RFC1751 mnemonic in the same way rippled's wallet_propose does.\n *\n * @param hex_key - An encoded secret in hex format.\n * @returns A mnemonic following rippled's modified RFC1751 mnemonic standard.\n */\nfunction keyToRFC1751Mnemonic(hex_key: string): string {\n  // Remove whitespace and interpret hex\n  const buf = hexToBytes(hex_key.replace(/\\s+/gu, ''))\n  // Swap byte order and use rfc1751\n  let key: number[] = bufferToArray(swap128(buf))\n\n  // pad to 8 bytes\n  const padding: number[] = []\n  for (let index = 0; index < (8 - (key.length % 8)) % 8; index++) {\n    padding.push(0)\n  }\n  key = padding.concat(key)\n\n  const english: string[] = []\n  for (let index = 0; index < key.length; index += 8) {\n    const subKey = key.slice(index, index + 8)\n\n    // add parity\n    let skbin = keyToBinary(subKey)\n    let parity = 0\n    for (let j = 0; j < 64; j += 2) {\n      parity += extract(skbin, j, 2)\n    }\n    subKey.push((parity << 6) & 0xff)\n\n    skbin = keyToBinary(subKey)\n    for (let j = 0; j < 64; j += 11) {\n      english.push(rfc1751WordList[extract(skbin, j, 11)])\n    }\n  }\n  return english.join(' ')\n}\n\n/**\n * Converts an english mnemonic following rippled's modified RFC1751 standard to an encoded hex secret.\n *\n * @param english - A mnemonic generated using ripple's modified RFC1751 standard.\n * @throws Error if the parity after decoding does not match.\n * @returns A Buffer containing an encoded secret.\n */\nfunction rfc1751MnemonicToKey(english: string): Uint8Array {\n  const words = english.split(' ')\n  let key: number[] = []\n\n  for (let index = 0; index < words.length; index += 6) {\n    const { subKey, word }: { subKey: number[]; word: string } = getSubKey(\n      words,\n      index,\n    )\n\n    // check parity\n    const skbin = keyToBinary(subKey)\n    let parity = 0\n    for (let j = 0; j < 64; j += 2) {\n      parity += extract(skbin, j, 2)\n    }\n    const cs0 = extract(skbin, 64, 2)\n    const cs1 = parity & 3\n    if (cs0 !== cs1) {\n      throw new Error(`Parity error at ${word}`)\n    }\n\n    key = key.concat(subKey.slice(0, 8))\n  }\n\n  // This is a step specific to the XRPL's implementation\n  const bufferKey = swap128(Uint8Array.from(key))\n  return bufferKey\n}\n\nfunction getSubKey(\n  words: string[],\n  index: number,\n): { subKey: number[]; word: string } {\n  const sublist = words.slice(index, index + 6)\n  let bits = 0\n  const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  let word = ''\n  for (word of sublist) {\n    const idx = rfc1751WordList.indexOf(word.toUpperCase())\n    if (idx === -1) {\n      throw new TypeError(\n        `Expected an RFC1751 word, but received '${word}'. ` +\n          `For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`,\n      )\n    }\n    const shift = (8 - ((bits + 11) % 8)) % 8\n    const y = idx << shift\n    const cl = y >> 16\n    const cc = (y >> 8) & 0xff\n    const cr = y & 0xff\n    const t = Math.floor(bits / 8)\n    if (shift > 5) {\n      ch[t] |= cl\n      ch[t + 1] |= cc\n      ch[t + 2] |= cr\n    } else if (shift > -3) {\n      ch[t] |= cc\n      ch[t + 1] |= cr\n    } else {\n      ch[t] |= cr\n    }\n    bits += 11\n  }\n  const subKey: number[] = ch.slice()\n  return { subKey, word }\n}\n\nfunction bufferToArray(buf: Uint8Array): number[] {\n  /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- We know the end type */\n  return Array.prototype.slice.call(buf) as number[]\n}\n\nfunction swap(arr: Uint8Array, n: number, m: number): void {\n  const i = arr[n]\n  // eslint-disable-next-line no-param-reassign -- we have to swap\n  arr[n] = arr[m]\n  // eslint-disable-next-line no-param-reassign -- see above\n  arr[m] = i\n}\n\n/**\n * Interprets arr as an array of 64-bit numbers and swaps byte order in 64 bit chunks.\n * Example of two 64 bit numbers 0000000100000002 => 1000000020000000\n *\n * @param arr A Uint8Array representation of one or more 64 bit numbers\n * @returns Uint8Array An array containing the bytes of 64 bit numbers each with reversed endianness\n */\nfunction swap64(arr: Uint8Array): Uint8Array {\n  const len = arr.length\n\n  for (let i = 0; i < len; i += 8) {\n    swap(arr, i, i + 7)\n    swap(arr, i + 1, i + 6)\n    swap(arr, i + 2, i + 5)\n    swap(arr, i + 3, i + 4)\n  }\n\n  return arr\n}\n\n/**\n * Swap the byte order of a 128-bit array.\n * Ex. 0000000100000002 => 2000000010000000\n *\n * @param arr - A 128-bit (16 byte) array\n * @returns An array containing the same data with reversed endianness\n */\nfunction swap128(arr: Uint8Array): Uint8Array {\n  // Interprets arr as an array of (two, in this case) 64-bit numbers and swaps byte order in 64 bit chunks.\n  // Ex. 0000000100000002 => 1000000020000000\n  const reversedBytes = swap64(arr)\n  // Further swap the two 64-bit numbers since our buffer is 128 bits.\n  // Ex. 1000000020000000 => 2000000010000000\n  return concat([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)])\n}\n\nexport { rfc1751MnemonicToKey, keyToRFC1751Mnemonic }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}