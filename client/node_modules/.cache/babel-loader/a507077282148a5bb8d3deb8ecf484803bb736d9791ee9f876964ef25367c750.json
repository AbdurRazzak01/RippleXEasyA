{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst xrp_codec_1 = require(\"./xrp-codec\");\nObject.defineProperty(exports, \"codec\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.codec;\n  }\n});\nObject.defineProperty(exports, \"encodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeSeed;\n  }\n});\nObject.defineProperty(exports, \"decodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeSeed;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountID\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountID;\n  }\n});\nObject.defineProperty(exports, \"encodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"decodeNodePublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeNodePublic;\n  }\n});\nObject.defineProperty(exports, \"encodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.encodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"decodeAccountPublic\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.decodeAccountPublic;\n  }\n});\nObject.defineProperty(exports, \"isValidClassicAddress\", {\n  enumerable: true,\n  get: function () {\n    return xrp_codec_1.isValidClassicAddress;\n  }\n});\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Uint8Array.from([0x05, 0x44]),\n  // 4, 147\n  test: Uint8Array.from([0x04, 0x93])\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n  const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n  return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes');\n  }\n  if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag');\n  }\n  const theTag = tag || 0;\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n  const flag = tag === false || tag == null ? 0 : 1;\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n  const bytes = (0, utils_1.concat)([test ? PREFIX_BYTES.test : PREFIX_BYTES.main, accountId, Uint8Array.from([\n  // 0x00 if no tag, 0x01 if 32-bit tag\n  flag,\n  // first byte\n  theTag & 0xff,\n  // second byte\n  theTag >> 8 & 0xff,\n  // third byte\n  theTag >> 16 & 0xff,\n  // fourth byte\n  theTag >> 24 & 0xff, 0, 0, 0,\n  // four zero bytes (reserved for 64-bit tags)\n  0])]);\n  /* eslint-enable no-bitwise */\n  return xrp_codec_1.codec.encodeChecked(bytes);\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const {\n    accountId,\n    tag,\n    test\n  } = decodeXAddress(xAddress);\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n  return {\n    classicAddress,\n    tag,\n    test\n  };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n  const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const test = isUint8ArrayForTestAddress(decoded);\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const accountId = decoded.slice(2, 22);\n  const tag = tagFromUint8Array(decoded);\n  return {\n    accountId,\n    tag,\n    test\n  };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isUint8ArrayForTestAddress(buf) {\n  const decodedPrefix = buf.slice(0, 2);\n  if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {\n    return false;\n  }\n  if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {\n    return true;\n  }\n  throw new Error('Invalid X-address: bad prefix');\n}\nfunction tagFromUint8Array(buf) {\n  const flag = buf[22];\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address');\n  }\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n  }\n  if (flag !== 0) {\n    throw new Error('flag must be zero to indicate no tag');\n  }\n  if (!(0, utils_1.equal)((0, utils_1.hexToBytes)('0000000000000000'), buf.slice(23, 23 + 8))) {\n    throw new Error('remaining bytes must be zero');\n  }\n  return false;\n}\nfunction isValidXAddress(xAddress) {\n  try {\n    decodeXAddress(xAddress);\n  } catch (_error) {\n    return false;\n  }\n  return true;\n}\nexports.isValidXAddress = isValidXAddress;","map":{"version":3,"names":["utils_1","require","xrp_codec_1","Object","defineProperty","exports","enumerable","get","codec","encodeSeed","decodeSeed","encodeAccountID","decodeAccountID","encodeNodePublic","decodeNodePublic","encodeAccountPublic","decodeAccountPublic","isValidClassicAddress","PREFIX_BYTES","main","Uint8Array","from","test","MAX_32_BIT_UNSIGNED_INT","classicAddressToXAddress","classicAddress","tag","accountId","encodeXAddress","length","Error","theTag","flag","bytes","concat","encodeChecked","xAddressToClassicAddress","xAddress","decodeXAddress","decoded","decodeChecked","isUint8ArrayForTestAddress","slice","tagFromUint8Array","buf","decodedPrefix","equal","hexToBytes","isValidXAddress","_error"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-address-codec/src/index.ts"],"sourcesContent":["import { concat, equal, hexToBytes } from '@xrplf/isomorphic/utils'\n\nimport {\n  codec,\n  encodeSeed,\n  decodeSeed,\n  encodeAccountID,\n  decodeAccountID,\n  encodeNodePublic,\n  decodeNodePublic,\n  encodeAccountPublic,\n  decodeAccountPublic,\n  isValidClassicAddress,\n} from './xrp-codec'\n\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Uint8Array.from([0x05, 0x44]),\n  // 4, 147\n  test: Uint8Array.from([0x04, 0x93]),\n}\n\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295\n\nfunction classicAddressToXAddress(\n  classicAddress: string,\n  tag: number | false,\n  test: boolean,\n): string {\n  const accountId = decodeAccountID(classicAddress)\n  return encodeXAddress(accountId, tag, test)\n}\n\nfunction encodeXAddress(\n  accountId: Uint8Array,\n  tag: number | false,\n  test: boolean,\n): string {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes')\n  }\n  if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag')\n  }\n  const theTag = tag || 0\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n  const flag = tag === false || tag == null ? 0 : 1\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n  const bytes = concat([\n    test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n    accountId,\n    Uint8Array.from([\n      // 0x00 if no tag, 0x01 if 32-bit tag\n      flag,\n      // first byte\n      theTag & 0xff,\n      // second byte\n      (theTag >> 8) & 0xff,\n      // third byte\n      (theTag >> 16) & 0xff,\n      // fourth byte\n      (theTag >> 24) & 0xff,\n      0,\n      0,\n      0,\n      // four zero bytes (reserved for 64-bit tags)\n      0,\n    ]),\n  ])\n  /* eslint-enable no-bitwise */\n  return codec.encodeChecked(bytes)\n}\n\nfunction xAddressToClassicAddress(xAddress: string): {\n  classicAddress: string\n  tag: number | false\n  test: boolean\n} {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const { accountId, tag, test } = decodeXAddress(xAddress)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const classicAddress = encodeAccountID(accountId)\n  return {\n    classicAddress,\n    tag,\n    test,\n  }\n}\n\nfunction decodeXAddress(xAddress: string): {\n  accountId: Uint8Array\n  tag: number | false\n  test: boolean\n} {\n  const decoded = codec.decodeChecked(xAddress)\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const test = isUint8ArrayForTestAddress(decoded)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const accountId = decoded.slice(2, 22)\n  const tag = tagFromUint8Array(decoded)\n  return {\n    accountId,\n    tag,\n    test,\n  }\n}\n\nfunction isUint8ArrayForTestAddress(buf: Uint8Array): boolean {\n  const decodedPrefix = buf.slice(0, 2)\n  if (equal(PREFIX_BYTES.main, decodedPrefix)) {\n    return false\n  }\n  if (equal(PREFIX_BYTES.test, decodedPrefix)) {\n    return true\n  }\n\n  throw new Error('Invalid X-address: bad prefix')\n}\n\nfunction tagFromUint8Array(buf: Uint8Array): number | false {\n  const flag = buf[22]\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address')\n  }\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000\n  }\n  if (flag !== 0) {\n    throw new Error('flag must be zero to indicate no tag')\n  }\n  if (!equal(hexToBytes('0000000000000000'), buf.slice(23, 23 + 8))) {\n    throw new Error('remaining bytes must be zero')\n  }\n  return false\n}\n\nfunction isValidXAddress(xAddress: string): boolean {\n  try {\n    decodeXAddress(xAddress)\n  } catch (_error) {\n    return false\n  }\n  return true\n}\n\nexport {\n  // Codec with XRP alphabet\n  codec,\n  // Encode entropy as a \"seed\"\n  encodeSeed,\n  // Decode a seed into an object with its version, type, and bytes\n  decodeSeed,\n  // Encode bytes as a classic address (r...)\n  encodeAccountID,\n  // Decode a classic address to its raw bytes\n  decodeAccountID,\n  // Encode bytes to XRP Ledger node public key format\n  encodeNodePublic,\n  // Decode an XRP Ledger node public key into its raw bytes\n  decodeNodePublic,\n  // Encode a public key, as for payment channels\n  encodeAccountPublic,\n  // Decode a public key, as for payment channels\n  decodeAccountPublic,\n  // Check whether a classic address (r...) is valid\n  isValidClassicAddress,\n  // Derive X-address from classic address, tag, and network ID\n  classicAddressToXAddress,\n  // Encode account ID, tag, and network ID to X-address\n  encodeXAddress,\n  // Decode X-address to account ID, tag, and network ID\n  xAddressToClassicAddress,\n  // Convert X-address to classic address, tag, and network ID\n  decodeXAddress,\n  // Check whether an X-address (X...) is valid\n  isValidXAddress,\n}\n"],"mappings":";;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AAEA,MAAAC,WAAA,GAAAD,OAAA;AAyJEE,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAxJAL,WAAA,CAAAM,KAAK;EAAA;AAAA;AA0JLL,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAzJAL,WAAA,CAAAO,UAAU;EAAA;AAAA;AA2JVN,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA1JAL,WAAA,CAAAQ,UAAU;EAAA;AAAA;AA4JVP,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA3JAL,WAAA,CAAAS,eAAe;EAAA;AAAA;AA6JfR,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA5JAL,WAAA,CAAAU,eAAe;EAAA;AAAA;AA8JfT,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA7JAL,WAAA,CAAAW,gBAAgB;EAAA;AAAA;AA+JhBV,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA9JAL,WAAA,CAAAY,gBAAgB;EAAA;AAAA;AAgKhBX,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OA/JAL,WAAA,CAAAa,mBAAmB;EAAA;AAAA;AAiKnBZ,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAhKAL,WAAA,CAAAc,mBAAmB;EAAA;AAAA;AAkKnBb,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAjKAL,WAAA,CAAAe,qBAAqB;EAAA;AAAA;AAGvB,MAAMC,YAAY,GAAG;EACnB;EACAC,IAAI,EAAEC,UAAU,CAACC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;EACnC;EACAC,IAAI,EAAEF,UAAU,CAACC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC;CACnC;AAED,MAAME,uBAAuB,GAAG,UAAU;AAE1C,SAASC,wBAAwBA,CAC/BC,cAAsB,EACtBC,GAAmB,EACnBJ,IAAa;EAEb,MAAMK,SAAS,GAAG,IAAAzB,WAAA,CAAAU,eAAe,EAACa,cAAc,CAAC;EACjD,OAAOG,cAAc,CAACD,SAAS,EAAED,GAAG,EAAEJ,IAAI,CAAC;AAC7C;AAgJEjB,OAAA,CAAAmB,wBAAA,GAAAA,wBAAA;AA9IF,SAASI,cAAcA,CACrBD,SAAqB,EACrBD,GAAmB,EACnBJ,IAAa;EAEb,IAAIK,SAAS,CAACE,MAAM,KAAK,EAAE,EAAE;IAC3B;IACA,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;;EAEhD,IAAIJ,GAAG,KAAK,KAAK,IAAIA,GAAG,GAAGH,uBAAuB,EAAE;IAClD,MAAM,IAAIO,KAAK,CAAC,aAAa,CAAC;;EAEhC,MAAMC,MAAM,GAAGL,GAAG,IAAI,CAAC;EACvB;EACA,MAAMM,IAAI,GAAGN,GAAG,KAAK,KAAK,IAAIA,GAAG,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC;EACjD;;EAEA,MAAMO,KAAK,GAAG,IAAAjC,OAAA,CAAAkC,MAAM,EAAC,CACnBZ,IAAI,GAAGJ,YAAY,CAACI,IAAI,GAAGJ,YAAY,CAACC,IAAI,EAC5CQ,SAAS,EACTP,UAAU,CAACC,IAAI,CAAC;EACd;EACAW,IAAI;EACJ;EACAD,MAAM,GAAG,IAAI;EACb;EACCA,MAAM,IAAI,CAAC,GAAI,IAAI;EACpB;EACCA,MAAM,IAAI,EAAE,GAAI,IAAI;EACrB;EACCA,MAAM,IAAI,EAAE,GAAI,IAAI,EACrB,CAAC,EACD,CAAC,EACD,CAAC;EACD;EACA,CAAC,CACF,CAAC,CACH,CAAC;EACF;EACA,OAAO7B,WAAA,CAAAM,KAAK,CAAC2B,aAAa,CAACF,KAAK,CAAC;AACnC;AAwGE5B,OAAA,CAAAuB,cAAA,GAAAA,cAAA;AAtGF,SAASQ,wBAAwBA,CAACC,QAAgB;EAKhD;;;EAGA,MAAM;IAAEV,SAAS;IAAED,GAAG;IAAEJ;EAAI,CAAE,GAAGgB,cAAc,CAACD,QAAQ,CAAC;EACzD;EACA,MAAMZ,cAAc,GAAG,IAAAvB,WAAA,CAAAS,eAAe,EAACgB,SAAS,CAAC;EACjD,OAAO;IACLF,cAAc;IACdC,GAAG;IACHJ;GACD;AACH;AAwFEjB,OAAA,CAAA+B,wBAAA,GAAAA,wBAAA;AAtFF,SAASE,cAAcA,CAACD,QAAgB;EAKtC,MAAME,OAAO,GAAGrC,WAAA,CAAAM,KAAK,CAACgC,aAAa,CAACH,QAAQ,CAAC;EAC7C;;;EAGA,MAAMf,IAAI,GAAGmB,0BAA0B,CAACF,OAAO,CAAC;EAChD;EACA,MAAMZ,SAAS,GAAGY,OAAO,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACtC,MAAMhB,GAAG,GAAGiB,iBAAiB,CAACJ,OAAO,CAAC;EACtC,OAAO;IACLZ,SAAS;IACTD,GAAG;IACHJ;GACD;AACH;AAsEEjB,OAAA,CAAAiC,cAAA,GAAAA,cAAA;AApEF,SAASG,0BAA0BA,CAACG,GAAe;EACjD,MAAMC,aAAa,GAAGD,GAAG,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EACrC,IAAI,IAAA1C,OAAA,CAAA8C,KAAK,EAAC5B,YAAY,CAACC,IAAI,EAAE0B,aAAa,CAAC,EAAE;IAC3C,OAAO,KAAK;;EAEd,IAAI,IAAA7C,OAAA,CAAA8C,KAAK,EAAC5B,YAAY,CAACI,IAAI,EAAEuB,aAAa,CAAC,EAAE;IAC3C,OAAO,IAAI;;EAGb,MAAM,IAAIf,KAAK,CAAC,+BAA+B,CAAC;AAClD;AAEA,SAASa,iBAAiBA,CAACC,GAAe;EACxC,MAAMZ,IAAI,GAAGY,GAAG,CAAC,EAAE,CAAC;EACpB,IAAIZ,IAAI,IAAI,CAAC,EAAE;IACb;IACA,MAAM,IAAIF,KAAK,CAAC,uBAAuB,CAAC;;EAE1C,IAAIE,IAAI,KAAK,CAAC,EAAE;IACd;IACA,OAAOY,GAAG,CAAC,EAAE,CAAC,GAAGA,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,GAAGA,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,GAAGA,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS;;EAE5E,IAAIZ,IAAI,KAAK,CAAC,EAAE;IACd,MAAM,IAAIF,KAAK,CAAC,sCAAsC,CAAC;;EAEzD,IAAI,CAAC,IAAA9B,OAAA,CAAA8C,KAAK,EAAC,IAAA9C,OAAA,CAAA+C,UAAU,EAAC,kBAAkB,CAAC,EAAEH,GAAG,CAACF,KAAK,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;IACjE,MAAM,IAAIZ,KAAK,CAAC,8BAA8B,CAAC;;EAEjD,OAAO,KAAK;AACd;AAEA,SAASkB,eAAeA,CAACX,QAAgB;EACvC,IAAI;IACFC,cAAc,CAACD,QAAQ,CAAC;GACzB,CAAC,OAAOY,MAAM,EAAE;IACf,OAAO,KAAK;;EAEd,OAAO,IAAI;AACb;AAgCE5C,OAAA,CAAA2C,eAAA,GAAAA,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}