{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass ConnectionManager {\n  constructor() {\n    this.promisesAwaitingConnection = [];\n  }\n  resolveAllAwaiting() {\n    this.promisesAwaitingConnection.map(({\n      resolve\n    }) => resolve());\n    this.promisesAwaitingConnection = [];\n  }\n  rejectAllAwaiting(error) {\n    this.promisesAwaitingConnection.map(({\n      reject\n    }) => reject(error));\n    this.promisesAwaitingConnection = [];\n  }\n  awaitConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        this.promisesAwaitingConnection.push({\n          resolve,\n          reject\n        });\n      });\n    });\n  }\n}\nexports.default = ConnectionManager;","map":{"version":3,"names":["ConnectionManager","constructor","promisesAwaitingConnection","resolveAllAwaiting","map","resolve","rejectAllAwaiting","error","reject","awaitConnection","Promise","push","exports","default"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/client/ConnectionManager.ts"],"sourcesContent":["/**\n * Manage all the requests made to the websocket, and their async responses\n * that come in from the WebSocket. Because they come in over the WS connection\n * after-the-fact.\n */\nexport default class ConnectionManager {\n  private promisesAwaitingConnection: Array<{\n    resolve: (value?: void | PromiseLike<void>) => void\n    reject: (value?: Error) => void\n  }> = []\n\n  /**\n   * Resolves all awaiting connections.\n   */\n  public resolveAllAwaiting(): void {\n    this.promisesAwaitingConnection.map(({ resolve }) => resolve())\n    this.promisesAwaitingConnection = []\n  }\n\n  /**\n   * Rejects all awaiting connections.\n   *\n   * @param error - Error to throw in the rejection.\n   */\n  public rejectAllAwaiting(error: Error): void {\n    this.promisesAwaitingConnection.map(({ reject }) => reject(error))\n    this.promisesAwaitingConnection = []\n  }\n\n  /**\n   * Await a new connection.\n   *\n   * @returns A promise for resolving the connection.\n   */\n  public async awaitConnection(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.promisesAwaitingConnection.push({ resolve, reject })\n    })\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAqBA,iBAAiB;EAAtCC,YAAA;IACU,KAAAC,0BAA0B,GAG7B,EAAE;EA8BT;EAzBSC,kBAAkBA,CAAA;IACvB,IAAI,CAACD,0BAA0B,CAACE,GAAG,CAAC,CAAC;MAAEC;IAAO,CAAE,KAAKA,OAAO,EAAE,CAAC;IAC/D,IAAI,CAACH,0BAA0B,GAAG,EAAE;EACtC;EAOOI,iBAAiBA,CAACC,KAAY;IACnC,IAAI,CAACL,0BAA0B,CAACE,GAAG,CAAC,CAAC;MAAEI;IAAM,CAAE,KAAKA,MAAM,CAACD,KAAK,CAAC,CAAC;IAClE,IAAI,CAACL,0BAA0B,GAAG,EAAE;EACtC;EAOaO,eAAeA,CAAA;;MAC1B,OAAO,IAAIC,OAAO,CAAC,CAACL,OAAO,EAAEG,MAAM,KAAI;QACrC,IAAI,CAACN,0BAA0B,CAACS,IAAI,CAAC;UAAEN,OAAO;UAAEG;QAAM,CAAE,CAAC;MAC3D,CAAC,CAAC;IACJ,CAAC;;;AAjCHI,OAAA,CAAAC,OAAA,GAAAb,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}