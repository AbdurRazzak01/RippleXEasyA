{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.multisign = exports.verifySignature = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nfunction multisign(transactions) {\n  if (transactions.length === 0) {\n    throw new errors_1.ValidationError('There were 0 transactions to multisign');\n  }\n  const decodedTransactions = transactions.map(txOrBlob => {\n    return getDecodedTransaction(txOrBlob);\n  });\n  decodedTransactions.forEach(tx => {\n    (0, transactions_1.validate)(tx);\n    if (tx.Signers == null || tx.Signers.length === 0) {\n      throw new errors_1.ValidationError(\"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\");\n    }\n    if (tx.SigningPubKey !== '') {\n      throw new errors_1.ValidationError('SigningPubKey must be an empty string for all transactions when multisigning.');\n    }\n  });\n  validateTransactionEquivalence(decodedTransactions);\n  return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));\n}\nexports.multisign = multisign;\nfunction verifySignature(tx, publicKey) {\n  const decodedTx = getDecodedTransaction(tx);\n  let key = publicKey;\n  if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n    throw new Error('Transaction is missing a signature, TxnSignature');\n  }\n  if (!key) {\n    if (typeof decodedTx.SigningPubKey !== 'string' || !decodedTx.SigningPubKey) {\n      throw new Error('Transaction is missing a public key, SigningPubKey');\n    }\n    key = decodedTx.SigningPubKey;\n  }\n  return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);\n}\nexports.verifySignature = verifySignature;\nfunction validateTransactionEquivalence(transactions) {\n  const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), {\n    Signers: null\n  }));\n  if (transactions.slice(1).some(tx => JSON.stringify(Object.assign(Object.assign({}, tx), {\n    Signers: null\n  })) !== exampleTransaction)) {\n    throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');\n  }\n}\nfunction getTransactionWithAllSigners(transactions) {\n  const sortedSigners = transactions.flatMap(tx => {\n    var _a;\n    return (_a = tx.Signers) !== null && _a !== void 0 ? _a : [];\n  }).sort(compareSigners);\n  return Object.assign(Object.assign({}, transactions[0]), {\n    Signers: sortedSigners\n  });\n}\nfunction compareSigners(left, right) {\n  return addressToBigNumber(left.Signer.Account).comparedTo(addressToBigNumber(right.Signer.Account));\n}\nconst NUM_BITS_IN_HEX = 16;\nfunction addressToBigNumber(address) {\n  const hex = (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));\n  return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);\n}\nfunction getDecodedTransaction(txOrBlob) {\n  if (typeof txOrBlob === 'object') {\n    return (0, ripple_binary_codec_1.decode)((0, ripple_binary_codec_1.encode)(txOrBlob));\n  }\n  return (0, ripple_binary_codec_1.decode)(txOrBlob);\n}","map":{"version":3,"names":["utils_1","require","bignumber_js_1","ripple_address_codec_1","ripple_binary_codec_1","ripple_keypairs_1","errors_1","transactions_1","multisign","transactions","length","ValidationError","decodedTransactions","map","txOrBlob","getDecodedTransaction","forEach","tx","validate","Signers","SigningPubKey","validateTransactionEquivalence","encode","getTransactionWithAllSigners","exports","verifySignature","publicKey","decodedTx","key","TxnSignature","Error","verify","encodeForSigning","exampleTransaction","JSON","stringify","Object","assign","slice","some","sortedSigners","flatMap","_a","sort","compareSigners","left","right","addressToBigNumber","Signer","Account","comparedTo","NUM_BITS_IN_HEX","address","hex","bytesToHex","decodeAccountID","BigNumber","decode"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/Wallet/signer.ts"],"sourcesContent":["import { bytesToHex } from '@xrplf/isomorphic/utils'\nimport { BigNumber } from 'bignumber.js'\nimport { decodeAccountID } from 'ripple-address-codec'\nimport { decode, encode, encodeForSigning } from 'ripple-binary-codec'\nimport { verify } from 'ripple-keypairs'\n\nimport { ValidationError } from '../errors'\nimport { Signer } from '../models/common'\nimport { Transaction, validate } from '../models/transactions'\n\n/**\n * Takes several transactions with Signer fields (in object or blob form) and creates a\n * single transaction with all Signers that then gets signed and returned.\n *\n * @param transactions - An array of signed Transactions (in object or blob form) to combine into a single signed Transaction.\n * @returns A single signed Transaction which has all Signers from transactions within it.\n * @throws ValidationError if:\n * - There were no transactions given to sign\n * - The SigningPubKey field is not the empty string in any given transaction\n * - Any transaction is missing a Signers field.\n * @category Signing\n */\nfunction multisign(transactions: Array<Transaction | string>): string {\n  if (transactions.length === 0) {\n    throw new ValidationError('There were 0 transactions to multisign')\n  }\n\n  const decodedTransactions: Transaction[] = transactions.map(\n    (txOrBlob: string | Transaction) => {\n      return getDecodedTransaction(txOrBlob)\n    },\n  )\n\n  decodedTransactions.forEach((tx) => {\n    /*\n     * This will throw a more clear error for JS users if any of the supplied transactions has incorrect formatting\n     */\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- validate does not accept Transaction type\n    validate(tx as unknown as Record<string, unknown>)\n    if (tx.Signers == null || tx.Signers.length === 0) {\n      throw new ValidationError(\n        \"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\",\n      )\n    }\n\n    if (tx.SigningPubKey !== '') {\n      throw new ValidationError(\n        'SigningPubKey must be an empty string for all transactions when multisigning.',\n      )\n    }\n  })\n\n  validateTransactionEquivalence(decodedTransactions)\n\n  return encode(getTransactionWithAllSigners(decodedTransactions))\n}\n\n/**\n * Verifies that the given transaction has a valid signature based on public-key encryption.\n *\n * @param tx - A transaction to verify the signature of. (Can be in object or encoded string format).\n * @param [publicKey] Specific public key to use to verify. If not specified the `SigningPublicKey` of tx will be used.\n * @returns Returns true if tx has a valid signature, and returns false otherwise.\n * @throws Error when transaction is missing TxnSignature\n * @throws Error when publicKey is not provided and transaction is missing SigningPubKey\n * @category Utilities\n */\nfunction verifySignature(\n  tx: Transaction | string,\n  publicKey?: string,\n): boolean {\n  const decodedTx: Transaction = getDecodedTransaction(tx)\n  let key = publicKey\n\n  // Need a SignedTransaction class where TxnSignature is not optional.\n  if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n    throw new Error('Transaction is missing a signature, TxnSignature')\n  }\n\n  if (!key) {\n    // Need a SignedTransaction class where TxnSignature is not optional.\n    if (\n      typeof decodedTx.SigningPubKey !== 'string' ||\n      !decodedTx.SigningPubKey\n    ) {\n      throw new Error('Transaction is missing a public key, SigningPubKey')\n    }\n    key = decodedTx.SigningPubKey\n  }\n\n  return verify(encodeForSigning(decodedTx), decodedTx.TxnSignature, key)\n}\n\n/**\n * The transactions should all be equal except for the 'Signers' field.\n *\n * @param transactions - An array of Transactions which are expected to be equal other than 'Signers'.\n * @throws ValidationError if the transactions are not equal in any field other than 'Signers'.\n */\nfunction validateTransactionEquivalence(transactions: Transaction[]): void {\n  const exampleTransaction = JSON.stringify({\n    ...transactions[0],\n    Signers: null,\n  })\n  if (\n    transactions\n      .slice(1)\n      .some(\n        (tx) => JSON.stringify({ ...tx, Signers: null }) !== exampleTransaction,\n      )\n  ) {\n    throw new ValidationError(\n      'txJSON is not the same for all signedTransactions',\n    )\n  }\n}\n\nfunction getTransactionWithAllSigners(\n  transactions: Transaction[],\n): Transaction {\n  // Signers must be sorted in the combined transaction - See compareSigners' documentation for more details\n  const sortedSigners: Signer[] = transactions\n    .flatMap((tx) => tx.Signers ?? [])\n    .sort(compareSigners)\n\n  return { ...transactions[0], Signers: sortedSigners }\n}\n\n/**\n * If presented in binary form, the Signers array must be sorted based on\n * the numeric value of the signer addresses, with the lowest value first.\n * (If submitted as JSON, the submit_multisigned method handles this automatically.)\n * https://xrpl.org/multi-signing.html.\n *\n * @param left - A Signer to compare with.\n * @param right - A second Signer to compare with.\n * @returns 1 if left \\> right, 0 if left = right, -1 if left \\< right, and null if left or right are NaN.\n */\nfunction compareSigners(left: Signer, right: Signer): number {\n  return addressToBigNumber(left.Signer.Account).comparedTo(\n    addressToBigNumber(right.Signer.Account),\n  )\n}\n\nconst NUM_BITS_IN_HEX = 16\n\nfunction addressToBigNumber(address: string): BigNumber {\n  const hex = bytesToHex(decodeAccountID(address))\n  return new BigNumber(hex, NUM_BITS_IN_HEX)\n}\n\nfunction getDecodedTransaction(txOrBlob: Transaction | string): Transaction {\n  if (typeof txOrBlob === 'object') {\n    // We need this to handle X-addresses in multisigning\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- We are casting here to get strong typing\n    return decode(encode(txOrBlob)) as unknown as Transaction\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- We are casting here to get strong typing\n  return decode(txOrBlob) as unknown as Transaction\n}\n\nexport { verifySignature, multisign }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}