{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FieldLookup = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst serialized_type_1 = require(\"../types/serialized-type\");\nconst constants_1 = require(\"./constants\");\n/*\n * @brief: Serialize a field based on type_code and Field.nth\n */\nfunction fieldHeader(type, nth) {\n  const header = [];\n  if (type < 16) {\n    if (nth < 16) {\n      header.push(type << 4 | nth);\n    } else {\n      header.push(type << 4, nth);\n    }\n  } else if (nth < 16) {\n    header.push(nth, type);\n  } else {\n    header.push(0, type, nth);\n  }\n  return Uint8Array.from(header);\n}\nfunction buildField([name, info], typeOrdinal) {\n  const field = fieldHeader(typeOrdinal, info.nth);\n  return {\n    name: name,\n    nth: info.nth,\n    isVariableLengthEncoded: info.isVLEncoded,\n    isSerialized: info.isSerialized,\n    isSigningField: info.isSigningField,\n    ordinal: typeOrdinal << 16 | info.nth,\n    type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),\n    header: field,\n    associatedType: serialized_type_1.SerializedType // For later assignment in ./types/index.js or Definitions.updateAll(...)\n  };\n}\n/*\n * @brief: The collection of all fields as defined in definitions.json\n */\nclass FieldLookup {\n  constructor(fields, types) {\n    fields.forEach(([name, field_info]) => {\n      const typeOrdinal = types[field_info.type];\n      this[name] = buildField([name, field_info], typeOrdinal);\n      this[this[name].ordinal.toString()] = this[name];\n    });\n  }\n  fromString(value) {\n    return this[value];\n  }\n}\nexports.FieldLookup = FieldLookup;","map":{"version":3,"names":["bytes_1","require","serialized_type_1","constants_1","fieldHeader","type","nth","header","push","Uint8Array","from","buildField","name","info","typeOrdinal","field","isVariableLengthEncoded","isVLEncoded","isSerialized","isSigningField","ordinal","Bytes","TYPE_WIDTH","associatedType","SerializedType","FieldLookup","constructor","fields","types","forEach","field_info","toString","fromString","value","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/enums/field.ts"],"sourcesContent":["import { Bytes } from './bytes'\nimport { SerializedType } from '../types/serialized-type'\nimport { TYPE_WIDTH } from './constants'\n\n/**\n * Encoding information for a rippled field, often used in transactions.\n * See the enums [README.md](https://github.com/XRPLF/xrpl.js/tree/main/packages/ripple-binary-codec/src/enums) for more details on what each means.\n */\nexport interface FieldInfo {\n  nth: number\n  isVLEncoded: boolean\n  isSerialized: boolean\n  isSigningField: boolean\n  type: string\n}\n\nexport interface FieldInstance {\n  readonly nth: number\n  readonly isVariableLengthEncoded: boolean\n  readonly isSerialized: boolean\n  readonly isSigningField: boolean\n  readonly type: Bytes\n  readonly ordinal: number\n  readonly name: string\n  readonly header: Uint8Array\n  readonly associatedType: typeof SerializedType\n}\n\n/*\n * @brief: Serialize a field based on type_code and Field.nth\n */\nfunction fieldHeader(type: number, nth: number): Uint8Array {\n  const header: Array<number> = []\n  if (type < 16) {\n    if (nth < 16) {\n      header.push((type << 4) | nth)\n    } else {\n      header.push(type << 4, nth)\n    }\n  } else if (nth < 16) {\n    header.push(nth, type)\n  } else {\n    header.push(0, type, nth)\n  }\n  return Uint8Array.from(header)\n}\n\nfunction buildField(\n  [name, info]: [string, FieldInfo],\n  typeOrdinal: number,\n): FieldInstance {\n  const field = fieldHeader(typeOrdinal, info.nth)\n  return {\n    name: name,\n    nth: info.nth,\n    isVariableLengthEncoded: info.isVLEncoded,\n    isSerialized: info.isSerialized,\n    isSigningField: info.isSigningField,\n    ordinal: (typeOrdinal << 16) | info.nth,\n    type: new Bytes(info.type, typeOrdinal, TYPE_WIDTH),\n    header: field,\n    associatedType: SerializedType, // For later assignment in ./types/index.js or Definitions.updateAll(...)\n  }\n}\n\n/*\n * @brief: The collection of all fields as defined in definitions.json\n */\nexport class FieldLookup {\n  constructor(\n    fields: Array<[string, FieldInfo]>,\n    types: Record<string, number>,\n  ) {\n    fields.forEach(([name, field_info]) => {\n      const typeOrdinal = types[field_info.type]\n      this[name] = buildField([name, field_info], typeOrdinal)\n      this[this[name].ordinal.toString()] = this[name]\n    })\n  }\n\n  fromString(value: string): FieldInstance {\n    return this[value] as FieldInstance\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,WAAA,GAAAF,OAAA;AA0BA;;;AAGA,SAASG,WAAWA,CAACC,IAAY,EAAEC,GAAW;EAC5C,MAAMC,MAAM,GAAkB,EAAE;EAChC,IAAIF,IAAI,GAAG,EAAE,EAAE;IACb,IAAIC,GAAG,GAAG,EAAE,EAAE;MACZC,MAAM,CAACC,IAAI,CAAEH,IAAI,IAAI,CAAC,GAAIC,GAAG,CAAC;KAC/B,MAAM;MACLC,MAAM,CAACC,IAAI,CAACH,IAAI,IAAI,CAAC,EAAEC,GAAG,CAAC;;GAE9B,MAAM,IAAIA,GAAG,GAAG,EAAE,EAAE;IACnBC,MAAM,CAACC,IAAI,CAACF,GAAG,EAAED,IAAI,CAAC;GACvB,MAAM;IACLE,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEH,IAAI,EAAEC,GAAG,CAAC;;EAE3B,OAAOG,UAAU,CAACC,IAAI,CAACH,MAAM,CAAC;AAChC;AAEA,SAASI,UAAUA,CACjB,CAACC,IAAI,EAAEC,IAAI,CAAsB,EACjCC,WAAmB;EAEnB,MAAMC,KAAK,GAAGX,WAAW,CAACU,WAAW,EAAED,IAAI,CAACP,GAAG,CAAC;EAChD,OAAO;IACLM,IAAI,EAAEA,IAAI;IACVN,GAAG,EAAEO,IAAI,CAACP,GAAG;IACbU,uBAAuB,EAAEH,IAAI,CAACI,WAAW;IACzCC,YAAY,EAAEL,IAAI,CAACK,YAAY;IAC/BC,cAAc,EAAEN,IAAI,CAACM,cAAc;IACnCC,OAAO,EAAGN,WAAW,IAAI,EAAE,GAAID,IAAI,CAACP,GAAG;IACvCD,IAAI,EAAE,IAAIL,OAAA,CAAAqB,KAAK,CAACR,IAAI,CAACR,IAAI,EAAES,WAAW,EAAEX,WAAA,CAAAmB,UAAU,CAAC;IACnDf,MAAM,EAAEQ,KAAK;IACbQ,cAAc,EAAErB,iBAAA,CAAAsB,cAAc,CAAE;GACjC;AACH;AAEA;;;AAGA,MAAaC,WAAW;EACtBC,YACEC,MAAkC,EAClCC,KAA6B;IAE7BD,MAAM,CAACE,OAAO,CAAC,CAAC,CAACjB,IAAI,EAAEkB,UAAU,CAAC,KAAI;MACpC,MAAMhB,WAAW,GAAGc,KAAK,CAACE,UAAU,CAACzB,IAAI,CAAC;MAC1C,IAAI,CAACO,IAAI,CAAC,GAAGD,UAAU,CAAC,CAACC,IAAI,EAAEkB,UAAU,CAAC,EAAEhB,WAAW,CAAC;MACxD,IAAI,CAAC,IAAI,CAACF,IAAI,CAAC,CAACQ,OAAO,CAACW,QAAQ,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAAC;IAClD,CAAC,CAAC;EACJ;EAEAoB,UAAUA,CAACC,KAAa;IACtB,OAAO,IAAI,CAACA,KAAK,CAAkB;EACrC;;AAdFC,OAAA,CAAAT,WAAA,GAAAA,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}