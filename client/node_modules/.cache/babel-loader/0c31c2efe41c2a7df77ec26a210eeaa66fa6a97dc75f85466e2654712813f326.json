{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Wallet = void 0;\nconst bip32_1 = require(\"@scure/bip32\");\nconst bip39_1 = require(\"@scure/bip39\");\nconst english_1 = require(\"@scure/bip39/wordlists/english\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst ECDSA_1 = __importDefault(require(\"../ECDSA\"));\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nconst utils_2 = require(\"../sugar/utils\");\nconst collections_1 = require(\"../utils/collections\");\nconst hashLedger_1 = require(\"../utils/hashes/hashLedger\");\nconst rfc1751_1 = require(\"./rfc1751\");\nconst signer_1 = require(\"./signer\");\nconst DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;\nconst DEFAULT_DERIVATION_PATH = \"m/44'/144'/0'/0/0\";\nfunction validateKey(node) {\n  if (!(node.privateKey instanceof Uint8Array)) {\n    throw new errors_1.ValidationError('Unable to derive privateKey from mnemonic input');\n  }\n  if (!(node.publicKey instanceof Uint8Array)) {\n    throw new errors_1.ValidationError('Unable to derive publicKey from mnemonic input');\n  }\n}\nclass Wallet {\n  constructor(publicKey, privateKey, opts = {}) {\n    this.publicKey = publicKey;\n    this.privateKey = privateKey;\n    this.classicAddress = opts.masterAddress ? (0, utils_2.ensureClassicAddress)(opts.masterAddress) : (0, ripple_keypairs_1.deriveAddress)(publicKey);\n    this.seed = opts.seed;\n  }\n  get address() {\n    return this.classicAddress;\n  }\n  static generate(algorithm = DEFAULT_ALGORITHM) {\n    if (!Object.values(ECDSA_1.default).includes(algorithm)) {\n      throw new errors_1.ValidationError('Invalid cryptographic signing algorithm');\n    }\n    const seed = (0, ripple_keypairs_1.generateSeed)({\n      algorithm\n    });\n    return Wallet.fromSeed(seed, {\n      algorithm\n    });\n  }\n  static fromSeed(seed, opts = {}) {\n    return Wallet.deriveWallet(seed, {\n      algorithm: opts.algorithm,\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromEntropy(entropy, opts = {}) {\n    var _a;\n    const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;\n    const options = {\n      entropy: Uint8Array.from(entropy),\n      algorithm\n    };\n    const seed = (0, ripple_keypairs_1.generateSeed)(options);\n    return Wallet.deriveWallet(seed, {\n      algorithm,\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromMnemonic(mnemonic, opts = {}) {\n    var _a;\n    if (opts.mnemonicEncoding === 'rfc1751') {\n      return Wallet.fromRFC1751Mnemonic(mnemonic, {\n        masterAddress: opts.masterAddress,\n        algorithm: opts.algorithm\n      });\n    }\n    if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {\n      throw new errors_1.ValidationError('Unable to parse the given mnemonic using bip39 encoding');\n    }\n    const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);\n    const masterNode = bip32_1.HDKey.fromMasterSeed(seed);\n    const node = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);\n    validateKey(node);\n    const publicKey = (0, utils_1.bytesToHex)(node.publicKey);\n    const privateKey = (0, utils_1.bytesToHex)(node.privateKey);\n    return new Wallet(publicKey, `00${privateKey}`, {\n      masterAddress: opts.masterAddress\n    });\n  }\n  static fromRFC1751Mnemonic(mnemonic, opts) {\n    const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);\n    let encodeAlgorithm;\n    if (opts.algorithm === ECDSA_1.default.ed25519) {\n      encodeAlgorithm = 'ed25519';\n    } else {\n      encodeAlgorithm = 'secp256k1';\n    }\n    const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(seed, encodeAlgorithm);\n    return Wallet.fromSeed(encodedSeed, {\n      masterAddress: opts.masterAddress,\n      algorithm: opts.algorithm\n    });\n  }\n  static deriveWallet(seed, opts = {}) {\n    var _a;\n    const {\n      publicKey,\n      privateKey\n    } = (0, ripple_keypairs_1.deriveKeypair)(seed, {\n      algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM\n    });\n    return new Wallet(publicKey, privateKey, {\n      seed,\n      masterAddress: opts.masterAddress\n    });\n  }\n  sign(transaction, multisign) {\n    let multisignAddress = false;\n    if (typeof multisign === 'string' && multisign.startsWith('X')) {\n      multisignAddress = multisign;\n    } else if (multisign) {\n      multisignAddress = this.classicAddress;\n    }\n    const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), value => value == null);\n    if (tx.TxnSignature || tx.Signers) {\n      throw new errors_1.ValidationError('txJSON must not contain \"TxnSignature\" or \"Signers\" properties');\n    }\n    removeTrailingZeros(tx);\n    (0, transactions_1.validate)(tx);\n    const txToSignAndEncode = Object.assign({}, tx);\n    txToSignAndEncode.SigningPubKey = multisignAddress ? '' : this.publicKey;\n    if (multisignAddress) {\n      const signer = {\n        Account: multisignAddress,\n        SigningPubKey: this.publicKey,\n        TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress)\n      };\n      txToSignAndEncode.Signers = [{\n        Signer: signer\n      }];\n    } else {\n      txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);\n    }\n    const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);\n    return {\n      tx_blob: serialized,\n      hash: (0, hashLedger_1.hashSignedTx)(serialized)\n    };\n  }\n  verifyTransaction(signedTransaction) {\n    return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);\n  }\n  getXAddress(tag = false, isTestnet = false) {\n    return (0, ripple_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);\n  }\n}\nexports.Wallet = Wallet;\nWallet.fromSecret = Wallet.fromSeed;\nfunction computeSignature(tx, privateKey, signAs) {\n  if (signAs) {\n    const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(signAs) ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress : signAs;\n    return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);\n  }\n  return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigning)(tx), privateKey);\n}\nfunction removeTrailingZeros(tx) {\n  if (tx.TransactionType === 'Payment' && typeof tx.Amount !== 'string' && tx.Amount.value.includes('.') && tx.Amount.value.endsWith('0')) {\n    tx.Amount = Object.assign({}, tx.Amount);\n    tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();\n  }\n}","map":{"version":3,"names":["bip32_1","require","bip39_1","english_1","utils_1","bignumber_js_1","__importDefault","ripple_address_codec_1","ripple_binary_codec_1","ripple_keypairs_1","ECDSA_1","errors_1","transactions_1","utils_2","collections_1","hashLedger_1","rfc1751_1","signer_1","DEFAULT_ALGORITHM","default","ed25519","DEFAULT_DERIVATION_PATH","validateKey","node","privateKey","Uint8Array","ValidationError","publicKey","Wallet","constructor","opts","classicAddress","masterAddress","ensureClassicAddress","deriveAddress","seed","address","generate","algorithm","Object","values","includes","generateSeed","fromSeed","deriveWallet","fromEntropy","entropy","_a","options","from","fromMnemonic","mnemonic","mnemonicEncoding","fromRFC1751Mnemonic","validateMnemonic","wordlist","mnemonicToSeedSync","masterNode","HDKey","fromMasterSeed","derive","derivationPath","bytesToHex","rfc1751MnemonicToKey","encodeAlgorithm","encodedSeed","encodeSeed","deriveKeypair","sign","transaction","multisign","multisignAddress","startsWith","tx","omitBy","assign","value","TxnSignature","Signers","removeTrailingZeros","validate","txToSignAndEncode","SigningPubKey","signer","Account","computeSignature","Signer","serialized","encode","tx_blob","hash","hashSignedTx","verifyTransaction","signedTransaction","verifySignature","getXAddress","tag","isTestnet","classicAddressToXAddress","exports","fromSecret","signAs","isValidXAddress","xAddressToClassicAddress","encodeForMultisigning","encodeForSigning","TransactionType","Amount","endsWith","toString"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/Wallet/index.ts"],"sourcesContent":["import { HDKey } from '@scure/bip32'\nimport { mnemonicToSeedSync, validateMnemonic } from '@scure/bip39'\nimport { wordlist } from '@scure/bip39/wordlists/english'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\nimport BigNumber from 'bignumber.js'\nimport {\n  classicAddressToXAddress,\n  isValidXAddress,\n  xAddressToClassicAddress,\n  encodeSeed,\n} from 'ripple-address-codec'\nimport {\n  encodeForSigning,\n  encodeForMultisigning,\n  encode,\n} from 'ripple-binary-codec'\nimport {\n  deriveAddress,\n  deriveKeypair,\n  generateSeed,\n  sign,\n} from 'ripple-keypairs'\n\nimport ECDSA from '../ECDSA'\nimport { ValidationError } from '../errors'\nimport { Transaction, validate } from '../models/transactions'\nimport { ensureClassicAddress } from '../sugar/utils'\nimport { omitBy } from '../utils/collections'\nimport { hashSignedTx } from '../utils/hashes/hashLedger'\n\nimport { rfc1751MnemonicToKey } from './rfc1751'\nimport { verifySignature } from './signer'\n\nconst DEFAULT_ALGORITHM: ECDSA = ECDSA.ed25519\nconst DEFAULT_DERIVATION_PATH = \"m/44'/144'/0'/0/0\"\n\ntype ValidHDKey = HDKey & {\n  privateKey: Uint8Array\n  publicKey: Uint8Array\n}\n\nfunction validateKey(node: HDKey): asserts node is ValidHDKey {\n  if (!(node.privateKey instanceof Uint8Array)) {\n    throw new ValidationError('Unable to derive privateKey from mnemonic input')\n  }\n\n  if (!(node.publicKey instanceof Uint8Array)) {\n    throw new ValidationError('Unable to derive publicKey from mnemonic input')\n  }\n}\n\n/**\n * A utility for deriving a wallet composed of a keypair (publicKey/privateKey).\n * A wallet can be derived from either a seed, mnemonic, or entropy (array of random numbers).\n * It provides functionality to sign/verify transactions offline.\n *\n * @example\n * ```typescript\n *\n * // Derive a wallet from a base58 encoded seed.\n * const seedWallet = Wallet.fromSeed('ssZkdwURFMBXenJPbrpE14b6noJSu')\n * console.log(seedWallet)\n * // Wallet {\n * // publicKey: '02FE9932A9C4AA2AC9F0ED0F2B89302DE7C2C95F91D782DA3CF06E64E1C1216449',\n * // privateKey: '00445D0A16DD05EFAF6D5AF45E6B8A6DE4170D93C0627021A0B8E705786CBCCFF7',\n * // classicAddress: 'rG88FVLjvYiQaGftSa1cKuE2qNx7aK5ivo',\n * // seed: 'ssZkdwURFMBXenJPbrpE14b6noJSu'\n * // }.\n *\n * // Sign a JSON Transaction\n *  const signed = seedWallet.signTransaction({\n *      TransactionType: 'Payment',\n *      Account: 'rG88FVLjvYiQaGftSa1cKuE2qNx7aK5ivo'\n *      ...........\n * }).\n *\n * console.log(signed)\n * // '1200007321......B01BE1DFF3'.\n * console.log(decode(signed))\n * // {\n * //   TransactionType: 'Payment',\n * //   SigningPubKey: '02FE9932A9C4AA2AC9F0ED0F2B89302DE7C2C95F91D782DA3CF06E64E1C1216449',\n * //   TxnSignature: '3045022100AAD......5B631ABD21171B61B07D304',\n * //   Account: 'rG88FVLjvYiQaGftSa1cKuE2qNx7aK5ivo'\n * //   ...........\n * // }\n * ```\n *\n * @category Signing\n */\nexport class Wallet {\n  public readonly publicKey: string\n  public readonly privateKey: string\n  public readonly classicAddress: string\n  public readonly seed?: string\n\n  /**\n   * Creates a new Wallet.\n   *\n   * @param publicKey - The public key for the account.\n   * @param privateKey - The private key used for signing transactions for the account.\n   * @param opts - (Optional) Options to initialize a Wallet.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @param opts.seed - The seed used to derive the account keys.\n   */\n  public constructor(\n    publicKey: string,\n    privateKey: string,\n    opts: {\n      masterAddress?: string\n      seed?: string\n    } = {},\n  ) {\n    this.publicKey = publicKey\n    this.privateKey = privateKey\n    this.classicAddress = opts.masterAddress\n      ? ensureClassicAddress(opts.masterAddress)\n      : deriveAddress(publicKey)\n    this.seed = opts.seed\n  }\n\n  /**\n   * Alias for wallet.classicAddress.\n   *\n   * @returns The wallet's classic address.\n   */\n  public get address(): string {\n    return this.classicAddress\n  }\n\n  /**\n   * `generate()` creates a new random Wallet. In order to make this a valid account on ledger, you must\n   * Send XRP to it. On test networks that can be done with \"faucets\" which send XRP to any account which asks\n   * For it. You can call `client.fundWallet()` in order to generate credentials and fund the account on test networks.\n   *\n   * @example\n   * ```ts\n   * const { Wallet } = require('xrpl')\n   * const wallet = Wallet.generate()\n   * ```\n   *\n   * @param algorithm - The digital signature algorithm to generate an address for.\n   * @returns A new Wallet derived from a generated seed.\n   *\n   * @throws ValidationError when signing algorithm isn't valid\n   */\n  public static generate(algorithm: ECDSA = DEFAULT_ALGORITHM): Wallet {\n    if (!Object.values(ECDSA).includes(algorithm)) {\n      throw new ValidationError('Invalid cryptographic signing algorithm')\n    }\n    const seed = generateSeed({ algorithm })\n    return Wallet.fromSeed(seed, { algorithm })\n  }\n\n  /**\n   * Derives a wallet from a seed.\n   *\n   * @param seed - A string used to generate a keypair (publicKey/privateKey) to derive a wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.algorithm - The digital signature algorithm to generate an address for.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @returns A Wallet derived from a seed.\n   */\n  public static fromSeed(\n    seed: string,\n    opts: { masterAddress?: string; algorithm?: ECDSA } = {},\n  ): Wallet {\n    return Wallet.deriveWallet(seed, {\n      algorithm: opts.algorithm,\n      masterAddress: opts.masterAddress,\n    })\n  }\n\n  /**\n   * Derives a wallet from a secret (AKA a seed).\n   *\n   * @param secret - A string used to generate a keypair (publicKey/privateKey) to derive a wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.algorithm - The digital signature algorithm to generate an address for.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @returns A Wallet derived from a secret (AKA a seed).\n   */\n  // eslint-disable-next-line @typescript-eslint/member-ordering -- Member is used as a function here\n  public static fromSecret = Wallet.fromSeed\n\n  /**\n   * Derives a wallet from an entropy (array of random numbers).\n   *\n   * @param entropy - An array of random numbers to generate a seed used to derive a wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.algorithm - The digital signature algorithm to generate an address for.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @returns A Wallet derived from an entropy.\n   */\n  public static fromEntropy(\n    entropy: Uint8Array | number[],\n    opts: { masterAddress?: string; algorithm?: ECDSA } = {},\n  ): Wallet {\n    const algorithm = opts.algorithm ?? DEFAULT_ALGORITHM\n    const options = {\n      entropy: Uint8Array.from(entropy),\n      algorithm,\n    }\n    const seed = generateSeed(options)\n    return Wallet.deriveWallet(seed, {\n      algorithm,\n      masterAddress: opts.masterAddress,\n    })\n  }\n\n  /**\n   * Derives a wallet from a bip39 or RFC1751 mnemonic (Defaults to bip39).\n   *\n   * @deprecated since version 2.6.1.\n   * Will be deleted in version 3.0.0.\n   * This representation is currently deprecated in rippled.\n   * You should use another method to represent your keys such as a seed or public/private keypair.\n   *\n   * @param mnemonic - A string consisting of words (whitespace delimited) used to derive a wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @param opts.derivationPath - The path to derive a keypair (publicKey/privateKey). Only used for bip39 conversions.\n   * @param opts.mnemonicEncoding - If set to 'rfc1751', this interprets the mnemonic as a rippled RFC1751 mnemonic like\n   *                          `wallet_propose` generates in rippled. Otherwise the function defaults to bip39 decoding.\n   * @param opts.algorithm - Only used if opts.mnemonicEncoding is 'rfc1751'. Allows the mnemonic to generate its\n   *                         secp256k1 seed, or its ed25519 seed. By default, it will generate the secp256k1 seed\n   *                         to match the rippled `wallet_propose` default algorithm.\n   * @returns A Wallet derived from a mnemonic.\n   * @throws ValidationError if unable to derive private key from mnemonic input.\n   */\n  public static fromMnemonic(\n    mnemonic: string,\n    opts: {\n      masterAddress?: string\n      derivationPath?: string\n      mnemonicEncoding?: 'bip39' | 'rfc1751'\n      algorithm?: ECDSA\n    } = {},\n  ): Wallet {\n    if (opts.mnemonicEncoding === 'rfc1751') {\n      return Wallet.fromRFC1751Mnemonic(mnemonic, {\n        masterAddress: opts.masterAddress,\n        algorithm: opts.algorithm,\n      })\n    }\n    // Otherwise decode using bip39's mnemonic standard\n    if (!validateMnemonic(mnemonic, wordlist)) {\n      throw new ValidationError(\n        'Unable to parse the given mnemonic using bip39 encoding',\n      )\n    }\n\n    const seed = mnemonicToSeedSync(mnemonic)\n    const masterNode = HDKey.fromMasterSeed(seed)\n    const node = masterNode.derive(\n      opts.derivationPath ?? DEFAULT_DERIVATION_PATH,\n    )\n    validateKey(node)\n\n    const publicKey = bytesToHex(node.publicKey)\n    const privateKey = bytesToHex(node.privateKey)\n    return new Wallet(publicKey, `00${privateKey}`, {\n      masterAddress: opts.masterAddress,\n    })\n  }\n\n  /**\n   * Derives a wallet from a RFC1751 mnemonic, which is how `wallet_propose` encodes mnemonics.\n   *\n   * @param mnemonic - A string consisting of words (whitespace delimited) used to derive a wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @param opts.algorithm - The digital signature algorithm to generate an address for.\n   * @returns A Wallet derived from a mnemonic.\n   */\n  private static fromRFC1751Mnemonic(\n    mnemonic: string,\n    opts: { masterAddress?: string; algorithm?: ECDSA },\n  ): Wallet {\n    const seed = rfc1751MnemonicToKey(mnemonic)\n    let encodeAlgorithm: 'ed25519' | 'secp256k1'\n    if (opts.algorithm === ECDSA.ed25519) {\n      encodeAlgorithm = 'ed25519'\n    } else {\n      // Defaults to secp256k1 since that's the default for `wallet_propose`\n      encodeAlgorithm = 'secp256k1'\n    }\n    const encodedSeed = encodeSeed(seed, encodeAlgorithm)\n    return Wallet.fromSeed(encodedSeed, {\n      masterAddress: opts.masterAddress,\n      algorithm: opts.algorithm,\n    })\n  }\n\n  /**\n   * Derive a Wallet from a seed.\n   *\n   * @param seed - The seed used to derive the wallet.\n   * @param opts - (Optional) Options to derive a Wallet.\n   * @param opts.algorithm - The digital signature algorithm to generate an address for.\n   * @param opts.masterAddress - Include if a Wallet uses a Regular Key Pair. It must be the master address of the account.\n   * @returns A Wallet derived from the seed.\n   */\n  private static deriveWallet(\n    seed: string,\n    opts: { masterAddress?: string; algorithm?: ECDSA } = {},\n  ): Wallet {\n    const { publicKey, privateKey } = deriveKeypair(seed, {\n      algorithm: opts.algorithm ?? DEFAULT_ALGORITHM,\n    })\n    return new Wallet(publicKey, privateKey, {\n      seed,\n      masterAddress: opts.masterAddress,\n    })\n  }\n\n  /**\n   * Signs a transaction offline.\n   *\n   * @example\n   *\n   * ```ts\n   * const { Client, Wallet } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   *\n   * async function signTransaction() {\n   *   await client.connect()\n   *   const { balance: balance1, wallet: wallet1 } = client.fundWallet()\n   *   const { balance: balance2, wallet: wallet2 } = client.fundWallet()\n   *\n   *   const transaction = {\n   *     TransactionType: 'Payment',\n   *     Account: wallet1.address,\n   *     Destination: wallet2.address,\n   *     Amount: '10'\n   *   }\n   *\n   *   try {\n   *     await client.autofill(transaction)\n   *     const { tx_blob: signed_tx_blob, hash} = await wallet1.sign(transaction)\n   *     console.log(signed_tx_blob)\n   *   } catch (error) {\n   *     console.error(`Failed to sign transaction: ${error}`)\n   *   }\n   *   const result = await client.submit(signed_tx_blob)\n   *   await client.disconnect()\n   * }\n   *\n   * signTransaction()\n   * ```\n   * In order for a transaction to be validated, it must be signed by the account sending the transaction to prove\n   * That the owner is actually the one deciding to take that action.\n   *\n   * In this example, we created, signed, and then submitted a transaction to testnet. You may notice that the\n   * Output of `sign` includes a `tx_blob` and a `hash`, both of which are needed to submit & verify the results.\n   * Note: If you pass a `Wallet` to `client.submit` or `client.submitAndWait` it will do signing like this under the hood.\n   *\n   * `tx_blob` is a binary representation of a transaction on the XRP Ledger. It's essentially a byte array\n   * that encodes all of the data necessary to execute the transaction, including the source address, the destination\n   * address, the amount, and any additional fields required for the specific transaction type.\n   *\n   * `hash` is a unique identifier that's generated from the signed transaction data on the XRP Ledger. It's essentially\n   * A cryptographic digest of the signed transaction blob, created using a hash function. The signed transaction hash is\n   * Useful for identifying and tracking specific transactions on the XRP Ledger. It can be used to query transaction\n   * Information, verify the authenticity of a transaction, and detect any tampering with the transaction data.\n   *\n   * @param this - Wallet instance.\n   * @param transaction - A transaction to be signed offline.\n   * @param multisign - Specify true/false to use multisign or actual address (classic/x-address) to make multisign tx request.\n   * @returns A signed transaction.\n   * @throws ValidationError if the transaction is already signed or does not encode/decode to same result.\n   * @throws XrplError if the issued currency being signed is XRP ignoring case.\n   */\n  // eslint-disable-next-line max-lines-per-function -- introduced more checks to support both string and boolean inputs.\n  public sign(\n    this: Wallet,\n    transaction: Transaction,\n    multisign?: boolean | string,\n  ): {\n    tx_blob: string\n    hash: string\n  } {\n    let multisignAddress: boolean | string = false\n    if (typeof multisign === 'string' && multisign.startsWith('X')) {\n      multisignAddress = multisign\n    } else if (multisign) {\n      multisignAddress = this.classicAddress\n    }\n\n    // clean null & undefined valued tx properties\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- ensure Transaction flows through\n    const tx = omitBy(\n      { ...transaction },\n      (value) => value == null,\n    ) as unknown as Transaction\n\n    if (tx.TxnSignature || tx.Signers) {\n      throw new ValidationError(\n        'txJSON must not contain \"TxnSignature\" or \"Signers\" properties',\n      )\n    }\n\n    removeTrailingZeros(tx)\n\n    /*\n     * This will throw a more clear error for JS users if the supplied transaction has incorrect formatting\n     */\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- validate does not accept Transaction type\n    validate(tx as unknown as Record<string, unknown>)\n\n    const txToSignAndEncode = { ...tx }\n\n    txToSignAndEncode.SigningPubKey = multisignAddress ? '' : this.publicKey\n\n    if (multisignAddress) {\n      const signer = {\n        Account: multisignAddress,\n        SigningPubKey: this.publicKey,\n        TxnSignature: computeSignature(\n          txToSignAndEncode,\n          this.privateKey,\n          multisignAddress,\n        ),\n      }\n      txToSignAndEncode.Signers = [{ Signer: signer }]\n    } else {\n      txToSignAndEncode.TxnSignature = computeSignature(\n        txToSignAndEncode,\n        this.privateKey,\n      )\n    }\n\n    const serialized = encode(txToSignAndEncode)\n    return {\n      tx_blob: serialized,\n      hash: hashSignedTx(serialized),\n    }\n  }\n\n  /**\n   * Verifies a signed transaction offline.\n   *\n   * @param signedTransaction - A signed transaction (hex string of signTransaction result) to be verified offline.\n   * @returns Returns true if a signedTransaction is valid.\n   * @throws {Error} Transaction is missing a signature, TxnSignature\n   */\n  public verifyTransaction(signedTransaction: Transaction | string): boolean {\n    return verifySignature(signedTransaction, this.publicKey)\n  }\n\n  /**\n   * Gets an X-address in Testnet/Mainnet format.\n   *\n   * @param tag - A tag to be included within the X-address.\n   * @param isTestnet - A boolean to indicate if X-address should be in Testnet (true) or Mainnet (false) format.\n   * @returns An X-address.\n   */\n  public getXAddress(tag: number | false = false, isTestnet = false): string {\n    return classicAddressToXAddress(this.classicAddress, tag, isTestnet)\n  }\n}\n\n/**\n * Signs a transaction with the proper signing encoding.\n *\n * @param tx - A transaction to sign.\n * @param privateKey - A key to sign the transaction with.\n * @param signAs - Multisign only. An account address to include in the Signer field.\n * Can be either a classic address or an XAddress.\n * @returns A signed transaction in the proper format.\n */\nfunction computeSignature(\n  tx: Transaction,\n  privateKey: string,\n  signAs?: string,\n): string {\n  if (signAs) {\n    const classicAddress = isValidXAddress(signAs)\n      ? xAddressToClassicAddress(signAs).classicAddress\n      : signAs\n\n    return sign(encodeForMultisigning(tx, classicAddress), privateKey)\n  }\n  return sign(encodeForSigning(tx), privateKey)\n}\n\n/**\n * Remove trailing insignificant zeros for non-XRP Payment amount.\n * This resolves the serialization mismatch bug when encoding/decoding a non-XRP Payment transaction\n * with an amount that contains trailing insignificant zeros; for example, '123.4000' would serialize\n * to '123.4' and cause a mismatch.\n *\n * @param tx - The transaction prior to signing.\n */\nfunction removeTrailingZeros(tx: Transaction): void {\n  if (\n    tx.TransactionType === 'Payment' &&\n    typeof tx.Amount !== 'string' &&\n    tx.Amount.value.includes('.') &&\n    tx.Amount.value.endsWith('0')\n  ) {\n    // eslint-disable-next-line no-param-reassign -- Required to update Transaction.Amount.value\n    tx.Amount = { ...tx.Amount }\n    // eslint-disable-next-line no-param-reassign -- Required to update Transaction.Amount.value\n    tx.Amount.value = new BigNumber(tx.Amount.value).toString()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}