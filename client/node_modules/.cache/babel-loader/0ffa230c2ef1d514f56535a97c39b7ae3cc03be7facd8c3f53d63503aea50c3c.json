{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;\nconst types_1 = require(\"./types\");\nconst hash_prefixes_1 = require(\"./hash-prefixes\");\nconst hashes_1 = require(\"./hashes\");\n/**\n * Abstract class describing a SHAMapNode\n */\nclass ShaMapNode {}\nexports.ShaMapNode = ShaMapNode;\n/**\n * Class describing a Leaf of SHAMap\n */\nclass ShaMapLeaf extends ShaMapNode {\n  constructor(index, item) {\n    super();\n    this.index = index;\n    this.item = item;\n  }\n  /**\n   * @returns true as ShaMapLeaf is a leaf node\n   */\n  isLeaf() {\n    return true;\n  }\n  /**\n   * @returns false as ShaMapLeaf is not an inner node\n   */\n  isInner() {\n    return false;\n  }\n  /**\n   * Get the prefix of the this.item\n   *\n   * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array\n   */\n  hashPrefix() {\n    return this.item === undefined ? new Uint8Array(0) : this.item.hashPrefix();\n  }\n  /**\n   * Hash the bytes representation of this\n   *\n   * @returns hash of this.item concatenated with this.index\n   */\n  hash() {\n    const hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  }\n  /**\n   * Write the bytes representation of this to a BytesList\n   * @param list BytesList to write bytes to\n   */\n  toBytesSink(list) {\n    if (this.item !== undefined) {\n      this.item.toBytesSink(list);\n    }\n    this.index.toBytesSink(list);\n  }\n}\nexports.ShaMapLeaf = ShaMapLeaf;\n/**\n * Class defining an Inner Node of a SHAMap\n */\nclass ShaMapInner extends ShaMapNode {\n  constructor(depth = 0) {\n    super();\n    this.depth = depth;\n    this.slotBits = 0;\n    this.branches = Array(16);\n  }\n  /**\n   * @returns true as ShaMapInner is an inner node\n   */\n  isInner() {\n    return true;\n  }\n  /**\n   * @returns false as ShaMapInner is not a leaf node\n   */\n  isLeaf() {\n    return false;\n  }\n  /**\n   * Get the hash prefix for this node\n   *\n   * @returns hash prefix describing an inner node\n   */\n  hashPrefix() {\n    return hash_prefixes_1.HashPrefix.innerNode;\n  }\n  /**\n   * Set a branch of this node to be another node\n   *\n   * @param slot Slot to add branch to this.branches\n   * @param branch Branch to add\n   */\n  setBranch(slot, branch) {\n    this.slotBits = this.slotBits | 1 << slot;\n    this.branches[slot] = branch;\n  }\n  /**\n   * @returns true if node is empty\n   */\n  empty() {\n    return this.slotBits === 0;\n  }\n  /**\n   * Compute the hash of this node\n   *\n   * @returns The hash of this node\n   */\n  hash() {\n    if (this.empty()) {\n      return types_1.coreTypes.Hash256.ZERO_256;\n    }\n    const hash = hashes_1.Sha512Half.put(this.hashPrefix());\n    this.toBytesSink(hash);\n    return hash.finish();\n  }\n  /**\n   * Writes the bytes representation of this node to a BytesList\n   *\n   * @param list BytesList to write bytes to\n   */\n  toBytesSink(list) {\n    for (let i = 0; i < this.branches.length; i++) {\n      const branch = this.branches[i];\n      const hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;\n      hash.toBytesSink(list);\n    }\n  }\n  /**\n   * Add item to the SHAMap\n   *\n   * @param index Hash of the index of the item being inserted\n   * @param item Item to insert in the map\n   * @param leaf Leaf node to insert when branch doesn't exist\n   */\n  addItem(index, item, leaf) {\n    if (index === undefined) {\n      throw new Error();\n    }\n    if (index !== undefined) {\n      const nibble = index.nibblet(this.depth);\n      const existing = this.branches[nibble];\n      if (existing === undefined) {\n        this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));\n      } else if (existing instanceof ShaMapLeaf) {\n        const newInner = new ShaMapInner(this.depth + 1);\n        newInner.addItem(existing.index, undefined, existing);\n        newInner.addItem(index, item, leaf);\n        this.setBranch(nibble, newInner);\n      } else if (existing instanceof ShaMapInner) {\n        existing.addItem(index, item, leaf);\n      } else {\n        throw new Error('invalid ShaMap.addItem call');\n      }\n    }\n  }\n}\nclass ShaMap extends ShaMapInner {}\nexports.ShaMap = ShaMap;","map":{"version":3,"names":["types_1","require","hash_prefixes_1","hashes_1","ShaMapNode","exports","ShaMapLeaf","constructor","index","item","isLeaf","isInner","hashPrefix","undefined","Uint8Array","hash","Sha512Half","put","toBytesSink","finish","list","ShaMapInner","depth","slotBits","branches","Array","HashPrefix","innerNode","setBranch","slot","branch","empty","coreTypes","Hash256","ZERO_256","i","length","addItem","leaf","Error","nibble","nibblet","existing","newInner","ShaMap"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/shamap.ts"],"sourcesContent":["import { coreTypes } from './types'\nimport { HashPrefix } from './hash-prefixes'\nimport { Sha512Half } from './hashes'\nimport { Hash256 } from './types/hash-256'\nimport { BytesList } from './serdes/binary-serializer'\n\n/**\n * Abstract class describing a SHAMapNode\n */\nabstract class ShaMapNode {\n  abstract hashPrefix(): Uint8Array\n  abstract isLeaf(): boolean\n  abstract isInner(): boolean\n  abstract toBytesSink(list: BytesList): void\n  abstract hash(): Hash256\n}\n\n/**\n * Class describing a Leaf of SHAMap\n */\nclass ShaMapLeaf extends ShaMapNode {\n  constructor(public index: Hash256, public item?: ShaMapNode) {\n    super()\n  }\n\n  /**\n   * @returns true as ShaMapLeaf is a leaf node\n   */\n  isLeaf(): boolean {\n    return true\n  }\n\n  /**\n   * @returns false as ShaMapLeaf is not an inner node\n   */\n  isInner(): boolean {\n    return false\n  }\n\n  /**\n   * Get the prefix of the this.item\n   *\n   * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array\n   */\n  hashPrefix(): Uint8Array {\n    return this.item === undefined ? new Uint8Array(0) : this.item.hashPrefix()\n  }\n\n  /**\n   * Hash the bytes representation of this\n   *\n   * @returns hash of this.item concatenated with this.index\n   */\n  hash(): Hash256 {\n    const hash = Sha512Half.put(this.hashPrefix())\n    this.toBytesSink(hash)\n    return hash.finish()\n  }\n\n  /**\n   * Write the bytes representation of this to a BytesList\n   * @param list BytesList to write bytes to\n   */\n  toBytesSink(list: BytesList): void {\n    if (this.item !== undefined) {\n      this.item.toBytesSink(list)\n    }\n    this.index.toBytesSink(list)\n  }\n}\n\n/**\n * Class defining an Inner Node of a SHAMap\n */\nclass ShaMapInner extends ShaMapNode {\n  private slotBits = 0\n  private branches: Array<ShaMapNode> = Array(16)\n\n  constructor(private depth: number = 0) {\n    super()\n  }\n\n  /**\n   * @returns true as ShaMapInner is an inner node\n   */\n  isInner(): boolean {\n    return true\n  }\n\n  /**\n   * @returns false as ShaMapInner is not a leaf node\n   */\n  isLeaf(): boolean {\n    return false\n  }\n\n  /**\n   * Get the hash prefix for this node\n   *\n   * @returns hash prefix describing an inner node\n   */\n  hashPrefix(): Uint8Array {\n    return HashPrefix.innerNode\n  }\n\n  /**\n   * Set a branch of this node to be another node\n   *\n   * @param slot Slot to add branch to this.branches\n   * @param branch Branch to add\n   */\n  setBranch(slot: number, branch: ShaMapNode): void {\n    this.slotBits = this.slotBits | (1 << slot)\n    this.branches[slot] = branch\n  }\n\n  /**\n   * @returns true if node is empty\n   */\n  empty(): boolean {\n    return this.slotBits === 0\n  }\n\n  /**\n   * Compute the hash of this node\n   *\n   * @returns The hash of this node\n   */\n  hash(): Hash256 {\n    if (this.empty()) {\n      return (coreTypes.Hash256 as typeof Hash256).ZERO_256\n    }\n    const hash = Sha512Half.put(this.hashPrefix())\n    this.toBytesSink(hash)\n    return hash.finish()\n  }\n\n  /**\n   * Writes the bytes representation of this node to a BytesList\n   *\n   * @param list BytesList to write bytes to\n   */\n  toBytesSink(list: BytesList): void {\n    for (let i = 0; i < this.branches.length; i++) {\n      const branch = this.branches[i]\n      const hash = branch\n        ? branch.hash()\n        : (coreTypes.Hash256 as typeof Hash256).ZERO_256\n      hash.toBytesSink(list)\n    }\n  }\n\n  /**\n   * Add item to the SHAMap\n   *\n   * @param index Hash of the index of the item being inserted\n   * @param item Item to insert in the map\n   * @param leaf Leaf node to insert when branch doesn't exist\n   */\n  addItem(index?: Hash256, item?: ShaMapNode, leaf?: ShaMapLeaf): void {\n    if (index === undefined) {\n      throw new Error()\n    }\n    if (index !== undefined) {\n      const nibble = index.nibblet(this.depth)\n      const existing = this.branches[nibble]\n\n      if (existing === undefined) {\n        this.setBranch(nibble, leaf || new ShaMapLeaf(index, item))\n      } else if (existing instanceof ShaMapLeaf) {\n        const newInner = new ShaMapInner(this.depth + 1)\n        newInner.addItem(existing.index, undefined, existing)\n        newInner.addItem(index, item, leaf)\n        this.setBranch(nibble, newInner)\n      } else if (existing instanceof ShaMapInner) {\n        existing.addItem(index, item, leaf)\n      } else {\n        throw new Error('invalid ShaMap.addItem call')\n      }\n    }\n  }\n}\n\nclass ShaMap extends ShaMapInner {}\n\nexport { ShaMap, ShaMapNode, ShaMapLeaf }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}