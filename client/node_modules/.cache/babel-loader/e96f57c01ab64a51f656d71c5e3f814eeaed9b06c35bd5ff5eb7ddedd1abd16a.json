{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nObject.defineProperty(exports, \"decodeSeed\", {\n  enumerable: true,\n  get: function () {\n    return ripple_address_codec_1.decodeSeed;\n  }\n});\nconst ripemd160_1 = require(\"@xrplf/isomorphic/ripemd160\");\nconst sha256_1 = require(\"@xrplf/isomorphic/sha256\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst utils_2 = require(\"./signing-schemes/secp256k1/utils\");\nconst Sha512_1 = __importDefault(require(\"./utils/Sha512\"));\nconst assert_1 = __importDefault(require(\"./utils/assert\"));\nconst getAlgorithmFromKey_1 = require(\"./utils/getAlgorithmFromKey\");\nconst secp256k1_1 = __importDefault(require(\"./signing-schemes/secp256k1\"));\nconst ed25519_1 = __importDefault(require(\"./signing-schemes/ed25519\"));\nfunction getSigningScheme(algorithm) {\n  const schemes = {\n    'ecdsa-secp256k1': secp256k1_1.default,\n    ed25519: ed25519_1.default\n  };\n  return schemes[algorithm];\n}\nfunction generateSeed(options = {}) {\n  assert_1.default.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n  const entropy = options.entropy ? options.entropy.slice(0, 16) : (0, utils_1.randomBytes)(16);\n  const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n  return (0, ripple_address_codec_1.encodeSeed)(entropy, type);\n}\nexports.generateSeed = generateSeed;\nfunction deriveKeypair(seed, options) {\n  var _a;\n  const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);\n  const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;\n  const algorithm = proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n  const scheme = getSigningScheme(algorithm);\n  const keypair = scheme.deriveKeypair(decoded.bytes, options);\n  const messageToVerify = Sha512_1.default.half('This test message should verify.');\n  const signature = scheme.sign(messageToVerify, keypair.privateKey);\n  /* istanbul ignore if */\n  if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n    throw new Error('derived keypair did not generate verifiable signature');\n  }\n  return keypair;\n}\nexports.deriveKeypair = deriveKeypair;\nfunction sign(messageHex, privateKey) {\n  const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);\n  return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);\n}\nexports.sign = sign;\nfunction verify(messageHex, signature, publicKey) {\n  const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);\n  return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);\n}\nexports.verify = verify;\nfunction computePublicKeyHash(publicKeyBytes) {\n  return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));\n}\nfunction deriveAddressFromBytes(publicKeyBytes) {\n  return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));\n}\nfunction deriveAddress(publicKey) {\n  return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));\n}\nexports.deriveAddress = deriveAddress;\nfunction deriveNodeAddress(publicKey) {\n  const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);\n  const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);\n  return deriveAddressFromBytes(accountPublicBytes);\n}\nexports.deriveNodeAddress = deriveNodeAddress;","map":{"version":3,"names":["ripple_address_codec_1","require","Object","defineProperty","exports","enumerable","get","decodeSeed","ripemd160_1","sha256_1","utils_1","utils_2","Sha512_1","__importDefault","assert_1","getAlgorithmFromKey_1","secp256k1_1","ed25519_1","getSigningScheme","algorithm","schemes","default","ed25519","generateSeed","options","ok","entropy","length","slice","randomBytes","type","encodeSeed","deriveKeypair","seed","decoded","proposedAlgorithm","_a","scheme","keypair","bytes","messageToVerify","half","signature","sign","privateKey","verify","publicKey","Error","messageHex","getAlgorithmFromPrivateKey","hexToBytes","getAlgorithmFromPublicKey","computePublicKeyHash","publicKeyBytes","ripemd160","sha256","deriveAddressFromBytes","encodeAccountID","deriveAddress","deriveNodeAddress","generatorBytes","decodeNodePublic","accountPublicBytes","accountPublicFromPublicGenerator"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-keypairs/src/index.ts"],"sourcesContent":["import {\n  decodeNodePublic,\n  decodeSeed,\n  encodeAccountID,\n  encodeSeed,\n} from 'ripple-address-codec'\nimport { ripemd160 } from '@xrplf/isomorphic/ripemd160'\nimport { sha256 } from '@xrplf/isomorphic/sha256'\nimport { hexToBytes, randomBytes } from '@xrplf/isomorphic/utils'\n\nimport { accountPublicFromPublicGenerator } from './signing-schemes/secp256k1/utils'\nimport Sha512 from './utils/Sha512'\nimport assert from './utils/assert'\nimport type { Algorithm, HexString, KeyPair, SigningScheme } from './types'\nimport {\n  getAlgorithmFromPrivateKey,\n  getAlgorithmFromPublicKey,\n} from './utils/getAlgorithmFromKey'\n\nimport secp256k1 from './signing-schemes/secp256k1'\nimport ed25519 from './signing-schemes/ed25519'\n\nfunction getSigningScheme(algorithm: Algorithm): SigningScheme {\n  const schemes = { 'ecdsa-secp256k1': secp256k1, ed25519 }\n  return schemes[algorithm]\n}\n\nfunction generateSeed(\n  options: {\n    entropy?: Uint8Array\n    algorithm?: Algorithm\n  } = {},\n): string {\n  assert.ok(\n    !options.entropy || options.entropy.length >= 16,\n    'entropy too short',\n  )\n  const entropy = options.entropy\n    ? options.entropy.slice(0, 16)\n    : randomBytes(16)\n  const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1'\n  return encodeSeed(entropy, type)\n}\n\nfunction deriveKeypair(\n  seed: string,\n  options?: {\n    algorithm?: Algorithm\n    validator?: boolean\n    accountIndex?: number\n  },\n): KeyPair {\n  const decoded = decodeSeed(seed)\n  const proposedAlgorithm = options?.algorithm ?? decoded.type\n  const algorithm =\n    proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1'\n  const scheme = getSigningScheme(algorithm)\n  const keypair = scheme.deriveKeypair(decoded.bytes, options)\n  const messageToVerify = Sha512.half('This test message should verify.')\n  const signature = scheme.sign(messageToVerify, keypair.privateKey)\n  /* istanbul ignore if */\n  if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n    throw new Error('derived keypair did not generate verifiable signature')\n  }\n  return keypair\n}\n\nfunction sign(messageHex: HexString, privateKey: HexString): HexString {\n  const algorithm = getAlgorithmFromPrivateKey(privateKey)\n  return getSigningScheme(algorithm).sign(hexToBytes(messageHex), privateKey)\n}\n\nfunction verify(\n  messageHex: HexString,\n  signature: HexString,\n  publicKey: HexString,\n): boolean {\n  const algorithm = getAlgorithmFromPublicKey(publicKey)\n  return getSigningScheme(algorithm).verify(\n    hexToBytes(messageHex),\n    signature,\n    publicKey,\n  )\n}\n\nfunction computePublicKeyHash(publicKeyBytes: Uint8Array): Uint8Array {\n  return ripemd160(sha256(publicKeyBytes))\n}\n\nfunction deriveAddressFromBytes(publicKeyBytes: Uint8Array): string {\n  return encodeAccountID(computePublicKeyHash(publicKeyBytes))\n}\n\nfunction deriveAddress(publicKey: string): string {\n  return deriveAddressFromBytes(hexToBytes(publicKey))\n}\n\nfunction deriveNodeAddress(publicKey: string): string {\n  const generatorBytes = decodeNodePublic(publicKey)\n  const accountPublicBytes = accountPublicFromPublicGenerator(generatorBytes)\n  return deriveAddressFromBytes(accountPublicBytes)\n}\n\nexport {\n  generateSeed,\n  deriveKeypair,\n  sign,\n  verify,\n  deriveAddress,\n  deriveNodeAddress,\n  decodeSeed,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}