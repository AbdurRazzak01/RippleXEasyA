{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAmountValue = exports.validateBaseTransaction = exports.validateOptionalField = exports.validateRequiredField = exports.isXChainBridge = exports.isAmount = exports.isAccount = exports.isIssuedCurrency = exports.isCurrency = exports.isNumber = exports.isString = void 0;\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst MEMO_SIZE = 3;\nfunction isMemo(obj) {\n  if (obj.Memo == null) {\n    return false;\n  }\n  const memo = obj.Memo;\n  const size = Object.keys(memo).length;\n  const validData = memo.MemoData == null || typeof memo.MemoData === 'string';\n  const validFormat = memo.MemoFormat == null || typeof memo.MemoFormat === 'string';\n  const validType = memo.MemoType == null || typeof memo.MemoType === 'string';\n  return size >= 1 && size <= MEMO_SIZE && validData && validFormat && validType && (0, utils_1.onlyHasFields)(memo, ['MemoFormat', 'MemoData', 'MemoType']);\n}\nconst SIGNER_SIZE = 3;\nfunction isSigner(obj) {\n  const signerWrapper = obj;\n  if (signerWrapper.Signer == null) {\n    return false;\n  }\n  const signer = signerWrapper.Signer;\n  return Object.keys(signer).length === SIGNER_SIZE && typeof signer.Account === 'string' && typeof signer.TxnSignature === 'string' && typeof signer.SigningPubKey === 'string';\n}\nconst XRP_CURRENCY_SIZE = 1;\nconst ISSUE_SIZE = 2;\nconst ISSUED_CURRENCY_SIZE = 3;\nconst XCHAIN_BRIDGE_SIZE = 4;\nfunction isRecord(value) {\n  return value !== null && typeof value === 'object';\n}\nfunction isString(str) {\n  return typeof str === 'string';\n}\nexports.isString = isString;\nfunction isNumber(num) {\n  return typeof num === 'number';\n}\nexports.isNumber = isNumber;\nfunction isCurrency(input) {\n  return isRecord(input) && (Object.keys(input).length === ISSUE_SIZE && typeof input.issuer === 'string' && typeof input.currency === 'string' || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === 'XRP');\n}\nexports.isCurrency = isCurrency;\nfunction isIssuedCurrency(input) {\n  return isRecord(input) && Object.keys(input).length === ISSUED_CURRENCY_SIZE && typeof input.value === 'string' && typeof input.issuer === 'string' && typeof input.currency === 'string';\n}\nexports.isIssuedCurrency = isIssuedCurrency;\nfunction isAccount(account) {\n  return typeof account === 'string' && ((0, ripple_address_codec_1.isValidClassicAddress)(account) || (0, ripple_address_codec_1.isValidXAddress)(account));\n}\nexports.isAccount = isAccount;\nfunction isAmount(amount) {\n  return typeof amount === 'string' || isIssuedCurrency(amount);\n}\nexports.isAmount = isAmount;\nfunction isXChainBridge(input) {\n  return isRecord(input) && Object.keys(input).length === XCHAIN_BRIDGE_SIZE && typeof input.LockingChainDoor === 'string' && isCurrency(input.LockingChainIssue) && typeof input.IssuingChainDoor === 'string' && isCurrency(input.IssuingChainIssue);\n}\nexports.isXChainBridge = isXChainBridge;\nfunction validateRequiredField(tx, paramName, checkValidity) {\n  if (tx[paramName] == null) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: missing field ${paramName}`);\n  }\n  if (!checkValidity(tx[paramName])) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);\n  }\n}\nexports.validateRequiredField = validateRequiredField;\nfunction validateOptionalField(tx, paramName, checkValidity) {\n  if (tx[paramName] !== undefined && !checkValidity(tx[paramName])) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);\n  }\n}\nexports.validateOptionalField = validateOptionalField;\nfunction validateBaseTransaction(common) {\n  if (common.TransactionType === undefined) {\n    throw new errors_1.ValidationError('BaseTransaction: missing field TransactionType');\n  }\n  if (typeof common.TransactionType !== 'string') {\n    throw new errors_1.ValidationError('BaseTransaction: TransactionType not string');\n  }\n  if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {\n    throw new errors_1.ValidationError('BaseTransaction: Unknown TransactionType');\n  }\n  validateRequiredField(common, 'Account', isString);\n  validateOptionalField(common, 'Fee', isString);\n  validateOptionalField(common, 'Sequence', isNumber);\n  validateOptionalField(common, 'AccountTxnID', isString);\n  validateOptionalField(common, 'LastLedgerSequence', isNumber);\n  const memos = common.Memos;\n  if (memos !== undefined && !memos.every(isMemo)) {\n    throw new errors_1.ValidationError('BaseTransaction: invalid Memos');\n  }\n  const signers = common.Signers;\n  if (signers !== undefined && (signers.length === 0 || !signers.every(isSigner))) {\n    throw new errors_1.ValidationError('BaseTransaction: invalid Signers');\n  }\n  validateOptionalField(common, 'SourceTag', isNumber);\n  validateOptionalField(common, 'SigningPubKey', isString);\n  validateOptionalField(common, 'TicketSequence', isNumber);\n  validateOptionalField(common, 'TxnSignature', isString);\n  validateOptionalField(common, 'NetworkID', isNumber);\n}\nexports.validateBaseTransaction = validateBaseTransaction;\nfunction parseAmountValue(amount) {\n  if (!isAmount(amount)) {\n    return NaN;\n  }\n  if (typeof amount === 'string') {\n    return parseFloat(amount);\n  }\n  return parseFloat(amount.value);\n}\nexports.parseAmountValue = parseAmountValue;","map":{"version":3,"names":["ripple_address_codec_1","require","ripple_binary_codec_1","errors_1","utils_1","MEMO_SIZE","isMemo","obj","Memo","memo","size","Object","keys","length","validData","MemoData","validFormat","MemoFormat","validType","MemoType","onlyHasFields","SIGNER_SIZE","isSigner","signerWrapper","Signer","signer","Account","TxnSignature","SigningPubKey","XRP_CURRENCY_SIZE","ISSUE_SIZE","ISSUED_CURRENCY_SIZE","XCHAIN_BRIDGE_SIZE","isRecord","value","isString","str","exports","isNumber","num","isCurrency","input","issuer","currency","isIssuedCurrency","isAccount","account","isValidClassicAddress","isValidXAddress","isAmount","amount","isXChainBridge","LockingChainDoor","LockingChainIssue","IssuingChainDoor","IssuingChainIssue","validateRequiredField","tx","paramName","checkValidity","ValidationError","TransactionType","validateOptionalField","undefined","validateBaseTransaction","common","TRANSACTION_TYPES","includes","memos","Memos","every","signers","Signers","parseAmountValue","NaN","parseFloat"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/models/transactions/common.ts"],"sourcesContent":["import { isValidClassicAddress, isValidXAddress } from 'ripple-address-codec'\nimport { TRANSACTION_TYPES } from 'ripple-binary-codec'\n\nimport { ValidationError } from '../../errors'\nimport {\n  Amount,\n  Currency,\n  IssuedCurrencyAmount,\n  Memo,\n  Signer,\n  XChainBridge,\n} from '../common'\nimport { onlyHasFields } from '../utils'\n\nconst MEMO_SIZE = 3\n\nfunction isMemo(obj: { Memo?: unknown }): boolean {\n  if (obj.Memo == null) {\n    return false\n  }\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n  const memo = obj.Memo as Record<string, unknown>\n  const size = Object.keys(memo).length\n  const validData = memo.MemoData == null || typeof memo.MemoData === 'string'\n  const validFormat =\n    memo.MemoFormat == null || typeof memo.MemoFormat === 'string'\n  const validType = memo.MemoType == null || typeof memo.MemoType === 'string'\n\n  return (\n    size >= 1 &&\n    size <= MEMO_SIZE &&\n    validData &&\n    validFormat &&\n    validType &&\n    onlyHasFields(memo, ['MemoFormat', 'MemoData', 'MemoType'])\n  )\n}\n\nconst SIGNER_SIZE = 3\n\nfunction isSigner(obj: unknown): boolean {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n  const signerWrapper = obj as Record<string, unknown>\n\n  if (signerWrapper.Signer == null) {\n    return false\n  }\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS and Signer is previously unknown\n  const signer = signerWrapper.Signer as Record<string, unknown>\n  return (\n    Object.keys(signer).length === SIGNER_SIZE &&\n    typeof signer.Account === 'string' &&\n    typeof signer.TxnSignature === 'string' &&\n    typeof signer.SigningPubKey === 'string'\n  )\n}\n\nconst XRP_CURRENCY_SIZE = 1\nconst ISSUE_SIZE = 2\nconst ISSUED_CURRENCY_SIZE = 3\nconst XCHAIN_BRIDGE_SIZE = 4\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === 'object'\n}\n\n/**\n * Verify the form and type of a string at runtime.\n *\n * @param str - The object to check the form and type of.\n * @returns Whether the string is properly formed.\n */\nexport function isString(str: unknown): str is string {\n  return typeof str === 'string'\n}\n\n/**\n * Verify the form and type of a number at runtime.\n *\n * @param num - The object to check the form and type of.\n * @returns Whether the number is properly formed.\n */\nexport function isNumber(num: unknown): num is number {\n  return typeof num === 'number'\n}\n\n/**\n * Verify the form and type of an IssuedCurrency at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the IssuedCurrency is properly formed.\n */\nexport function isCurrency(input: unknown): input is Currency {\n  return (\n    isRecord(input) &&\n    ((Object.keys(input).length === ISSUE_SIZE &&\n      typeof input.issuer === 'string' &&\n      typeof input.currency === 'string') ||\n      (Object.keys(input).length === XRP_CURRENCY_SIZE &&\n        input.currency === 'XRP'))\n  )\n}\n\n/**\n * Verify the form and type of an IssuedCurrencyAmount at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the IssuedCurrencyAmount is properly formed.\n */\nexport function isIssuedCurrency(\n  input: unknown,\n): input is IssuedCurrencyAmount {\n  return (\n    isRecord(input) &&\n    Object.keys(input).length === ISSUED_CURRENCY_SIZE &&\n    typeof input.value === 'string' &&\n    typeof input.issuer === 'string' &&\n    typeof input.currency === 'string'\n  )\n}\n\n/**\n * Must be a valid account address\n */\nexport type Account = string\n\n/**\n * Verify a string is in fact a valid account address.\n *\n * @param account - The object to check the form and type of.\n * @returns Whether the account is properly formed account for a transaction.\n */\nexport function isAccount(account: unknown): account is Account {\n  return (\n    typeof account === 'string' &&\n    (isValidClassicAddress(account) || isValidXAddress(account))\n  )\n}\n\n/**\n * Verify the form and type of an Amount at runtime.\n *\n * @param amount - The object to check the form and type of.\n * @returns Whether the Amount is properly formed.\n */\nexport function isAmount(amount: unknown): amount is Amount {\n  return typeof amount === 'string' || isIssuedCurrency(amount)\n}\n\n/**\n * Verify the form and type of an XChainBridge at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the XChainBridge is properly formed.\n */\nexport function isXChainBridge(input: unknown): input is XChainBridge {\n  return (\n    isRecord(input) &&\n    Object.keys(input).length === XCHAIN_BRIDGE_SIZE &&\n    typeof input.LockingChainDoor === 'string' &&\n    isCurrency(input.LockingChainIssue) &&\n    typeof input.IssuingChainDoor === 'string' &&\n    isCurrency(input.IssuingChainIssue)\n  )\n}\n\n/* eslint-disable @typescript-eslint/restrict-template-expressions -- tx.TransactionType is checked before any calls */\n\n/**\n * Verify the form and type of a required type for a transaction at runtime.\n *\n * @param tx - The transaction input to check the form and type of.\n * @param paramName - The name of the transaction parameter.\n * @param checkValidity - The function to use to check the type.\n * @throws\n */\nexport function validateRequiredField(\n  tx: Record<string, unknown>,\n  paramName: string,\n  checkValidity: (inp: unknown) => boolean,\n): void {\n  if (tx[paramName] == null) {\n    throw new ValidationError(\n      `${tx.TransactionType}: missing field ${paramName}`,\n    )\n  }\n\n  if (!checkValidity(tx[paramName])) {\n    throw new ValidationError(\n      `${tx.TransactionType}: invalid field ${paramName}`,\n    )\n  }\n}\n\n/**\n * Verify the form and type of an optional type for a transaction at runtime.\n *\n * @param tx - The transaction input to check the form and type of.\n * @param paramName - The name of the transaction parameter.\n * @param checkValidity - The function to use to check the type.\n * @throws\n */\nexport function validateOptionalField(\n  tx: Record<string, unknown>,\n  paramName: string,\n  checkValidity: (inp: unknown) => boolean,\n): void {\n  if (tx[paramName] !== undefined && !checkValidity(tx[paramName])) {\n    throw new ValidationError(\n      `${tx.TransactionType}: invalid field ${paramName}`,\n    )\n  }\n}\n\n/* eslint-enable @typescript-eslint/restrict-template-expressions -- checked before */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- no global flags right now, so this is fine\nexport interface GlobalFlags {}\n\n/**\n * Every transaction has the same set of common fields.\n */\nexport interface BaseTransaction {\n  /** The unique address of the transaction sender. */\n  Account: Account\n  /**\n   * The type of transaction. Valid types include: `Payment`, `OfferCreate`,\n   * `TrustSet`, and many others.\n   */\n  TransactionType: string\n  /**\n   * Integer amount of XRP, in drops, to be destroyed as a cost for\n   * distributing this transaction to the network. Some transaction types have\n   * different minimum requirements.\n   */\n  Fee?: string\n  /**\n   * The sequence number of the account sending the transaction. A transaction\n   * is only valid if the Sequence number is exactly 1 greater than the previous\n   * transaction from the same account. The special case 0 means the transaction\n   * is using a Ticket instead.\n   */\n  Sequence?: number\n  /**\n   * Hash value identifying another transaction. If provided, this transaction\n   * is only valid if the sending account's previously-sent transaction matches\n   * the provided hash.\n   */\n  AccountTxnID?: string\n  /** Set of bit-flags for this transaction. */\n  Flags?: number | GlobalFlags\n  /**\n   * Highest ledger index this transaction can appear in. Specifying this field\n   * places a strict upper limit on how long the transaction can wait to be\n   * validated or rejected.\n   */\n  LastLedgerSequence?: number\n  /**\n   * Additional arbitrary information used to identify this transaction.\n   */\n  Memos?: Memo[]\n  /**\n   * Array of objects that represent a multi-signature which authorizes this\n   * transaction.\n   */\n  Signers?: Signer[]\n  /**\n   * Arbitrary integer used to identify the reason for this payment, or a sender\n   * on whose behalf this transaction is made. Conventionally, a refund should\n   * specify the initial payment's SourceTag as the refund payment's\n   * DestinationTag.\n   */\n  SourceTag?: number\n  /**\n   * Hex representation of the public key that corresponds to the private key\n   * used to sign this transaction. If an empty string, indicates a\n   * multi-signature is present in the Signers field instead.\n   */\n  SigningPubKey?: string\n  /**\n   * The sequence number of the ticket to use in place of a Sequence number. If\n   * this is provided, Sequence must be 0. Cannot be used with AccountTxnID.\n   */\n  TicketSequence?: number\n  /**\n   * The signature that verifies this transaction as originating from the\n   * account it says it is from.\n   */\n  TxnSignature?: string\n  /**\n   * The network id of the transaction.\n   */\n  NetworkID?: number\n}\n\n/**\n * Verify the common fields of a transaction. The validate functionality will be\n * optional, and will check transaction form at runtime. This should be called\n * any time a transaction will be verified.\n *\n * @param common - An interface w/ common transaction fields.\n * @throws When the common param is malformed.\n */\nexport function validateBaseTransaction(common: Record<string, unknown>): void {\n  if (common.TransactionType === undefined) {\n    throw new ValidationError('BaseTransaction: missing field TransactionType')\n  }\n\n  if (typeof common.TransactionType !== 'string') {\n    throw new ValidationError('BaseTransaction: TransactionType not string')\n  }\n\n  if (!TRANSACTION_TYPES.includes(common.TransactionType)) {\n    throw new ValidationError('BaseTransaction: Unknown TransactionType')\n  }\n\n  validateRequiredField(common, 'Account', isString)\n\n  validateOptionalField(common, 'Fee', isString)\n\n  validateOptionalField(common, 'Sequence', isNumber)\n\n  validateOptionalField(common, 'AccountTxnID', isString)\n\n  validateOptionalField(common, 'LastLedgerSequence', isNumber)\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n  const memos = common.Memos as Array<{ Memo?: unknown }> | undefined\n  if (memos !== undefined && !memos.every(isMemo)) {\n    throw new ValidationError('BaseTransaction: invalid Memos')\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n  const signers = common.Signers as Array<Record<string, unknown>> | undefined\n\n  if (\n    signers !== undefined &&\n    (signers.length === 0 || !signers.every(isSigner))\n  ) {\n    throw new ValidationError('BaseTransaction: invalid Signers')\n  }\n\n  validateOptionalField(common, 'SourceTag', isNumber)\n\n  validateOptionalField(common, 'SigningPubKey', isString)\n\n  validateOptionalField(common, 'TicketSequence', isNumber)\n\n  validateOptionalField(common, 'TxnSignature', isString)\n\n  validateOptionalField(common, 'NetworkID', isNumber)\n}\n\n/**\n * Parse the value of an amount, expressed either in XRP or as an Issued Currency, into a number.\n *\n * @param amount - An Amount to parse for its value.\n * @returns The parsed amount value, or NaN if the amount count not be parsed.\n */\nexport function parseAmountValue(amount: unknown): number {\n  if (!isAmount(amount)) {\n    return NaN\n  }\n  if (typeof amount === 'string') {\n    return parseFloat(amount)\n  }\n  return parseFloat(amount.value)\n}\n"],"mappings":";;;;;;AAAA,MAAAA,sBAAA,GAAAC,OAAA;AACA,MAAAC,qBAAA,GAAAD,OAAA;AAEA,MAAAE,QAAA,GAAAF,OAAA;AASA,MAAAG,OAAA,GAAAH,OAAA;AAEA,MAAMI,SAAS,GAAG,CAAC;AAEnB,SAASC,MAAMA,CAACC,GAAuB;EACrC,IAAIA,GAAG,CAACC,IAAI,IAAI,IAAI,EAAE;IACpB,OAAO,KAAK;;EAGd,MAAMC,IAAI,GAAGF,GAAG,CAACC,IAA+B;EAChD,MAAME,IAAI,GAAGC,MAAM,CAACC,IAAI,CAACH,IAAI,CAAC,CAACI,MAAM;EACrC,MAAMC,SAAS,GAAGL,IAAI,CAACM,QAAQ,IAAI,IAAI,IAAI,OAAON,IAAI,CAACM,QAAQ,KAAK,QAAQ;EAC5E,MAAMC,WAAW,GACfP,IAAI,CAACQ,UAAU,IAAI,IAAI,IAAI,OAAOR,IAAI,CAACQ,UAAU,KAAK,QAAQ;EAChE,MAAMC,SAAS,GAAGT,IAAI,CAACU,QAAQ,IAAI,IAAI,IAAI,OAAOV,IAAI,CAACU,QAAQ,KAAK,QAAQ;EAE5E,OACET,IAAI,IAAI,CAAC,IACTA,IAAI,IAAIL,SAAS,IACjBS,SAAS,IACTE,WAAW,IACXE,SAAS,IACT,IAAAd,OAAA,CAAAgB,aAAa,EAACX,IAAI,EAAE,CAAC,YAAY,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;AAE/D;AAEA,MAAMY,WAAW,GAAG,CAAC;AAErB,SAASC,QAAQA,CAACf,GAAY;EAE5B,MAAMgB,aAAa,GAAGhB,GAA8B;EAEpD,IAAIgB,aAAa,CAACC,MAAM,IAAI,IAAI,EAAE;IAChC,OAAO,KAAK;;EAGd,MAAMC,MAAM,GAAGF,aAAa,CAACC,MAAiC;EAC9D,OACEb,MAAM,CAACC,IAAI,CAACa,MAAM,CAAC,CAACZ,MAAM,KAAKQ,WAAW,IAC1C,OAAOI,MAAM,CAACC,OAAO,KAAK,QAAQ,IAClC,OAAOD,MAAM,CAACE,YAAY,KAAK,QAAQ,IACvC,OAAOF,MAAM,CAACG,aAAa,KAAK,QAAQ;AAE5C;AAEA,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,oBAAoB,GAAG,CAAC;AAC9B,MAAMC,kBAAkB,GAAG,CAAC;AAE5B,SAASC,QAAQA,CAACC,KAAc;EAC9B,OAAOA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;AACpD;AAQA,SAAgBC,QAAQA,CAACC,GAAY;EACnC,OAAO,OAAOA,GAAG,KAAK,QAAQ;AAChC;AAFAC,OAAA,CAAAF,QAAA,GAAAA,QAAA;AAUA,SAAgBG,QAAQA,CAACC,GAAY;EACnC,OAAO,OAAOA,GAAG,KAAK,QAAQ;AAChC;AAFAF,OAAA,CAAAC,QAAA,GAAAA,QAAA;AAUA,SAAgBE,UAAUA,CAACC,KAAc;EACvC,OACER,QAAQ,CAACQ,KAAK,CAAC,KACb9B,MAAM,CAACC,IAAI,CAAC6B,KAAK,CAAC,CAAC5B,MAAM,KAAKiB,UAAU,IACxC,OAAOW,KAAK,CAACC,MAAM,KAAK,QAAQ,IAChC,OAAOD,KAAK,CAACE,QAAQ,KAAK,QAAQ,IACjChC,MAAM,CAACC,IAAI,CAAC6B,KAAK,CAAC,CAAC5B,MAAM,KAAKgB,iBAAiB,IAC9CY,KAAK,CAACE,QAAQ,KAAK,KAAM,CAAC;AAElC;AATAN,OAAA,CAAAG,UAAA,GAAAA,UAAA;AAiBA,SAAgBI,gBAAgBA,CAC9BH,KAAc;EAEd,OACER,QAAQ,CAACQ,KAAK,CAAC,IACf9B,MAAM,CAACC,IAAI,CAAC6B,KAAK,CAAC,CAAC5B,MAAM,KAAKkB,oBAAoB,IAClD,OAAOU,KAAK,CAACP,KAAK,KAAK,QAAQ,IAC/B,OAAOO,KAAK,CAACC,MAAM,KAAK,QAAQ,IAChC,OAAOD,KAAK,CAACE,QAAQ,KAAK,QAAQ;AAEtC;AAVAN,OAAA,CAAAO,gBAAA,GAAAA,gBAAA;AAuBA,SAAgBC,SAASA,CAACC,OAAgB;EACxC,OACE,OAAOA,OAAO,KAAK,QAAQ,KAC1B,IAAA9C,sBAAA,CAAA+C,qBAAqB,EAACD,OAAO,CAAC,IAAI,IAAA9C,sBAAA,CAAAgD,eAAe,EAACF,OAAO,CAAC,CAAC;AAEhE;AALAT,OAAA,CAAAQ,SAAA,GAAAA,SAAA;AAaA,SAAgBI,QAAQA,CAACC,MAAe;EACtC,OAAO,OAAOA,MAAM,KAAK,QAAQ,IAAIN,gBAAgB,CAACM,MAAM,CAAC;AAC/D;AAFAb,OAAA,CAAAY,QAAA,GAAAA,QAAA;AAUA,SAAgBE,cAAcA,CAACV,KAAc;EAC3C,OACER,QAAQ,CAACQ,KAAK,CAAC,IACf9B,MAAM,CAACC,IAAI,CAAC6B,KAAK,CAAC,CAAC5B,MAAM,KAAKmB,kBAAkB,IAChD,OAAOS,KAAK,CAACW,gBAAgB,KAAK,QAAQ,IAC1CZ,UAAU,CAACC,KAAK,CAACY,iBAAiB,CAAC,IACnC,OAAOZ,KAAK,CAACa,gBAAgB,KAAK,QAAQ,IAC1Cd,UAAU,CAACC,KAAK,CAACc,iBAAiB,CAAC;AAEvC;AATAlB,OAAA,CAAAc,cAAA,GAAAA,cAAA;AAqBA,SAAgBK,qBAAqBA,CACnCC,EAA2B,EAC3BC,SAAiB,EACjBC,aAAwC;EAExC,IAAIF,EAAE,CAACC,SAAS,CAAC,IAAI,IAAI,EAAE;IACzB,MAAM,IAAIvD,QAAA,CAAAyD,eAAe,CACvB,GAAGH,EAAE,CAACI,eAAe,mBAAmBH,SAAS,EAAE,CACpD;;EAGH,IAAI,CAACC,aAAa,CAACF,EAAE,CAACC,SAAS,CAAC,CAAC,EAAE;IACjC,MAAM,IAAIvD,QAAA,CAAAyD,eAAe,CACvB,GAAGH,EAAE,CAACI,eAAe,mBAAmBH,SAAS,EAAE,CACpD;;AAEL;AAhBArB,OAAA,CAAAmB,qBAAA,GAAAA,qBAAA;AA0BA,SAAgBM,qBAAqBA,CACnCL,EAA2B,EAC3BC,SAAiB,EACjBC,aAAwC;EAExC,IAAIF,EAAE,CAACC,SAAS,CAAC,KAAKK,SAAS,IAAI,CAACJ,aAAa,CAACF,EAAE,CAACC,SAAS,CAAC,CAAC,EAAE;IAChE,MAAM,IAAIvD,QAAA,CAAAyD,eAAe,CACvB,GAAGH,EAAE,CAACI,eAAe,mBAAmBH,SAAS,EAAE,CACpD;;AAEL;AAVArB,OAAA,CAAAyB,qBAAA,GAAAA,qBAAA;AAqGA,SAAgBE,uBAAuBA,CAACC,MAA+B;EACrE,IAAIA,MAAM,CAACJ,eAAe,KAAKE,SAAS,EAAE;IACxC,MAAM,IAAI5D,QAAA,CAAAyD,eAAe,CAAC,gDAAgD,CAAC;;EAG7E,IAAI,OAAOK,MAAM,CAACJ,eAAe,KAAK,QAAQ,EAAE;IAC9C,MAAM,IAAI1D,QAAA,CAAAyD,eAAe,CAAC,6CAA6C,CAAC;;EAG1E,IAAI,CAAC1D,qBAAA,CAAAgE,iBAAiB,CAACC,QAAQ,CAACF,MAAM,CAACJ,eAAe,CAAC,EAAE;IACvD,MAAM,IAAI1D,QAAA,CAAAyD,eAAe,CAAC,0CAA0C,CAAC;;EAGvEJ,qBAAqB,CAACS,MAAM,EAAE,SAAS,EAAE9B,QAAQ,CAAC;EAElD2B,qBAAqB,CAACG,MAAM,EAAE,KAAK,EAAE9B,QAAQ,CAAC;EAE9C2B,qBAAqB,CAACG,MAAM,EAAE,UAAU,EAAE3B,QAAQ,CAAC;EAEnDwB,qBAAqB,CAACG,MAAM,EAAE,cAAc,EAAE9B,QAAQ,CAAC;EAEvD2B,qBAAqB,CAACG,MAAM,EAAE,oBAAoB,EAAE3B,QAAQ,CAAC;EAG7D,MAAM8B,KAAK,GAAGH,MAAM,CAACI,KAA8C;EACnE,IAAID,KAAK,KAAKL,SAAS,IAAI,CAACK,KAAK,CAACE,KAAK,CAAChE,MAAM,CAAC,EAAE;IAC/C,MAAM,IAAIH,QAAA,CAAAyD,eAAe,CAAC,gCAAgC,CAAC;;EAI7D,MAAMW,OAAO,GAAGN,MAAM,CAACO,OAAqD;EAE5E,IACED,OAAO,KAAKR,SAAS,KACpBQ,OAAO,CAAC1D,MAAM,KAAK,CAAC,IAAI,CAAC0D,OAAO,CAACD,KAAK,CAAChD,QAAQ,CAAC,CAAC,EAClD;IACA,MAAM,IAAInB,QAAA,CAAAyD,eAAe,CAAC,kCAAkC,CAAC;;EAG/DE,qBAAqB,CAACG,MAAM,EAAE,WAAW,EAAE3B,QAAQ,CAAC;EAEpDwB,qBAAqB,CAACG,MAAM,EAAE,eAAe,EAAE9B,QAAQ,CAAC;EAExD2B,qBAAqB,CAACG,MAAM,EAAE,gBAAgB,EAAE3B,QAAQ,CAAC;EAEzDwB,qBAAqB,CAACG,MAAM,EAAE,cAAc,EAAE9B,QAAQ,CAAC;EAEvD2B,qBAAqB,CAACG,MAAM,EAAE,WAAW,EAAE3B,QAAQ,CAAC;AACtD;AAhDAD,OAAA,CAAA2B,uBAAA,GAAAA,uBAAA;AAwDA,SAAgBS,gBAAgBA,CAACvB,MAAe;EAC9C,IAAI,CAACD,QAAQ,CAACC,MAAM,CAAC,EAAE;IACrB,OAAOwB,GAAG;;EAEZ,IAAI,OAAOxB,MAAM,KAAK,QAAQ,EAAE;IAC9B,OAAOyB,UAAU,CAACzB,MAAM,CAAC;;EAE3B,OAAOyB,UAAU,CAACzB,MAAM,CAAChB,KAAK,CAAC;AACjC;AARAG,OAAA,CAAAoC,gBAAA,GAAAA,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}