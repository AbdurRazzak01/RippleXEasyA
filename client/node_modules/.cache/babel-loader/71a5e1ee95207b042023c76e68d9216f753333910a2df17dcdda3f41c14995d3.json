{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BytesLookup = exports.Bytes = void 0;\n/*\n * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result\n */\nclass Bytes {\n  constructor(name, ordinal, ordinalWidth) {\n    this.name = name;\n    this.ordinal = ordinal;\n    this.ordinalWidth = ordinalWidth;\n    this.bytes = new Uint8Array(ordinalWidth);\n    for (let i = 0; i < ordinalWidth; i++) {\n      this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 0xff;\n    }\n  }\n  toJSON() {\n    return this.name;\n  }\n  toBytesSink(sink) {\n    sink.put(this.bytes);\n  }\n  toBytes() {\n    return this.bytes;\n  }\n}\nexports.Bytes = Bytes;\n/*\n * @brief: Collection of Bytes objects, mapping bidirectionally\n */\nclass BytesLookup {\n  constructor(types, ordinalWidth) {\n    this.ordinalWidth = ordinalWidth;\n    Object.entries(types).forEach(([k, v]) => {\n      this.add(k, v);\n    });\n  }\n  /**\n   * Add a new name value pair to the BytesLookup.\n   *\n   * @param name - A human readable name for the field.\n   * @param value - The numeric value for the field.\n   * @throws if the name or value already exist in the lookup because it's unclear how to decode.\n   */\n  add(name, value) {\n    if (this[name]) {\n      throw new SyntaxError(`Attempted to add a value with a duplicate name \"${name}\". This is not allowed because it is unclear how to decode.`);\n    }\n    if (this[value.toString()]) {\n      throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: \"${name}\" and previous name: \"${this[value.toString()]}. This is not allowed because it is unclear how to decode.\\nGiven value: ${value.toString()}`);\n    }\n    this[name] = new Bytes(name, value, this.ordinalWidth);\n    this[value.toString()] = this[name];\n  }\n  from(value) {\n    return value instanceof Bytes ? value : this[value];\n  }\n  fromParser(parser) {\n    return this.from(parser.readUIntN(this.ordinalWidth).toString());\n  }\n}\nexports.BytesLookup = BytesLookup;","map":{"version":3,"names":["Bytes","constructor","name","ordinal","ordinalWidth","bytes","Uint8Array","i","toJSON","toBytesSink","sink","put","toBytes","exports","BytesLookup","types","Object","entries","forEach","k","v","add","value","SyntaxError","toString","from","fromParser","parser","readUIntN"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/enums/bytes.ts"],"sourcesContent":["import { BytesList, BinaryParser } from '../binary'\n\n/*\n * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result\n */\nexport class Bytes {\n  readonly bytes: Uint8Array\n\n  constructor(\n    readonly name: string,\n    readonly ordinal: number,\n    readonly ordinalWidth: number,\n  ) {\n    this.bytes = new Uint8Array(ordinalWidth)\n    for (let i = 0; i < ordinalWidth; i++) {\n      this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 0xff\n    }\n  }\n\n  toJSON(): string {\n    return this.name\n  }\n\n  toBytesSink(sink: BytesList): void {\n    sink.put(this.bytes)\n  }\n\n  toBytes(): Uint8Array {\n    return this.bytes\n  }\n}\n\n/*\n * @brief: Collection of Bytes objects, mapping bidirectionally\n */\nexport class BytesLookup {\n  constructor(types: Record<string, number>, readonly ordinalWidth: number) {\n    Object.entries(types).forEach(([k, v]) => {\n      this.add(k, v)\n    })\n  }\n\n  /**\n   * Add a new name value pair to the BytesLookup.\n   *\n   * @param name - A human readable name for the field.\n   * @param value - The numeric value for the field.\n   * @throws if the name or value already exist in the lookup because it's unclear how to decode.\n   */\n  add(name: string, value: number): void {\n    if (this[name]) {\n      throw new SyntaxError(\n        `Attempted to add a value with a duplicate name \"${name}\". This is not allowed because it is unclear how to decode.`,\n      )\n    }\n    if (this[value.toString()]) {\n      throw new SyntaxError(\n        `Attempted to add a duplicate value under a different name (Given name: \"${name}\" and previous name: \"${\n          this[value.toString()]\n        }. This is not allowed because it is unclear how to decode.\\nGiven value: ${value.toString()}`,\n      )\n    }\n    this[name] = new Bytes(name, value, this.ordinalWidth)\n    this[value.toString()] = this[name]\n  }\n\n  from(value: Bytes | string): Bytes {\n    return value instanceof Bytes ? value : (this[value] as Bytes)\n  }\n\n  fromParser(parser: BinaryParser): Bytes {\n    return this.from(parser.readUIntN(this.ordinalWidth).toString())\n  }\n}\n"],"mappings":";;;;;;AAEA;;;AAGA,MAAaA,KAAK;EAGhBC,YACWC,IAAY,EACZC,OAAe,EACfC,YAAoB;IAFpB,KAAAF,IAAI,GAAJA,IAAI;IACJ,KAAAC,OAAO,GAAPA,OAAO;IACP,KAAAC,YAAY,GAAZA,YAAY;IAErB,IAAI,CAACC,KAAK,GAAG,IAAIC,UAAU,CAACF,YAAY,CAAC;IACzC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,YAAY,EAAEG,CAAC,EAAE,EAAE;MACrC,IAAI,CAACF,KAAK,CAACD,YAAY,GAAGG,CAAC,GAAG,CAAC,CAAC,GAAIJ,OAAO,KAAMI,CAAC,GAAG,CAAE,GAAI,IAAI;;EAEnE;EAEAC,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACN,IAAI;EAClB;EAEAO,WAAWA,CAACC,IAAe;IACzBA,IAAI,CAACC,GAAG,CAAC,IAAI,CAACN,KAAK,CAAC;EACtB;EAEAO,OAAOA,CAAA;IACL,OAAO,IAAI,CAACP,KAAK;EACnB;;AAxBFQ,OAAA,CAAAb,KAAA,GAAAA,KAAA;AA2BA;;;AAGA,MAAac,WAAW;EACtBb,YAAYc,KAA6B,EAAWX,YAAoB;IAApB,KAAAA,YAAY,GAAZA,YAAY;IAC9DY,MAAM,CAACC,OAAO,CAACF,KAAK,CAAC,CAACG,OAAO,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAI;MACvC,IAAI,CAACC,GAAG,CAACF,CAAC,EAAEC,CAAC,CAAC;IAChB,CAAC,CAAC;EACJ;EAEA;;;;;;;EAOAC,GAAGA,CAACnB,IAAY,EAAEoB,KAAa;IAC7B,IAAI,IAAI,CAACpB,IAAI,CAAC,EAAE;MACd,MAAM,IAAIqB,WAAW,CACnB,mDAAmDrB,IAAI,6DAA6D,CACrH;;IAEH,IAAI,IAAI,CAACoB,KAAK,CAACE,QAAQ,EAAE,CAAC,EAAE;MAC1B,MAAM,IAAID,WAAW,CACnB,2EAA2ErB,IAAI,yBAC7E,IAAI,CAACoB,KAAK,CAACE,QAAQ,EAAE,CACvB,4EAA4EF,KAAK,CAACE,QAAQ,EAAE,EAAE,CAC/F;;IAEH,IAAI,CAACtB,IAAI,CAAC,GAAG,IAAIF,KAAK,CAACE,IAAI,EAAEoB,KAAK,EAAE,IAAI,CAAClB,YAAY,CAAC;IACtD,IAAI,CAACkB,KAAK,CAACE,QAAQ,EAAE,CAAC,GAAG,IAAI,CAACtB,IAAI,CAAC;EACrC;EAEAuB,IAAIA,CAACH,KAAqB;IACxB,OAAOA,KAAK,YAAYtB,KAAK,GAAGsB,KAAK,GAAI,IAAI,CAACA,KAAK,CAAW;EAChE;EAEAI,UAAUA,CAACC,MAAoB;IAC7B,OAAO,IAAI,CAACF,IAAI,CAACE,MAAM,CAACC,SAAS,CAAC,IAAI,CAACxB,YAAY,CAAC,CAACoB,QAAQ,EAAE,CAAC;EAClE;;AArCFX,OAAA,CAAAC,WAAA,GAAAA,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}