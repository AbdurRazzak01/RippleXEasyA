{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Issue = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst account_id_1 = require(\"./account-id\");\nconst currency_1 = require(\"./currency\");\nconst serialized_type_1 = require(\"./serialized-type\");\n/**\n * Type guard for AmountObject\n */\nfunction isIssueObject(arg) {\n  const keys = Object.keys(arg).sort();\n  if (keys.length === 1) {\n    return keys[0] === 'currency';\n  }\n  return keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';\n}\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Issue extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : Issue.ZERO_ISSUED_CURRENCY.bytes);\n  }\n  /**\n   * Construct an amount from an IOU or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from(value) {\n    if (value instanceof Issue) {\n      return value;\n    }\n    if (isIssueObject(value)) {\n      const currency = currency_1.Currency.from(value.currency).toBytes();\n      if (value.issuer == null) {\n        return new Issue(currency);\n      }\n      const issuer = account_id_1.AccountID.from(value.issuer).toBytes();\n      return new Issue((0, utils_1.concat)([currency, issuer]));\n    }\n    throw new Error('Invalid type to construct an Amount');\n  }\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser) {\n    const currency = parser.read(20);\n    if (new currency_1.Currency(currency).toJSON() === 'XRP') {\n      return new Issue(currency);\n    }\n    const currencyAndIssuer = [currency, parser.read(20)];\n    return new Issue((0, utils_1.concat)(currencyAndIssuer));\n  }\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON() {\n    const parser = new binary_parser_1.BinaryParser(this.toString());\n    const currency = currency_1.Currency.fromParser(parser);\n    if (currency.toJSON() === 'XRP') {\n      return {\n        currency: currency.toJSON()\n      };\n    }\n    const issuer = account_id_1.AccountID.fromParser(parser);\n    return {\n      currency: currency.toJSON(),\n      issuer: issuer.toJSON()\n    };\n  }\n}\nexports.Issue = Issue;\nIssue.ZERO_ISSUED_CURRENCY = new Issue(new Uint8Array(20));","map":{"version":3,"names":["utils_1","require","binary_parser_1","account_id_1","currency_1","serialized_type_1","isIssueObject","arg","keys","Object","sort","length","Issue","SerializedType","constructor","bytes","ZERO_ISSUED_CURRENCY","from","value","currency","Currency","toBytes","issuer","AccountID","concat","Error","fromParser","parser","read","toJSON","currencyAndIssuer","BinaryParser","toString","exports","Uint8Array"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/types/issue.ts"],"sourcesContent":["import { concat } from '@xrplf/isomorphic/utils'\nimport { BinaryParser } from '../serdes/binary-parser'\n\nimport { AccountID } from './account-id'\nimport { Currency } from './currency'\nimport { JsonObject, SerializedType } from './serialized-type'\n\n/**\n * Interface for JSON objects that represent amounts\n */\ninterface IssueObject extends JsonObject {\n  currency: string\n  issuer?: string\n}\n\n/**\n * Type guard for AmountObject\n */\nfunction isIssueObject(arg): arg is IssueObject {\n  const keys = Object.keys(arg).sort()\n  if (keys.length === 1) {\n    return keys[0] === 'currency'\n  }\n  return keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer'\n}\n\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Issue extends SerializedType {\n  static readonly ZERO_ISSUED_CURRENCY: Issue = new Issue(new Uint8Array(20))\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? Issue.ZERO_ISSUED_CURRENCY.bytes)\n  }\n\n  /**\n   * Construct an amount from an IOU or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from<T extends Issue | IssueObject>(value: T): Issue {\n    if (value instanceof Issue) {\n      return value\n    }\n\n    if (isIssueObject(value)) {\n      const currency = Currency.from(value.currency).toBytes()\n      if (value.issuer == null) {\n        return new Issue(currency)\n      }\n      const issuer = AccountID.from(value.issuer).toBytes()\n      return new Issue(concat([currency, issuer]))\n    }\n\n    throw new Error('Invalid type to construct an Amount')\n  }\n\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser: BinaryParser): Issue {\n    const currency = parser.read(20)\n    if (new Currency(currency).toJSON() === 'XRP') {\n      return new Issue(currency)\n    }\n    const currencyAndIssuer = [currency, parser.read(20)]\n    return new Issue(concat(currencyAndIssuer))\n  }\n\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON(): IssueObject {\n    const parser = new BinaryParser(this.toString())\n    const currency = Currency.fromParser(parser) as Currency\n    if (currency.toJSON() === 'XRP') {\n      return { currency: currency.toJSON() }\n    }\n    const issuer = AccountID.fromParser(parser) as AccountID\n\n    return {\n      currency: currency.toJSON(),\n      issuer: issuer.toJSON(),\n    }\n  }\n}\n\nexport { Issue, IssueObject }\n"],"mappings":";;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,eAAA,GAAAD,OAAA;AAEA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,iBAAA,GAAAJ,OAAA;AAUA;;;AAGA,SAASK,aAAaA,CAACC,GAAG;EACxB,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACD,GAAG,CAAC,CAACG,IAAI,EAAE;EACpC,IAAIF,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;IACrB,OAAOH,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU;;EAE/B,OAAOA,IAAI,CAACG,MAAM,KAAK,CAAC,IAAIH,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ;AAC5E;AAEA;;;AAGA,MAAMI,KAAM,SAAQP,iBAAA,CAAAQ,cAAc;EAGhCC,YAAYC,KAAiB;IAC3B,KAAK,CAACA,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIH,KAAK,CAACI,oBAAoB,CAACD,KAAK,CAAC;EAClD;EAEA;;;;;;;EAOA,OAAOE,IAAIA,CAAgCC,KAAQ;IACjD,IAAIA,KAAK,YAAYN,KAAK,EAAE;MAC1B,OAAOM,KAAK;;IAGd,IAAIZ,aAAa,CAACY,KAAK,CAAC,EAAE;MACxB,MAAMC,QAAQ,GAAGf,UAAA,CAAAgB,QAAQ,CAACH,IAAI,CAACC,KAAK,CAACC,QAAQ,CAAC,CAACE,OAAO,EAAE;MACxD,IAAIH,KAAK,CAACI,MAAM,IAAI,IAAI,EAAE;QACxB,OAAO,IAAIV,KAAK,CAACO,QAAQ,CAAC;;MAE5B,MAAMG,MAAM,GAAGnB,YAAA,CAAAoB,SAAS,CAACN,IAAI,CAACC,KAAK,CAACI,MAAM,CAAC,CAACD,OAAO,EAAE;MACrD,OAAO,IAAIT,KAAK,CAAC,IAAAZ,OAAA,CAAAwB,MAAM,EAAC,CAACL,QAAQ,EAAEG,MAAM,CAAC,CAAC,CAAC;;IAG9C,MAAM,IAAIG,KAAK,CAAC,qCAAqC,CAAC;EACxD;EAEA;;;;;;EAMA,OAAOC,UAAUA,CAACC,MAAoB;IACpC,MAAMR,QAAQ,GAAGQ,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;IAChC,IAAI,IAAIxB,UAAA,CAAAgB,QAAQ,CAACD,QAAQ,CAAC,CAACU,MAAM,EAAE,KAAK,KAAK,EAAE;MAC7C,OAAO,IAAIjB,KAAK,CAACO,QAAQ,CAAC;;IAE5B,MAAMW,iBAAiB,GAAG,CAACX,QAAQ,EAAEQ,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;IACrD,OAAO,IAAIhB,KAAK,CAAC,IAAAZ,OAAA,CAAAwB,MAAM,EAACM,iBAAiB,CAAC,CAAC;EAC7C;EAEA;;;;;EAKAD,MAAMA,CAAA;IACJ,MAAMF,MAAM,GAAG,IAAIzB,eAAA,CAAA6B,YAAY,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC;IAChD,MAAMb,QAAQ,GAAGf,UAAA,CAAAgB,QAAQ,CAACM,UAAU,CAACC,MAAM,CAAa;IACxD,IAAIR,QAAQ,CAACU,MAAM,EAAE,KAAK,KAAK,EAAE;MAC/B,OAAO;QAAEV,QAAQ,EAAEA,QAAQ,CAACU,MAAM;MAAE,CAAE;;IAExC,MAAMP,MAAM,GAAGnB,YAAA,CAAAoB,SAAS,CAACG,UAAU,CAACC,MAAM,CAAc;IAExD,OAAO;MACLR,QAAQ,EAAEA,QAAQ,CAACU,MAAM,EAAE;MAC3BP,MAAM,EAAEA,MAAM,CAACO,MAAM;KACtB;EACH;;AAGOI,OAAA,CAAArB,KAAA,GAAAA,KAAA;AAjESA,KAAA,CAAAI,oBAAoB,GAAU,IAAIJ,KAAK,CAAC,IAAIsB,UAAU,CAAC,EAAE,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}