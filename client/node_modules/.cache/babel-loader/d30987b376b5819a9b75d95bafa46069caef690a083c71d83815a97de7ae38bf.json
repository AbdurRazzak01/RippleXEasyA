{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Amount = void 0;\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst account_id_1 = require(\"./account-id\");\nconst currency_1 = require(\"./currency\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst utils_2 = require(\"../utils\");\n/**\n * Constants for validating amounts\n */\nconst MIN_IOU_EXPONENT = -96;\nconst MAX_IOU_EXPONENT = 80;\nconst MAX_IOU_PRECISION = 16;\nconst MAX_DROPS = new bignumber_js_1.default('1e17');\nconst MIN_XRP = new bignumber_js_1.default('1e-6');\nconst mask = BigInt(0x00000000ffffffff);\n/**\n * BigNumber configuration for Amount IOUs\n */\nbignumber_js_1.default.config({\n  EXPONENTIAL_AT: [MIN_IOU_EXPONENT - MAX_IOU_PRECISION, MAX_IOU_EXPONENT + MAX_IOU_PRECISION]\n});\n/**\n * Type guard for AmountObject\n */\nfunction isAmountObject(arg) {\n  const keys = Object.keys(arg).sort();\n  return keys.length === 3 && keys[0] === 'currency' && keys[1] === 'issuer' && keys[2] === 'value';\n}\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Amount extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);\n  }\n  /**\n   * Construct an amount from an IOU or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from(value) {\n    if (value instanceof Amount) {\n      return value;\n    }\n    let amount = new Uint8Array(8);\n    if (typeof value === 'string') {\n      Amount.assertXrpIsValid(value);\n      const number = BigInt(value);\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n      (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);\n      (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);\n      amount = (0, utils_1.concat)(intBuf);\n      amount[0] |= 0x40;\n      return new Amount(amount);\n    }\n    if (isAmountObject(value)) {\n      const number = new bignumber_js_1.default(value.value);\n      Amount.assertIouIsValid(number);\n      if (number.isZero()) {\n        amount[0] |= 0x80;\n      } else {\n        const integerNumberString = number.times(`1e${-((number.e || 0) - 15)}`).abs().toString();\n        const num = BigInt(integerNumberString);\n        const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n        (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);\n        (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);\n        amount = (0, utils_1.concat)(intBuf);\n        amount[0] |= 0x80;\n        if (number.gt(new bignumber_js_1.default(0))) {\n          amount[0] |= 0x40;\n        }\n        const exponent = (number.e || 0) - 15;\n        const exponentByte = 97 + exponent;\n        amount[0] |= exponentByte >>> 2;\n        amount[1] |= (exponentByte & 0x03) << 6;\n      }\n      const currency = currency_1.Currency.from(value.currency).toBytes();\n      const issuer = account_id_1.AccountID.from(value.issuer).toBytes();\n      return new Amount((0, utils_1.concat)([amount, currency, issuer]));\n    }\n    throw new Error('Invalid type to construct an Amount');\n  }\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser) {\n    const isXRP = parser.peek() & 0x80;\n    const numBytes = isXRP ? 48 : 8;\n    return new Amount(parser.read(numBytes));\n  }\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON() {\n    if (this.isNative()) {\n      const bytes = this.bytes;\n      const isPositive = bytes[0] & 0x40;\n      const sign = isPositive ? '' : '-';\n      bytes[0] &= 0x3f;\n      const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));\n      const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));\n      const num = msb << BigInt(32) | lsb;\n      return `${sign}${num.toString()}`;\n    } else {\n      const parser = new binary_parser_1.BinaryParser(this.toString());\n      const mantissa = parser.read(8);\n      const currency = currency_1.Currency.fromParser(parser);\n      const issuer = account_id_1.AccountID.fromParser(parser);\n      const b1 = mantissa[0];\n      const b2 = mantissa[1];\n      const isPositive = b1 & 0x40;\n      const sign = isPositive ? '' : '-';\n      const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;\n      mantissa[0] = 0;\n      mantissa[1] &= 0x3f;\n      const value = new bignumber_js_1.default(`${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);\n      Amount.assertIouIsValid(value);\n      return {\n        value: value.toString(),\n        currency: currency.toJSON(),\n        issuer: issuer.toJSON()\n      };\n    }\n  }\n  /**\n   * Validate XRP amount\n   *\n   * @param amount String representing XRP amount\n   * @returns void, but will throw if invalid amount\n   */\n  static assertXrpIsValid(amount) {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`);\n    }\n    const decimal = new bignumber_js_1.default(amount);\n    if (!decimal.isZero()) {\n      if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {\n        throw new Error(`${amount.toString()} is an illegal amount`);\n      }\n    }\n  }\n  /**\n   * Validate IOU.value amount\n   *\n   * @param decimal BigNumber object representing IOU.value\n   * @returns void, but will throw if invalid amount\n   */\n  static assertIouIsValid(decimal) {\n    if (!decimal.isZero()) {\n      const p = decimal.precision();\n      const e = (decimal.e || 0) - 15;\n      if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {\n        throw new Error('Decimal precision out of range');\n      }\n      this.verifyNoDecimal(decimal);\n    }\n  }\n  /**\n   * Ensure that the value after being multiplied by the exponent does not\n   * contain a decimal.\n   *\n   * @param decimal a Decimal object\n   * @returns a string of the object without a decimal\n   */\n  static verifyNoDecimal(decimal) {\n    const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();\n    if (integerNumberString.indexOf('.') !== -1) {\n      throw new Error('Decimal place found in integerNumberString');\n    }\n  }\n  /**\n   * Test if this amount is in units of Native Currency(XRP)\n   *\n   * @returns true if Native (XRP)\n   */\n  isNative() {\n    return (this.bytes[0] & 0x80) === 0;\n  }\n}\nexports.Amount = Amount;\nAmount.defaultAmount = new Amount((0, utils_1.hexToBytes)('4000000000000000'));","map":{"version":3,"names":["binary_parser_1","require","account_id_1","currency_1","serialized_type_1","bignumber_js_1","__importDefault","utils_1","utils_2","MIN_IOU_EXPONENT","MAX_IOU_EXPONENT","MAX_IOU_PRECISION","MAX_DROPS","default","MIN_XRP","mask","BigInt","config","EXPONENTIAL_AT","isAmountObject","arg","keys","Object","sort","length","Amount","SerializedType","constructor","bytes","defaultAmount","from","value","amount","Uint8Array","assertXrpIsValid","number","intBuf","writeUInt32BE","Number","concat","assertIouIsValid","isZero","integerNumberString","times","e","abs","toString","num","gt","exponent","exponentByte","currency","Currency","toBytes","issuer","AccountID","Error","fromParser","parser","isXRP","peek","numBytes","read","toJSON","isNative","isPositive","sign","msb","readUInt32BE","slice","lsb","BinaryParser","mantissa","b1","b2","bytesToHex","indexOf","decimal","lt","p","precision","verifyNoDecimal","exports","hexToBytes"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/types/amount.ts"],"sourcesContent":["import { BinaryParser } from '../serdes/binary-parser'\n\nimport { AccountID } from './account-id'\nimport { Currency } from './currency'\nimport { JsonObject, SerializedType } from './serialized-type'\nimport BigNumber from 'bignumber.js'\nimport { bytesToHex, concat, hexToBytes } from '@xrplf/isomorphic/utils'\nimport { readUInt32BE, writeUInt32BE } from '../utils'\n\n/**\n * Constants for validating amounts\n */\nconst MIN_IOU_EXPONENT = -96\nconst MAX_IOU_EXPONENT = 80\nconst MAX_IOU_PRECISION = 16\nconst MAX_DROPS = new BigNumber('1e17')\nconst MIN_XRP = new BigNumber('1e-6')\nconst mask = BigInt(0x00000000ffffffff)\n\n/**\n * BigNumber configuration for Amount IOUs\n */\nBigNumber.config({\n  EXPONENTIAL_AT: [\n    MIN_IOU_EXPONENT - MAX_IOU_PRECISION,\n    MAX_IOU_EXPONENT + MAX_IOU_PRECISION,\n  ],\n})\n\n/**\n * Interface for JSON objects that represent amounts\n */\ninterface AmountObject extends JsonObject {\n  value: string\n  currency: string\n  issuer: string\n}\n\n/**\n * Type guard for AmountObject\n */\nfunction isAmountObject(arg): arg is AmountObject {\n  const keys = Object.keys(arg).sort()\n  return (\n    keys.length === 3 &&\n    keys[0] === 'currency' &&\n    keys[1] === 'issuer' &&\n    keys[2] === 'value'\n  )\n}\n\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Amount extends SerializedType {\n  static defaultAmount: Amount = new Amount(hexToBytes('4000000000000000'))\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? Amount.defaultAmount.bytes)\n  }\n\n  /**\n   * Construct an amount from an IOU or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from<T extends Amount | AmountObject | string>(value: T): Amount {\n    if (value instanceof Amount) {\n      return value\n    }\n\n    let amount = new Uint8Array(8)\n    if (typeof value === 'string') {\n      Amount.assertXrpIsValid(value)\n\n      const number = BigInt(value)\n\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n      writeUInt32BE(intBuf[0], Number(number >> BigInt(32)), 0)\n      writeUInt32BE(intBuf[1], Number(number & BigInt(mask)), 0)\n\n      amount = concat(intBuf)\n\n      amount[0] |= 0x40\n\n      return new Amount(amount)\n    }\n\n    if (isAmountObject(value)) {\n      const number = new BigNumber(value.value)\n      Amount.assertIouIsValid(number)\n\n      if (number.isZero()) {\n        amount[0] |= 0x80\n      } else {\n        const integerNumberString = number\n          .times(`1e${-((number.e || 0) - 15)}`)\n          .abs()\n          .toString()\n\n        const num = BigInt(integerNumberString)\n        const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n        writeUInt32BE(intBuf[0], Number(num >> BigInt(32)), 0)\n        writeUInt32BE(intBuf[1], Number(num & BigInt(mask)), 0)\n\n        amount = concat(intBuf)\n\n        amount[0] |= 0x80\n\n        if (number.gt(new BigNumber(0))) {\n          amount[0] |= 0x40\n        }\n\n        const exponent = (number.e || 0) - 15\n        const exponentByte = 97 + exponent\n        amount[0] |= exponentByte >>> 2\n        amount[1] |= (exponentByte & 0x03) << 6\n      }\n\n      const currency = Currency.from(value.currency).toBytes()\n      const issuer = AccountID.from(value.issuer).toBytes()\n      return new Amount(concat([amount, currency, issuer]))\n    }\n\n    throw new Error('Invalid type to construct an Amount')\n  }\n\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser: BinaryParser): Amount {\n    const isXRP = parser.peek() & 0x80\n    const numBytes = isXRP ? 48 : 8\n    return new Amount(parser.read(numBytes))\n  }\n\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON(): AmountObject | string {\n    if (this.isNative()) {\n      const bytes = this.bytes\n      const isPositive = bytes[0] & 0x40\n      const sign = isPositive ? '' : '-'\n      bytes[0] &= 0x3f\n\n      const msb = BigInt(readUInt32BE(bytes.slice(0, 4), 0))\n      const lsb = BigInt(readUInt32BE(bytes.slice(4), 0))\n      const num = (msb << BigInt(32)) | lsb\n\n      return `${sign}${num.toString()}`\n    } else {\n      const parser = new BinaryParser(this.toString())\n      const mantissa = parser.read(8)\n      const currency = Currency.fromParser(parser) as Currency\n      const issuer = AccountID.fromParser(parser) as AccountID\n\n      const b1 = mantissa[0]\n      const b2 = mantissa[1]\n\n      const isPositive = b1 & 0x40\n      const sign = isPositive ? '' : '-'\n      const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97\n\n      mantissa[0] = 0\n      mantissa[1] &= 0x3f\n      const value = new BigNumber(`${sign}0x${bytesToHex(mantissa)}`).times(\n        `1e${exponent}`,\n      )\n      Amount.assertIouIsValid(value)\n\n      return {\n        value: value.toString(),\n        currency: currency.toJSON(),\n        issuer: issuer.toJSON(),\n      }\n    }\n  }\n\n  /**\n   * Validate XRP amount\n   *\n   * @param amount String representing XRP amount\n   * @returns void, but will throw if invalid amount\n   */\n  private static assertXrpIsValid(amount: string): void {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`)\n    }\n\n    const decimal = new BigNumber(amount)\n    if (!decimal.isZero()) {\n      if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {\n        throw new Error(`${amount.toString()} is an illegal amount`)\n      }\n    }\n  }\n\n  /**\n   * Validate IOU.value amount\n   *\n   * @param decimal BigNumber object representing IOU.value\n   * @returns void, but will throw if invalid amount\n   */\n  private static assertIouIsValid(decimal: BigNumber): void {\n    if (!decimal.isZero()) {\n      const p = decimal.precision()\n      const e = (decimal.e || 0) - 15\n      if (\n        p > MAX_IOU_PRECISION ||\n        e > MAX_IOU_EXPONENT ||\n        e < MIN_IOU_EXPONENT\n      ) {\n        throw new Error('Decimal precision out of range')\n      }\n      this.verifyNoDecimal(decimal)\n    }\n  }\n\n  /**\n   * Ensure that the value after being multiplied by the exponent does not\n   * contain a decimal.\n   *\n   * @param decimal a Decimal object\n   * @returns a string of the object without a decimal\n   */\n  private static verifyNoDecimal(decimal: BigNumber): void {\n    const integerNumberString = decimal\n      .times(`1e${-((decimal.e || 0) - 15)}`)\n      .abs()\n      .toString()\n\n    if (integerNumberString.indexOf('.') !== -1) {\n      throw new Error('Decimal place found in integerNumberString')\n    }\n  }\n\n  /**\n   * Test if this amount is in units of Native Currency(XRP)\n   *\n   * @returns true if Native (XRP)\n   */\n  private isNative(): boolean {\n    return (this.bytes[0] & 0x80) === 0\n  }\n}\n\nexport { Amount, AmountObject }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}