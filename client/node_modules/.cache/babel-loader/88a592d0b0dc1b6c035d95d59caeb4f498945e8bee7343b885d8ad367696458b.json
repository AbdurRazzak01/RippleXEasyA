{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePayment = exports.PaymentFlags = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nvar PaymentFlags;\n(function (PaymentFlags) {\n  PaymentFlags[PaymentFlags[\"tfNoDirectRipple\"] = 65536] = \"tfNoDirectRipple\";\n  PaymentFlags[PaymentFlags[\"tfPartialPayment\"] = 131072] = \"tfPartialPayment\";\n  PaymentFlags[PaymentFlags[\"tfLimitQuality\"] = 262144] = \"tfLimitQuality\";\n})(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));\nfunction validatePayment(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  if (tx.Amount === undefined) {\n    throw new errors_1.ValidationError('PaymentTransaction: missing field Amount');\n  }\n  if (!(0, common_1.isAmount)(tx.Amount)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid Amount');\n  }\n  (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);\n  (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);\n  if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {\n    throw new errors_1.ValidationError('PaymentTransaction: InvoiceID must be a string');\n  }\n  if (tx.Paths !== undefined && !isPaths(tx.Paths)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid Paths');\n  }\n  if (tx.SendMax !== undefined && !(0, common_1.isAmount)(tx.SendMax)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid SendMax');\n  }\n  checkPartialPayment(tx);\n}\nexports.validatePayment = validatePayment;\nfunction checkPartialPayment(tx) {\n  var _a;\n  if (tx.DeliverMin != null) {\n    if (tx.Flags == null) {\n      throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');\n    }\n    const flags = tx.Flags;\n    const isTfPartialPayment = typeof flags === 'number' ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment) : (_a = flags.tfPartialPayment) !== null && _a !== void 0 ? _a : false;\n    if (!isTfPartialPayment) {\n      throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');\n    }\n    if (!(0, common_1.isAmount)(tx.DeliverMin)) {\n      throw new errors_1.ValidationError('PaymentTransaction: invalid DeliverMin');\n    }\n  }\n}\nfunction isPathStep(pathStep) {\n  if (pathStep.account !== undefined && typeof pathStep.account !== 'string') {\n    return false;\n  }\n  if (pathStep.currency !== undefined && typeof pathStep.currency !== 'string') {\n    return false;\n  }\n  if (pathStep.issuer !== undefined && typeof pathStep.issuer !== 'string') {\n    return false;\n  }\n  if (pathStep.account !== undefined && pathStep.currency === undefined && pathStep.issuer === undefined) {\n    return true;\n  }\n  if (pathStep.currency !== undefined || pathStep.issuer !== undefined) {\n    return true;\n  }\n  return false;\n}\nfunction isPath(path) {\n  for (const pathStep of path) {\n    if (!isPathStep(pathStep)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPaths(paths) {\n  if (!Array.isArray(paths) || paths.length === 0) {\n    return false;\n  }\n  for (const path of paths) {\n    if (!Array.isArray(path) || path.length === 0) {\n      return false;\n    }\n    if (!isPath(path)) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["errors_1","require","utils_1","common_1","PaymentFlags","exports","validatePayment","tx","validateBaseTransaction","Amount","undefined","ValidationError","isAmount","validateRequiredField","isAccount","validateOptionalField","isNumber","InvoiceID","Paths","isPaths","SendMax","checkPartialPayment","DeliverMin","Flags","flags","isTfPartialPayment","isFlagEnabled","tfPartialPayment","_a","isPathStep","pathStep","account","currency","issuer","isPath","path","paths","Array","isArray","length"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/models/transactions/payment.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { Amount, Path } from '../common'\nimport { isFlagEnabled } from '../utils'\n\nimport {\n  BaseTransaction,\n  isAmount,\n  GlobalFlags,\n  validateBaseTransaction,\n  isAccount,\n  validateRequiredField,\n  validateOptionalField,\n  isNumber,\n  Account,\n} from './common'\nimport type { TransactionMetadataBase } from './metadata'\n\n/**\n * Enum representing values for Payment Transaction Flags.\n *\n * @category Transaction Flags\n */\nexport enum PaymentFlags {\n  /**\n   * Do not use the default path; only use paths included in the Paths field.\n   * This is intended to force the transaction to take arbitrage opportunities.\n   * Most clients do not need this.\n   */\n  tfNoDirectRipple = 0x00010000,\n  /**\n   * If the specified Amount cannot be sent without spending more than SendMax,\n   * reduce the received amount instead of failing outright. See Partial.\n   * Payments for more details.\n   */\n  tfPartialPayment = 0x00020000,\n  /**\n   * Only take paths where all the conversions have an input:output ratio that\n   * is equal or better than the ratio of Amount:SendMax. See Limit Quality for\n   * details.\n   */\n  tfLimitQuality = 0x00040000,\n}\n\n/**\n * Map of flags to boolean values representing {@link Payment} transaction\n * flags.\n *\n * @category Transaction Flags\n *\n * @example\n * ```typescript\n * const partialPayment: Payment = {\n *  TransactionType: 'Payment',\n *  Account: 'rM9WCfJU6udpFkvKThRaFHDMsp7L8rpgN',\n *  Amount: {\n *    currency: 'FOO',\n *    value: '4000',\n *    issuer: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n *  },\n *  Destination: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n *  Flags: {\n *    tfPartialPayment: true\n *  }\n * }\n *\n * // Autofill the tx to see how flags actually look compared to the interface usage.\n * const autofilledTx = await client.autofill(partialPayment)\n * console.log(autofilledTx)\n * // {\n * //  TransactionType: 'Payment',\n * //  Account: 'rM9WCfJU6udpFkvKThRaFHDMsp7L8rpgN',\n * //  Amount: {\n * //   currency: 'FOO',\n * //   value: '4000',\n * //   issuer: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz'\n * //  },\n * //  Destination: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n * //  Flags: 131072,\n * //  Sequence: 21970996,\n * //  Fee: '12',\n * //  LastLedgerSequence: 21971016\n * // }\n * ```\n */\nexport interface PaymentFlagsInterface extends GlobalFlags {\n  /**\n   * Do not use the default path; only use paths included in the Paths field.\n   * This is intended to force the transaction to take arbitrage opportunities.\n   * Most clients do not need this.\n   */\n  tfNoDirectRipple?: boolean\n  /**\n   * If the specified Amount cannot be sent without spending more than SendMax,\n   * reduce the received amount instead of failing outright. See Partial.\n   * Payments for more details.\n   */\n  tfPartialPayment?: boolean\n  /**\n   * Only take paths where all the conversions have an input:output ratio that\n   * is equal or better than the ratio of Amount:SendMax. See Limit Quality for\n   * details.\n   */\n  tfLimitQuality?: boolean\n}\n\n/**\n * A Payment transaction represents a transfer of value from one account to\n * another.\n *\n * @category Transaction Models\n */\nexport interface Payment extends BaseTransaction {\n  TransactionType: 'Payment'\n  /**\n   * The amount of currency to deliver. For non-XRP amounts, the nested field\n   * names MUST be lower-case. If the tfPartialPayment flag is set, deliver up\n   * to this amount instead.\n   */\n  Amount: Amount\n  /** The unique address of the account receiving the payment. */\n  Destination: Account\n  /**\n   * Arbitrary tag that identifies the reason for the payment to the\n   * destination, or a hosted recipient to pay.\n   */\n  DestinationTag?: number\n  /**\n   * Arbitrary 256-bit hash representing a specific reason or identifier for\n   * this payment.\n   */\n  InvoiceID?: string\n  /**\n   * Array of payment paths to be used for this transaction. Must be omitted\n   * for XRP-to-XRP transactions.\n   */\n  Paths?: Path[]\n  /**\n   * Highest amount of source currency this transaction is allowed to cost,\n   * including transfer fees, exchange rates, and slippage . Does not include\n   * the XRP destroyed as a cost for submitting the transaction. For non-XRP\n   * amounts, the nested field names MUST be lower-case. Must be supplied for\n   * cross-currency/cross-issue payments. Must be omitted for XRP-to-XRP\n   * Payments.\n   */\n  SendMax?: Amount\n  /**\n   * Minimum amount of destination currency this transaction should deliver.\n   * Only valid if this is a partial payment. For non-XRP amounts, the nested\n   * field names are lower-case.\n   */\n  DeliverMin?: Amount\n  Flags?: number | PaymentFlagsInterface\n}\n\nexport interface PaymentMetadata extends TransactionMetadataBase {\n  DeliveredAmount?: Amount\n  delivered_amount?: Amount | 'unavailable'\n}\n\n/**\n * Verify the form and type of a Payment at runtime.\n *\n * @param tx - A Payment Transaction.\n * @throws When the Payment is malformed.\n */\nexport function validatePayment(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  if (tx.Amount === undefined) {\n    throw new ValidationError('PaymentTransaction: missing field Amount')\n  }\n\n  if (!isAmount(tx.Amount)) {\n    throw new ValidationError('PaymentTransaction: invalid Amount')\n  }\n\n  validateRequiredField(tx, 'Destination', isAccount)\n  validateOptionalField(tx, 'DestinationTag', isNumber)\n\n  if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {\n    throw new ValidationError('PaymentTransaction: InvoiceID must be a string')\n  }\n\n  if (\n    tx.Paths !== undefined &&\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n    !isPaths(tx.Paths as Array<Array<Record<string, unknown>>>)\n  ) {\n    throw new ValidationError('PaymentTransaction: invalid Paths')\n  }\n\n  if (tx.SendMax !== undefined && !isAmount(tx.SendMax)) {\n    throw new ValidationError('PaymentTransaction: invalid SendMax')\n  }\n\n  checkPartialPayment(tx)\n}\n\nfunction checkPartialPayment(tx: Record<string, unknown>): void {\n  if (tx.DeliverMin != null) {\n    if (tx.Flags == null) {\n      throw new ValidationError(\n        'PaymentTransaction: tfPartialPayment flag required with DeliverMin',\n      )\n    }\n\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n    const flags = tx.Flags as number | PaymentFlagsInterface\n    const isTfPartialPayment =\n      typeof flags === 'number'\n        ? isFlagEnabled(flags, PaymentFlags.tfPartialPayment)\n        : flags.tfPartialPayment ?? false\n\n    if (!isTfPartialPayment) {\n      throw new ValidationError(\n        'PaymentTransaction: tfPartialPayment flag required with DeliverMin',\n      )\n    }\n\n    if (!isAmount(tx.DeliverMin)) {\n      throw new ValidationError('PaymentTransaction: invalid DeliverMin')\n    }\n  }\n}\n\nfunction isPathStep(pathStep: Record<string, unknown>): boolean {\n  if (pathStep.account !== undefined && typeof pathStep.account !== 'string') {\n    return false\n  }\n  if (\n    pathStep.currency !== undefined &&\n    typeof pathStep.currency !== 'string'\n  ) {\n    return false\n  }\n  if (pathStep.issuer !== undefined && typeof pathStep.issuer !== 'string') {\n    return false\n  }\n  if (\n    pathStep.account !== undefined &&\n    pathStep.currency === undefined &&\n    pathStep.issuer === undefined\n  ) {\n    return true\n  }\n  if (pathStep.currency !== undefined || pathStep.issuer !== undefined) {\n    return true\n  }\n  return false\n}\n\nfunction isPath(path: Array<Record<string, unknown>>): boolean {\n  for (const pathStep of path) {\n    if (!isPathStep(pathStep)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isPaths(paths: Array<Array<Record<string, unknown>>>): boolean {\n  if (!Array.isArray(paths) || paths.length === 0) {\n    return false\n  }\n\n  for (const path of paths) {\n    if (!Array.isArray(path) || path.length === 0) {\n      return false\n    }\n\n    if (!isPath(path)) {\n      return false\n    }\n  }\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}