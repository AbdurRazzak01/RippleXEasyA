{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst defaultFaucets_1 = require(\"./defaultFaucets\");\nconst _1 = require(\".\");\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\nfunction generateWalletToFund(wallet) {\n  if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {\n    return wallet;\n  }\n  return _1.Wallet.generate();\n}\nexports.generateWalletToFund = generateWalletToFund;\nfunction getStartingBalance(client, classicAddress) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let startingBalance = 0;\n    try {\n      startingBalance = Number(yield client.getXrpBalance(classicAddress));\n    } catch (_a) {}\n    return startingBalance;\n  });\n}\nexports.getStartingBalance = getStartingBalance;\nfunction requestFunding(options, client, startingBalance, walletToFund, postBody) {\n  var _a, _b, _c;\n  return __awaiter(this, void 0, void 0, function* () {\n    const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);\n    if (!hostname) {\n      throw new errors_1.XRPLFaucetError('No faucet hostname could be derived');\n    }\n    const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);\n    const response = yield (0, cross_fetch_1.default)(`https://${hostname}${pathname}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(postBody)\n    });\n    const body = yield response.json();\n    if (response.ok && ((_c = response.headers.get('Content-Type')) === null || _c === void 0 ? void 0 : _c.startsWith('application/json'))) {\n      const classicAddress = body.account.classicAddress;\n      return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);\n    }\n    return processError(response, body);\n  });\n}\nexports.requestFunding = requestFunding;\nfunction processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!classicAddress) {\n      return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));\n    }\n    try {\n      const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);\n      if (updatedBalance > startingBalance) {\n        return {\n          wallet: walletToFund,\n          balance: updatedBalance\n        };\n      }\n      throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new errors_1.XRPLFaucetError(err.message);\n      }\n      throw err;\n    }\n  });\n}\nfunction processError(response, body) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify({\n      body: body || {},\n      contentType: response.headers.get('Content-Type'),\n      statusCode: response.status\n    })}`));\n  });\n}\nfunction getUpdatedBalance(client, address, originalBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let attempts = MAX_ATTEMPTS;\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        if (attempts < 0) {\n          clearInterval(interval);\n          resolve(originalBalance);\n        } else {\n          attempts -= 1;\n        }\n        try {\n          let newBalance;\n          try {\n            newBalance = Number(yield client.getXrpBalance(address));\n          } catch (_a) {}\n          if (newBalance > originalBalance) {\n            clearInterval(interval);\n            resolve(newBalance);\n          }\n        } catch (err) {\n          clearInterval(interval);\n          if (err instanceof Error) {\n            reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));\n          }\n          reject(err);\n        }\n      }), INTERVAL_SECONDS * 1000);\n    });\n  });\n}","map":{"version":3,"names":["cross_fetch_1","__importDefault","require","ripple_address_codec_1","errors_1","defaultFaucets_1","_1","INTERVAL_SECONDS","MAX_ATTEMPTS","generateWalletToFund","wallet","isValidClassicAddress","classicAddress","Wallet","generate","exports","getStartingBalance","client","startingBalance","Number","getXrpBalance","_a","requestFunding","options","walletToFund","postBody","hostname","faucetHost","getFaucetHost","XRPLFaucetError","pathname","_b","faucetPath","getDefaultFaucetPath","response","default","method","headers","body","JSON","stringify","json","ok","_c","get","startsWith","account","processSuccessfulResponse","processError","Promise","reject","updatedBalance","getUpdatedBalance","balance","err","Error","message","contentType","statusCode","status","address","originalBalance","resolve","attempts","interval","setInterval","__awaiter","clearInterval","newBalance"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/Wallet/fundWallet.ts"],"sourcesContent":["import fetch from 'cross-fetch'\nimport { isValidClassicAddress } from 'ripple-address-codec'\n\nimport type { Client } from '../client'\nimport { XRPLFaucetError } from '../errors'\n\nimport {\n  FaucetWallet,\n  getFaucetHost,\n  getDefaultFaucetPath,\n} from './defaultFaucets'\n\nimport { Wallet } from '.'\n\n// Interval to check an account balance\nconst INTERVAL_SECONDS = 1\n// Maximum attempts to retrieve a balance\nconst MAX_ATTEMPTS = 20\n\nexport interface FundingOptions {\n  /**\n   *  A custom amount to fund, if undefined or null, the default amount will be 1000.\n   */\n  amount?: string\n  /**\n   * A custom host for a faucet server. On devnet, testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct server automatically. In other environments, or if you would like to customize\n   * the faucet host in devnet or testnet, you should provide the host using this option.\n   */\n  faucetHost?: string\n  /**\n   * A custom path for a faucet server. On devnet,\n   * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct path automatically. In other environments,\n   * or if you would like to customize the faucet path in devnet or testnet,\n   * you should provide the path using this option.\n   * Ex: client.fundWallet(null,{'faucet.altnet.rippletest.net', '/accounts'})\n   * specifies a request to 'faucet.altnet.rippletest.net/accounts' to fund a new wallet.\n   */\n  faucetPath?: string\n  /**\n   * An optional field to indicate the use case context of the faucet transaction\n   * Ex: integration test, code snippets.\n   */\n  usageContext?: string\n}\n\n/**\n * Parameters to pass into a faucet request to fund an XRP account.\n */\nexport interface FaucetRequestBody {\n  /**\n   * The address to fund. If no address is provided the faucet will fund a random account.\n   */\n  destination?: string\n  /**\n   * The total amount of XRP to fund the account with.\n   */\n  xrpAmount?: string\n  /**\n   * An optional field to indicate the use case context of the faucet transaction\n   * Ex: integration test, code snippets.\n   */\n  usageContext?: string\n  /**\n   * Information about the context of where the faucet is being called from.\n   * Ex: xrpl.js or xrpl-py\n   */\n  userAgent: string\n}\n\n/**\n * Generate a new wallet to fund if no existing wallet is provided or its address is invalid.\n *\n * @param wallet - Optional existing wallet.\n * @returns The wallet to fund.\n */\nexport function generateWalletToFund(wallet?: Wallet | null): Wallet {\n  if (wallet && isValidClassicAddress(wallet.classicAddress)) {\n    return wallet\n  }\n  return Wallet.generate()\n}\n\n/**\n * Get the starting balance of the wallet.\n *\n * @param client - The client object.\n * @param classicAddress - The classic address of the wallet.\n * @returns The starting balance.\n */\nexport async function getStartingBalance(\n  client: Client,\n  classicAddress: string,\n): Promise<number> {\n  let startingBalance = 0\n  try {\n    startingBalance = Number(await client.getXrpBalance(classicAddress))\n  } catch {\n    // startingBalance remains '0'\n  }\n  return startingBalance\n}\n\nexport interface FundWalletOptions {\n  faucetHost?: string\n  faucetPath?: string\n  amount?: string\n  usageContext?: string\n}\n\n/**\n *\n * Helper function to request funding from a faucet. Should not be called directly from outside the xrpl.js library.\n *\n * @param options - See below\n * @param options.faucetHost - A custom host for a faucet server. On devnet,\n * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n * attempt to determine the correct server automatically. In other environments,\n * or if you would like to customize the faucet host in devnet or testnet,\n * you should provide the host using this option.\n * @param options.faucetPath - A custom path for a faucet server. On devnet,\n * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n * attempt to determine the correct path automatically. In other environments,\n * or if you would like to customize the faucet path in devnet or testnet,\n * you should provide the path using this option.\n * Ex: client.fundWallet(null,{'faucet.altnet.rippletest.net', '/accounts'})\n * specifies a request to 'faucet.altnet.rippletest.net/accounts' to fund a new wallet.\n * @param options.amount - A custom amount to fund, if undefined or null, the default amount will be 1000.\n * @param client - A connection to the XRPL to send requests and transactions.\n * @param startingBalance - The amount of XRP in the given walletToFund on ledger already.\n * @param walletToFund - An existing XRPL Wallet to fund.\n * @param postBody - The content to send the faucet to indicate which address to fund, how much to fund it, and\n * where the request is coming from.\n * @returns A promise that resolves to a funded wallet and the balance within it.\n */\n// eslint-disable-next-line max-params -- Helper function created for organizational purposes\nexport async function requestFunding(\n  options: FundingOptions,\n  client: Client,\n  startingBalance: number,\n  walletToFund: Wallet,\n  postBody: FaucetRequestBody,\n): Promise<{\n  wallet: Wallet\n  balance: number\n}> {\n  const hostname = options.faucetHost ?? getFaucetHost(client)\n  if (!hostname) {\n    throw new XRPLFaucetError('No faucet hostname could be derived')\n  }\n  const pathname = options.faucetPath ?? getDefaultFaucetPath(hostname)\n  const response = await fetch(`https://${hostname}${pathname}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(postBody),\n  })\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- it can be anything\n  const body = await response.json()\n  if (\n    response.ok &&\n    response.headers.get('Content-Type')?.startsWith('application/json')\n  ) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- It's a FaucetWallet\n    const classicAddress = (body as FaucetWallet).account.classicAddress\n    return processSuccessfulResponse(\n      client,\n      classicAddress,\n      walletToFund,\n      startingBalance,\n    )\n  }\n  return processError(response, body)\n}\n\n// eslint-disable-next-line max-params -- Only used as a helper function, lines inc due to added balance.\nasync function processSuccessfulResponse(\n  client: Client,\n  classicAddress: string | undefined,\n  walletToFund: Wallet,\n  startingBalance: number,\n): Promise<{\n  wallet: Wallet\n  balance: number\n}> {\n  if (!classicAddress) {\n    return Promise.reject(\n      new XRPLFaucetError(`The faucet account is undefined`),\n    )\n  }\n  try {\n    // Check at regular interval if the address is enabled on the XRPL and funded\n    const updatedBalance = await getUpdatedBalance(\n      client,\n      classicAddress,\n      startingBalance,\n    )\n\n    if (updatedBalance > startingBalance) {\n      return {\n        wallet: walletToFund,\n        balance: updatedBalance,\n      }\n    }\n    throw new XRPLFaucetError(\n      `Unable to fund address with faucet after waiting ${\n        INTERVAL_SECONDS * MAX_ATTEMPTS\n      } seconds`,\n    )\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new XRPLFaucetError(err.message)\n    }\n    throw err\n  }\n}\n\nasync function processError(response: Response, body): Promise<never> {\n  return Promise.reject(\n    new XRPLFaucetError(\n      `Request failed: ${JSON.stringify({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- json response could be anything\n        body: body || {},\n        contentType: response.headers.get('Content-Type'),\n        statusCode: response.status,\n      })}`,\n    ),\n  )\n}\n\n/**\n * Check at regular interval if the address is enabled on the XRPL and funded.\n *\n * @param client - Client.\n * @param address - The account address to check.\n * @param originalBalance - The initial balance before the funding.\n * @returns A Promise boolean.\n */\nasync function getUpdatedBalance(\n  client: Client,\n  address: string,\n  originalBalance: number,\n): Promise<number> {\n  return new Promise((resolve, reject) => {\n    let attempts = MAX_ATTEMPTS\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Not actually misused here, different resolve\n    const interval = setInterval(async () => {\n      if (attempts < 0) {\n        clearInterval(interval)\n        resolve(originalBalance)\n      } else {\n        attempts -= 1\n      }\n\n      try {\n        let newBalance\n        try {\n          newBalance = Number(await client.getXrpBalance(address))\n        } catch {\n          /* newBalance remains undefined */\n        }\n\n        if (newBalance > originalBalance) {\n          clearInterval(interval)\n          resolve(newBalance)\n        }\n      } catch (err) {\n        clearInterval(interval)\n        if (err instanceof Error) {\n          reject(\n            new XRPLFaucetError(\n              `Unable to check if the address ${address} balance has increased. Error: ${err.message}`,\n            ),\n          )\n        }\n        reject(err)\n      }\n    }, INTERVAL_SECONDS * 1000)\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}