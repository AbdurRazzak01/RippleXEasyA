{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nfunction randomEntropy() {\n  return (0, utils_1.randomBytes)(16);\n}\nexports.randomEntropy = randomEntropy;\nfunction calculateChecksum(position, value) {\n  return value * (position * 2 + 1) % 9;\n}\nexports.calculateChecksum = calculateChecksum;\nfunction checkChecksum(position, value, checksum) {\n  let normalizedChecksum;\n  let normalizedValue;\n  if (typeof value === 'string') {\n    if (value.length !== 6) {\n      throw new Error('value must have a length of 6');\n    }\n    normalizedChecksum = parseInt(value.slice(5), 10);\n    normalizedValue = parseInt(value.slice(0, 5), 10);\n  } else {\n    if (typeof checksum !== 'number') {\n      throw new Error('checksum must be a number when value is a number');\n    }\n    normalizedChecksum = checksum;\n    normalizedValue = value;\n  }\n  return normalizedValue * (position * 2 + 1) % 9 === normalizedChecksum;\n}\nexports.checkChecksum = checkChecksum;\nfunction entropyToSecret(entropy) {\n  const len = new Array(Math.ceil(entropy.length / 2));\n  const chunks = Array.from(len, (_a, chunk) => {\n    const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);\n    const no = parseInt((0, utils_1.bytesToHex)(buffChunk), 16);\n    const fill = '0'.repeat(5 - String(no).length);\n    return fill + String(no) + String(calculateChecksum(chunk, no));\n  });\n  if (chunks.length !== 8) {\n    throw new Error('Chucks must have 8 digits');\n  }\n  return chunks;\n}\nexports.entropyToSecret = entropyToSecret;\nfunction randomSecret() {\n  return entropyToSecret(randomEntropy());\n}\nexports.randomSecret = randomSecret;\nfunction secretToEntropy(secret) {\n  return (0, utils_1.concat)(secret.map((chunk, i) => {\n    const no = Number(chunk.slice(0, 5));\n    const checksum = Number(chunk.slice(5));\n    if (chunk.length !== 6) {\n      throw new Error('Invalid secret: number invalid');\n    }\n    if (!checkChecksum(i, no, checksum)) {\n      throw new Error('Invalid secret part: checksum invalid');\n    }\n    const hex = `0000${no.toString(16)}`.slice(-4);\n    return (0, utils_1.hexToBytes)(hex);\n  }));\n}\nexports.secretToEntropy = secretToEntropy;\nfunction parseSecretString(secret) {\n  const normalizedSecret = secret.replace(/[^0-9]/gu, '');\n  if (normalizedSecret.length !== 48) {\n    throw new Error('Invalid secret string (should contain 8 blocks of 6 digits');\n  }\n  return Array.from(new Array(8), (_a, index) => {\n    return normalizedSecret.slice(index * 6, (index + 1) * 6);\n  });\n}\nexports.parseSecretString = parseSecretString;","map":{"version":3,"names":["utils_1","require","randomEntropy","randomBytes","exports","calculateChecksum","position","value","checkChecksum","checksum","normalizedChecksum","normalizedValue","length","Error","parseInt","slice","entropyToSecret","entropy","len","Array","Math","ceil","chunks","from","_a","chunk","buffChunk","no","bytesToHex","fill","repeat","String","randomSecret","secretToEntropy","secret","concat","map","i","Number","hex","toString","hexToBytes","parseSecretString","normalizedSecret","replace","index"],"sources":["/Users/mdabdurrazzak/node_modules/@xrplf/secret-numbers/src/utils/index.ts"],"sourcesContent":["import {\n  bytesToHex,\n  concat,\n  hexToBytes,\n  randomBytes,\n} from '@xrplf/isomorphic/utils'\n\nfunction randomEntropy(): Uint8Array {\n  return randomBytes(16)\n}\n\nfunction calculateChecksum(position: number, value: number): number {\n  return (value * (position * 2 + 1)) % 9\n}\n\nfunction checkChecksum(\n  position: number,\n  value: number | string,\n  checksum?: number,\n): boolean {\n  let normalizedChecksum: number\n  let normalizedValue: number\n\n  if (typeof value === 'string') {\n    if (value.length !== 6) {\n      throw new Error('value must have a length of 6')\n    }\n    normalizedChecksum = parseInt(value.slice(5), 10)\n    normalizedValue = parseInt(value.slice(0, 5), 10)\n  } else {\n    if (typeof checksum !== 'number') {\n      throw new Error('checksum must be a number when value is a number')\n    }\n    normalizedChecksum = checksum\n    normalizedValue = value\n  }\n  return (normalizedValue * (position * 2 + 1)) % 9 === normalizedChecksum\n}\n\nfunction entropyToSecret(entropy: Uint8Array): string[] {\n  const len = new Array(Math.ceil(entropy.length / 2))\n  const chunks = Array.from(len, (_a, chunk) => {\n    const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2)\n    const no = parseInt(bytesToHex(buffChunk), 16)\n    const fill = '0'.repeat(5 - String(no).length)\n    return fill + String(no) + String(calculateChecksum(chunk, no))\n  })\n  if (chunks.length !== 8) {\n    throw new Error('Chucks must have 8 digits')\n  }\n  return chunks\n}\n\nfunction randomSecret(): string[] {\n  return entropyToSecret(randomEntropy())\n}\n\nfunction secretToEntropy(secret: string[]): Uint8Array {\n  return concat(\n    secret.map((chunk, i) => {\n      const no = Number(chunk.slice(0, 5))\n      const checksum = Number(chunk.slice(5))\n      if (chunk.length !== 6) {\n        throw new Error('Invalid secret: number invalid')\n      }\n      if (!checkChecksum(i, no, checksum)) {\n        throw new Error('Invalid secret part: checksum invalid')\n      }\n      const hex = `0000${no.toString(16)}`.slice(-4)\n      return hexToBytes(hex)\n    }),\n  )\n}\n\nfunction parseSecretString(secret: string): string[] {\n  const normalizedSecret = secret.replace(/[^0-9]/gu, '')\n  if (normalizedSecret.length !== 48) {\n    throw new Error(\n      'Invalid secret string (should contain 8 blocks of 6 digits',\n    )\n  }\n  return Array.from(new Array(8), (_a, index) => {\n    return normalizedSecret.slice(index * 6, (index + 1) * 6)\n  })\n}\n\nexport {\n  randomEntropy,\n  randomSecret,\n  entropyToSecret,\n  secretToEntropy,\n  calculateChecksum,\n  checkChecksum,\n  parseSecretString,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}