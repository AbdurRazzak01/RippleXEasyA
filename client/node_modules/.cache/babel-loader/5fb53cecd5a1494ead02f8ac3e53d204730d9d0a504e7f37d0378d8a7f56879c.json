{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hash = void 0;\nconst serialized_type_1 = require(\"./serialized-type\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst utils_2 = require(\"../utils\");\n/**\n * Base class defining how to encode and decode hashes\n */\nclass Hash extends serialized_type_1.Comparable {\n  constructor(bytes) {\n    super(bytes);\n    if (this.bytes.length !== this.constructor.width) {\n      throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);\n    }\n  }\n  /**\n   * Construct a Hash object from an existing Hash object or a hex-string\n   *\n   * @param value A hash object or hex-string of a hash\n   */\n  static from(value) {\n    if (value instanceof this) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      return new this((0, utils_1.hexToBytes)(value));\n    }\n    throw new Error('Cannot construct Hash from given value');\n  }\n  /**\n   * Read a Hash object from a BinaryParser\n   *\n   * @param parser BinaryParser to read the hash from\n   * @param hint length of the bytes to read, optional\n   */\n  static fromParser(parser, hint) {\n    return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));\n  }\n  /**\n   * Overloaded operator for comparing two hash objects\n   *\n   * @param other The Hash to compare this to\n   */\n  compareTo(other) {\n    return (0, utils_2.compare)(this.bytes, this.constructor.from(other).bytes);\n  }\n  /**\n   * @returns the hex-string representation of this Hash\n   */\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * Returns four bits at the specified depth within a hash\n   *\n   * @param depth The depth of the four bits\n   * @returns The number represented by the four bits\n   */\n  nibblet(depth) {\n    const byteIx = depth > 0 ? depth / 2 | 0 : 0;\n    let b = this.bytes[byteIx];\n    if (depth % 2 === 0) {\n      b = (b & 0xf0) >>> 4;\n    } else {\n      b = b & 0x0f;\n    }\n    return b;\n  }\n}\nexports.Hash = Hash;","map":{"version":3,"names":["serialized_type_1","require","utils_1","utils_2","Hash","Comparable","constructor","bytes","length","width","Error","byteLength","from","value","hexToBytes","fromParser","parser","hint","read","compareTo","other","compare","toString","toHex","nibblet","depth","byteIx","b","exports"],"sources":["/Users/mdabdurrazzak/node_modules/ripple-binary-codec/src/types/hash.ts"],"sourcesContent":["import { Comparable } from './serialized-type'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { hexToBytes } from '@xrplf/isomorphic/utils'\nimport { compare } from '../utils'\n\n/**\n * Base class defining how to encode and decode hashes\n */\nclass Hash extends Comparable<Hash | string> {\n  static readonly width: number\n\n  constructor(bytes: Uint8Array) {\n    super(bytes)\n    if (this.bytes.length !== (this.constructor as typeof Hash).width) {\n      throw new Error(`Invalid Hash length ${this.bytes.byteLength}`)\n    }\n  }\n\n  /**\n   * Construct a Hash object from an existing Hash object or a hex-string\n   *\n   * @param value A hash object or hex-string of a hash\n   */\n  static from<T extends Hash | string>(value: T): Hash {\n    if (value instanceof this) {\n      return value\n    }\n\n    if (typeof value === 'string') {\n      return new this(hexToBytes(value))\n    }\n\n    throw new Error('Cannot construct Hash from given value')\n  }\n\n  /**\n   * Read a Hash object from a BinaryParser\n   *\n   * @param parser BinaryParser to read the hash from\n   * @param hint length of the bytes to read, optional\n   */\n  static fromParser(parser: BinaryParser, hint?: number): Hash {\n    return new this(parser.read(hint ?? this.width))\n  }\n\n  /**\n   * Overloaded operator for comparing two hash objects\n   *\n   * @param other The Hash to compare this to\n   */\n  compareTo(other: Hash): number {\n    return compare(\n      this.bytes,\n      (this.constructor as typeof Hash).from(other).bytes,\n    )\n  }\n\n  /**\n   * @returns the hex-string representation of this Hash\n   */\n  toString(): string {\n    return this.toHex()\n  }\n\n  /**\n   * Returns four bits at the specified depth within a hash\n   *\n   * @param depth The depth of the four bits\n   * @returns The number represented by the four bits\n   */\n  nibblet(depth: number): number {\n    const byteIx = depth > 0 ? (depth / 2) | 0 : 0\n    let b = this.bytes[byteIx]\n    if (depth % 2 === 0) {\n      b = (b & 0xf0) >>> 4\n    } else {\n      b = b & 0x0f\n    }\n    return b\n  }\n}\n\nexport { Hash }\n"],"mappings":";;;;;;AAAA,MAAAA,iBAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAEA;;;AAGA,MAAMG,IAAK,SAAQJ,iBAAA,CAAAK,UAAyB;EAG1CC,YAAYC,KAAiB;IAC3B,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,IAAI,CAACA,KAAK,CAACC,MAAM,KAAM,IAAI,CAACF,WAA2B,CAACG,KAAK,EAAE;MACjE,MAAM,IAAIC,KAAK,CAAC,uBAAuB,IAAI,CAACH,KAAK,CAACI,UAAU,EAAE,CAAC;;EAEnE;EAEA;;;;;EAKA,OAAOC,IAAIA,CAA0BC,KAAQ;IAC3C,IAAIA,KAAK,YAAY,IAAI,EAAE;MACzB,OAAOA,KAAK;;IAGd,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,OAAO,IAAI,IAAI,CAAC,IAAAX,OAAA,CAAAY,UAAU,EAACD,KAAK,CAAC,CAAC;;IAGpC,MAAM,IAAIH,KAAK,CAAC,wCAAwC,CAAC;EAC3D;EAEA;;;;;;EAMA,OAAOK,UAAUA,CAACC,MAAoB,EAAEC,IAAa;IACnD,OAAO,IAAI,IAAI,CAACD,MAAM,CAACE,IAAI,CAACD,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI,IAAI,CAACR,KAAK,CAAC,CAAC;EAClD;EAEA;;;;;EAKAU,SAASA,CAACC,KAAW;IACnB,OAAO,IAAAjB,OAAA,CAAAkB,OAAO,EACZ,IAAI,CAACd,KAAK,EACT,IAAI,CAACD,WAA2B,CAACM,IAAI,CAACQ,KAAK,CAAC,CAACb,KAAK,CACpD;EACH;EAEA;;;EAGAe,QAAQA,CAAA;IACN,OAAO,IAAI,CAACC,KAAK,EAAE;EACrB;EAEA;;;;;;EAMAC,OAAOA,CAACC,KAAa;IACnB,MAAMC,MAAM,GAAGD,KAAK,GAAG,CAAC,GAAIA,KAAK,GAAG,CAAC,GAAI,CAAC,GAAG,CAAC;IAC9C,IAAIE,CAAC,GAAG,IAAI,CAACpB,KAAK,CAACmB,MAAM,CAAC;IAC1B,IAAID,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE;MACnBE,CAAC,GAAG,CAACA,CAAC,GAAG,IAAI,MAAM,CAAC;KACrB,MAAM;MACLA,CAAC,GAAGA,CAAC,GAAG,IAAI;;IAEd,OAAOA,CAAC;EACV;;AAGOC,OAAA,CAAAxB,IAAA,GAAAA,IAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}