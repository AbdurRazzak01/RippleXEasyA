{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.multisign = exports.verifySignature = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nfunction multisign(transactions) {\n  if (transactions.length === 0) {\n    throw new errors_1.ValidationError('There were 0 transactions to multisign');\n  }\n  const decodedTransactions = transactions.map(txOrBlob => {\n    return getDecodedTransaction(txOrBlob);\n  });\n  decodedTransactions.forEach(tx => {\n    (0, transactions_1.validate)(tx);\n    if (tx.Signers == null || tx.Signers.length === 0) {\n      throw new errors_1.ValidationError(\"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\");\n    }\n    if (tx.SigningPubKey !== '') {\n      throw new errors_1.ValidationError('SigningPubKey must be an empty string for all transactions when multisigning.');\n    }\n  });\n  validateTransactionEquivalence(decodedTransactions);\n  return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));\n}\nexports.multisign = multisign;\nfunction verifySignature(tx, publicKey) {\n  const decodedTx = getDecodedTransaction(tx);\n  let key = publicKey;\n  if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n    throw new Error('Transaction is missing a signature, TxnSignature');\n  }\n  if (!key) {\n    if (typeof decodedTx.SigningPubKey !== 'string' || !decodedTx.SigningPubKey) {\n      throw new Error('Transaction is missing a public key, SigningPubKey');\n    }\n    key = decodedTx.SigningPubKey;\n  }\n  return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);\n}\nexports.verifySignature = verifySignature;\nfunction validateTransactionEquivalence(transactions) {\n  const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), {\n    Signers: null\n  }));\n  if (transactions.slice(1).some(tx => JSON.stringify(Object.assign(Object.assign({}, tx), {\n    Signers: null\n  })) !== exampleTransaction)) {\n    throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');\n  }\n}\nfunction getTransactionWithAllSigners(transactions) {\n  const sortedSigners = transactions.flatMap(tx => {\n    var _a;\n    return (_a = tx.Signers) !== null && _a !== void 0 ? _a : [];\n  }).sort(compareSigners);\n  return Object.assign(Object.assign({}, transactions[0]), {\n    Signers: sortedSigners\n  });\n}\nfunction compareSigners(left, right) {\n  return addressToBigNumber(left.Signer.Account).comparedTo(addressToBigNumber(right.Signer.Account));\n}\nconst NUM_BITS_IN_HEX = 16;\nfunction addressToBigNumber(address) {\n  const hex = (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));\n  return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);\n}\nfunction getDecodedTransaction(txOrBlob) {\n  if (typeof txOrBlob === 'object') {\n    return (0, ripple_binary_codec_1.decode)((0, ripple_binary_codec_1.encode)(txOrBlob));\n  }\n  return (0, ripple_binary_codec_1.decode)(txOrBlob);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","multisign","verifySignature","utils_1","require","bignumber_js_1","ripple_address_codec_1","ripple_binary_codec_1","ripple_keypairs_1","errors_1","transactions_1","transactions","length","ValidationError","decodedTransactions","map","txOrBlob","getDecodedTransaction","forEach","tx","validate","Signers","SigningPubKey","validateTransactionEquivalence","encode","getTransactionWithAllSigners","publicKey","decodedTx","key","TxnSignature","Error","verify","encodeForSigning","exampleTransaction","JSON","stringify","assign","slice","some","sortedSigners","flatMap","_a","sort","compareSigners","left","right","addressToBigNumber","Signer","Account","comparedTo","NUM_BITS_IN_HEX","address","hex","bytesToHex","decodeAccountID","BigNumber","decode"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/dist/npm/Wallet/signer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.multisign = exports.verifySignature = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nfunction multisign(transactions) {\n    if (transactions.length === 0) {\n        throw new errors_1.ValidationError('There were 0 transactions to multisign');\n    }\n    const decodedTransactions = transactions.map((txOrBlob) => {\n        return getDecodedTransaction(txOrBlob);\n    });\n    decodedTransactions.forEach((tx) => {\n        (0, transactions_1.validate)(tx);\n        if (tx.Signers == null || tx.Signers.length === 0) {\n            throw new errors_1.ValidationError(\"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\");\n        }\n        if (tx.SigningPubKey !== '') {\n            throw new errors_1.ValidationError('SigningPubKey must be an empty string for all transactions when multisigning.');\n        }\n    });\n    validateTransactionEquivalence(decodedTransactions);\n    return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));\n}\nexports.multisign = multisign;\nfunction verifySignature(tx, publicKey) {\n    const decodedTx = getDecodedTransaction(tx);\n    let key = publicKey;\n    if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n        throw new Error('Transaction is missing a signature, TxnSignature');\n    }\n    if (!key) {\n        if (typeof decodedTx.SigningPubKey !== 'string' ||\n            !decodedTx.SigningPubKey) {\n            throw new Error('Transaction is missing a public key, SigningPubKey');\n        }\n        key = decodedTx.SigningPubKey;\n    }\n    return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);\n}\nexports.verifySignature = verifySignature;\nfunction validateTransactionEquivalence(transactions) {\n    const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));\n    if (transactions\n        .slice(1)\n        .some((tx) => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {\n        throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');\n    }\n}\nfunction getTransactionWithAllSigners(transactions) {\n    const sortedSigners = transactions\n        .flatMap((tx) => { var _a; return (_a = tx.Signers) !== null && _a !== void 0 ? _a : []; })\n        .sort(compareSigners);\n    return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });\n}\nfunction compareSigners(left, right) {\n    return addressToBigNumber(left.Signer.Account).comparedTo(addressToBigNumber(right.Signer.Account));\n}\nconst NUM_BITS_IN_HEX = 16;\nfunction addressToBigNumber(address) {\n    const hex = (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));\n    return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);\n}\nfunction getDecodedTransaction(txOrBlob) {\n    if (typeof txOrBlob === 'object') {\n        return (0, ripple_binary_codec_1.decode)((0, ripple_binary_codec_1.encode)(txOrBlob));\n    }\n    return (0, ripple_binary_codec_1.decode)(txOrBlob);\n}\n//# sourceMappingURL=signer.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}