{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Comparable = exports.SerializedType = void 0;\nconst binary_serializer_1 = require(\"../serdes/binary-serializer\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * The base class for all binary-codec types\n */\nclass SerializedType {\n  constructor(bytes) {\n    this.bytes = new Uint8Array(0);\n    this.bytes = bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);\n  }\n  static fromParser(parser, hint) {\n    throw new Error('fromParser not implemented');\n    return this.fromParser(parser, hint);\n  }\n  static from(value) {\n    throw new Error('from not implemented');\n    return this.from(value);\n  }\n  /**\n   * Write the bytes representation of a SerializedType to a BytesList\n   *\n   * @param list The BytesList to write SerializedType bytes to\n   */\n  toBytesSink(list) {\n    list.put(this.bytes);\n  }\n  /**\n   * Get the hex representation of a SerializedType's bytes\n   *\n   * @returns hex String of this.bytes\n   */\n  toHex() {\n    return (0, utils_1.bytesToHex)(this.toBytes());\n  }\n  /**\n   * Get the bytes representation of a SerializedType\n   *\n   * @returns A Uint8Array of the bytes\n   */\n  toBytes() {\n    if (this.bytes) {\n      return this.bytes;\n    }\n    const bytes = new binary_serializer_1.BytesList();\n    this.toBytesSink(bytes);\n    return bytes.toBytes();\n  }\n  /**\n   * Return the JSON representation of a SerializedType\n   *\n   * @param _definitions rippled definitions used to parse the values of transaction types and such.\n   *                          Unused in default, but used in STObject, STArray\n   *                          Can be customized for sidechains and amendments.\n   * @returns any type, if not overloaded returns hexString representation of bytes\n   */\n  toJSON(_definitions) {\n    return this.toHex();\n  }\n  /**\n   * @returns hexString representation of this.bytes\n   */\n  toString() {\n    return this.toHex();\n  }\n}\nexports.SerializedType = SerializedType;\n/**\n * Base class for SerializedTypes that are comparable.\n *\n * @template T - What types you want to allow comparisons between. You must specify all types. Primarily used to allow\n * comparisons between built-in types (like `string`) and SerializedType subclasses (like `Hash`).\n *\n * Ex. `class Hash extends Comparable<Hash | string>`\n */\nclass Comparable extends SerializedType {\n  lt(other) {\n    return this.compareTo(other) < 0;\n  }\n  eq(other) {\n    return this.compareTo(other) === 0;\n  }\n  gt(other) {\n    return this.compareTo(other) > 0;\n  }\n  gte(other) {\n    return this.compareTo(other) > -1;\n  }\n  lte(other) {\n    return this.compareTo(other) < 1;\n  }\n  /**\n   * Overload this method to define how two Comparable SerializedTypes are compared\n   *\n   * @param other The comparable object to compare this to\n   * @returns A number denoting the relationship of this and other\n   */\n  compareTo(other) {\n    throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);\n  }\n}\nexports.Comparable = Comparable;","map":{"version":3,"names":["binary_serializer_1","require","utils_1","SerializedType","constructor","bytes","Uint8Array","fromParser","parser","hint","Error","from","value","toBytesSink","list","put","toHex","bytesToHex","toBytes","BytesList","toJSON","_definitions","toString","exports","Comparable","lt","other","compareTo","eq","gt","gte","lte"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/types/serialized-type.ts"],"sourcesContent":["import { BytesList } from '../serdes/binary-serializer'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { XrplDefinitionsBase } from '../enums'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\ntype JSON = string | number | boolean | null | undefined | JSON[] | JsonObject\n\ntype JsonObject = { [key: string]: JSON }\n\n/**\n * The base class for all binary-codec types\n */\nclass SerializedType {\n  protected readonly bytes: Uint8Array = new Uint8Array(0)\n\n  constructor(bytes?: Uint8Array) {\n    this.bytes = bytes ?? new Uint8Array(0)\n  }\n\n  static fromParser(parser: BinaryParser, hint?: number): SerializedType {\n    throw new Error('fromParser not implemented')\n    return this.fromParser(parser, hint)\n  }\n\n  static from(value: SerializedType | JSON | bigint): SerializedType {\n    throw new Error('from not implemented')\n    return this.from(value)\n  }\n\n  /**\n   * Write the bytes representation of a SerializedType to a BytesList\n   *\n   * @param list The BytesList to write SerializedType bytes to\n   */\n  toBytesSink(list: BytesList): void {\n    list.put(this.bytes)\n  }\n\n  /**\n   * Get the hex representation of a SerializedType's bytes\n   *\n   * @returns hex String of this.bytes\n   */\n  toHex(): string {\n    return bytesToHex(this.toBytes())\n  }\n\n  /**\n   * Get the bytes representation of a SerializedType\n   *\n   * @returns A Uint8Array of the bytes\n   */\n  toBytes(): Uint8Array {\n    if (this.bytes) {\n      return this.bytes\n    }\n    const bytes = new BytesList()\n    this.toBytesSink(bytes)\n    return bytes.toBytes()\n  }\n\n  /**\n   * Return the JSON representation of a SerializedType\n   *\n   * @param _definitions rippled definitions used to parse the values of transaction types and such.\n   *                          Unused in default, but used in STObject, STArray\n   *                          Can be customized for sidechains and amendments.\n   * @returns any type, if not overloaded returns hexString representation of bytes\n   */\n  toJSON(_definitions?: XrplDefinitionsBase): JSON {\n    return this.toHex()\n  }\n\n  /**\n   * @returns hexString representation of this.bytes\n   */\n  toString(): string {\n    return this.toHex()\n  }\n}\n\n/**\n * Base class for SerializedTypes that are comparable.\n *\n * @template T - What types you want to allow comparisons between. You must specify all types. Primarily used to allow\n * comparisons between built-in types (like `string`) and SerializedType subclasses (like `Hash`).\n *\n * Ex. `class Hash extends Comparable<Hash | string>`\n */\nclass Comparable<T extends Object> extends SerializedType {\n  lt(other: T): boolean {\n    return this.compareTo(other) < 0\n  }\n\n  eq(other: T): boolean {\n    return this.compareTo(other) === 0\n  }\n\n  gt(other: T): boolean {\n    return this.compareTo(other) > 0\n  }\n\n  gte(other: T): boolean {\n    return this.compareTo(other) > -1\n  }\n\n  lte(other: T): boolean {\n    return this.compareTo(other) < 1\n  }\n\n  /**\n   * Overload this method to define how two Comparable SerializedTypes are compared\n   *\n   * @param other The comparable object to compare this to\n   * @returns A number denoting the relationship of this and other\n   */\n  compareTo(other: T): number {\n    throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`)\n  }\n}\n\nexport { SerializedType, Comparable, JSON, JsonObject }\n"],"mappings":";;;;;;AAAA,MAAAA,mBAAA,GAAAC,OAAA;AAGA,MAAAC,OAAA,GAAAD,OAAA;AAMA;;;AAGA,MAAME,cAAc;EAGlBC,YAAYC,KAAkB;IAFX,KAAAA,KAAK,GAAe,IAAIC,UAAU,CAAC,CAAC,CAAC;IAGtD,IAAI,CAACD,KAAK,GAAGA,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,IAAIC,UAAU,CAAC,CAAC,CAAC;EACzC;EAEA,OAAOC,UAAUA,CAACC,MAAoB,EAAEC,IAAa;IACnD,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;IAC7C,OAAO,IAAI,CAACH,UAAU,CAACC,MAAM,EAAEC,IAAI,CAAC;EACtC;EAEA,OAAOE,IAAIA,CAACC,KAAqC;IAC/C,MAAM,IAAIF,KAAK,CAAC,sBAAsB,CAAC;IACvC,OAAO,IAAI,CAACC,IAAI,CAACC,KAAK,CAAC;EACzB;EAEA;;;;;EAKAC,WAAWA,CAACC,IAAe;IACzBA,IAAI,CAACC,GAAG,CAAC,IAAI,CAACV,KAAK,CAAC;EACtB;EAEA;;;;;EAKAW,KAAKA,CAAA;IACH,OAAO,IAAAd,OAAA,CAAAe,UAAU,EAAC,IAAI,CAACC,OAAO,EAAE,CAAC;EACnC;EAEA;;;;;EAKAA,OAAOA,CAAA;IACL,IAAI,IAAI,CAACb,KAAK,EAAE;MACd,OAAO,IAAI,CAACA,KAAK;;IAEnB,MAAMA,KAAK,GAAG,IAAIL,mBAAA,CAAAmB,SAAS,EAAE;IAC7B,IAAI,CAACN,WAAW,CAACR,KAAK,CAAC;IACvB,OAAOA,KAAK,CAACa,OAAO,EAAE;EACxB;EAEA;;;;;;;;EAQAE,MAAMA,CAACC,YAAkC;IACvC,OAAO,IAAI,CAACL,KAAK,EAAE;EACrB;EAEA;;;EAGAM,QAAQA,CAAA;IACN,OAAO,IAAI,CAACN,KAAK,EAAE;EACrB;;AA2COO,OAAA,CAAApB,cAAA,GAAAA,cAAA;AAxCT;;;;;;;;AAQA,MAAMqB,UAA6B,SAAQrB,cAAc;EACvDsB,EAAEA,CAACC,KAAQ;IACT,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC,GAAG,CAAC;EAClC;EAEAE,EAAEA,CAACF,KAAQ;IACT,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC,KAAK,CAAC;EACpC;EAEAG,EAAEA,CAACH,KAAQ;IACT,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC,GAAG,CAAC;EAClC;EAEAI,GAAGA,CAACJ,KAAQ;IACV,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC;EACnC;EAEAK,GAAGA,CAACL,KAAQ;IACV,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC,GAAG,CAAC;EAClC;EAEA;;;;;;EAMAC,SAASA,CAACD,KAAQ;IAChB,MAAM,IAAIhB,KAAK,CAAC,kBAAkB,IAAI,CAACY,QAAQ,EAAE,QAAQI,KAAK,CAACJ,QAAQ,EAAE,EAAE,CAAC;EAC9E;;AAGuBC,OAAA,CAAAC,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}