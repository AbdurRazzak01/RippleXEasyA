{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;\nconst coretypes_1 = require(\"./coretypes\");\nconst ledger_hashes_1 = require(\"./ledger-hashes\");\nObject.defineProperty(exports, \"decodeLedgerData\", {\n  enumerable: true,\n  get: function () {\n    return ledger_hashes_1.decodeLedgerData;\n  }\n});\nconst enums_1 = require(\"./enums\");\nObject.defineProperty(exports, \"XrplDefinitionsBase\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.XrplDefinitionsBase;\n  }\n});\nObject.defineProperty(exports, \"TRANSACTION_TYPES\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.TRANSACTION_TYPES;\n  }\n});\nObject.defineProperty(exports, \"DEFAULT_DEFINITIONS\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.DEFAULT_DEFINITIONS;\n  }\n});\nconst xrpl_definitions_1 = require(\"./enums/xrpl-definitions\");\nObject.defineProperty(exports, \"XrplDefinitions\", {\n  enumerable: true,\n  get: function () {\n    return xrpl_definitions_1.XrplDefinitions;\n  }\n});\nconst types_1 = require(\"./types\");\nObject.defineProperty(exports, \"coreTypes\", {\n  enumerable: true,\n  get: function () {\n    return types_1.coreTypes;\n  }\n});\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst {\n  signingData,\n  signingClaimData,\n  multiSigningData,\n  binaryToJSON,\n  serializeObject\n} = coretypes_1.binary;\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the JSON representation of the transaction\n */\nfunction decode(binary, definitions) {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string');\n  }\n  return binaryToJSON(binary, definitions);\n}\nexports.decode = decode;\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n *\n * @returns A hex-string of the encoded transaction\n */\nfunction encode(json, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(serializeObject(json, {\n    definitions\n  }));\n}\nexports.encode = encode;\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigning(json, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {\n    definitions\n  }));\n}\nexports.encodeForSigning = encodeForSigning;\n/**\n * Encode a transaction and prepare for signing with a claim\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigningClaim(json) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(signingClaimData(json));\n}\nexports.encodeForSigningClaim = encodeForSigningClaim;\n/**\n * Encode a transaction and prepare for multi-signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForMultisigning(json, signer, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  if (json['SigningPubKey'] !== '') {\n    throw new Error();\n  }\n  const definitionsOpt = definitions ? {\n    definitions\n  } : undefined;\n  return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));\n}\nexports.encodeForMultisigning = encodeForMultisigning;\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\nfunction encodeQuality(value) {\n  if (typeof value !== 'string') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));\n}\nexports.encodeQuality = encodeQuality;\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\nfunction decodeQuality(value) {\n  if (typeof value !== 'string') {\n    throw new Error();\n  }\n  return coretypes_1.quality.decode(value).toString();\n}\nexports.decodeQuality = decodeQuality;","map":{"version":3,"names":["coretypes_1","require","ledger_hashes_1","Object","defineProperty","exports","enumerable","get","decodeLedgerData","enums_1","XrplDefinitionsBase","TRANSACTION_TYPES","DEFAULT_DEFINITIONS","xrpl_definitions_1","XrplDefinitions","types_1","coreTypes","utils_1","signingData","signingClaimData","multiSigningData","binaryToJSON","serializeObject","binary","decode","definitions","Error","encode","json","bytesToHex","encodeForSigning","HashPrefix","transactionSig","encodeForSigningClaim","encodeForMultisigning","signer","definitionsOpt","undefined","encodeQuality","value","quality","decodeQuality","toString"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/ripple-binary-codec/src/index.ts"],"sourcesContent":["import { quality, binary, HashPrefix } from './coretypes'\nimport { decodeLedgerData } from './ledger-hashes'\nimport { ClaimObject } from './binary'\nimport { JsonObject } from './types/serialized-type'\nimport {\n  XrplDefinitionsBase,\n  TRANSACTION_TYPES,\n  DEFAULT_DEFINITIONS,\n} from './enums'\nimport { XrplDefinitions } from './enums/xrpl-definitions'\nimport { coreTypes } from './types'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nconst {\n  signingData,\n  signingClaimData,\n  multiSigningData,\n  binaryToJSON,\n  serializeObject,\n} = binary\n\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the JSON representation of the transaction\n */\nfunction decode(binary: string, definitions?: XrplDefinitionsBase): JsonObject {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string')\n  }\n  return binaryToJSON(binary, definitions)\n}\n\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n *\n * @returns A hex-string of the encoded transaction\n */\nfunction encode(json: object, definitions?: XrplDefinitionsBase): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(serializeObject(json as JsonObject, { definitions }))\n}\n\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigning(\n  json: object,\n  definitions?: XrplDefinitionsBase,\n): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(\n    signingData(json as JsonObject, HashPrefix.transactionSig, {\n      definitions,\n    }),\n  )\n}\n\n/**\n * Encode a transaction and prepare for signing with a claim\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigningClaim(json: object): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(signingClaimData(json as ClaimObject))\n}\n\n/**\n * Encode a transaction and prepare for multi-signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForMultisigning(\n  json: object,\n  signer: string,\n  definitions?: XrplDefinitionsBase,\n): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  if (json['SigningPubKey'] !== '') {\n    throw new Error()\n  }\n  const definitionsOpt = definitions ? { definitions } : undefined\n  return bytesToHex(\n    multiSigningData(json as JsonObject, signer, definitionsOpt),\n  )\n}\n\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\nfunction encodeQuality(value: string): string {\n  if (typeof value !== 'string') {\n    throw new Error()\n  }\n  return bytesToHex(quality.encode(value))\n}\n\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\nfunction decodeQuality(value: string): string {\n  if (typeof value !== 'string') {\n    throw new Error()\n  }\n  return quality.decode(value).toString()\n}\n\nexport {\n  decode,\n  encode,\n  encodeForSigning,\n  encodeForSigningClaim,\n  encodeForMultisigning,\n  encodeQuality,\n  decodeQuality,\n  decodeLedgerData,\n  TRANSACTION_TYPES,\n  XrplDefinitions,\n  XrplDefinitionsBase,\n  DEFAULT_DEFINITIONS,\n  coreTypes,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}