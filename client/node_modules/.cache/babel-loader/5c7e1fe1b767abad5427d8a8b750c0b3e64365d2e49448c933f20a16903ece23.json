{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connection = exports.INTENTIONAL_DISCONNECT_CODE = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst ws_1 = __importDefault(require(\"@xrplf/isomorphic/ws\"));\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst errors_1 = require(\"../errors\");\nconst ConnectionManager_1 = __importDefault(require(\"./ConnectionManager\"));\nconst ExponentialBackoff_1 = __importDefault(require(\"./ExponentialBackoff\"));\nconst RequestManager_1 = __importDefault(require(\"./RequestManager\"));\nconst SECONDS_PER_MINUTE = 60;\nconst TIMEOUT = 20;\nconst CONNECTION_TIMEOUT = 5;\nexports.INTENTIONAL_DISCONNECT_CODE = 4000;\nfunction createWebSocket(url, config) {\n  const options = {\n    agent: config.agent\n  };\n  if (config.headers) {\n    options.headers = config.headers;\n  }\n  if (config.authorization != null) {\n    options.headers = Object.assign(Object.assign({}, options.headers), {\n      Authorization: `Basic ${btoa(config.authorization)}`\n    });\n  }\n  const websocketOptions = Object.assign({}, options);\n  return new ws_1.default(url, websocketOptions);\n}\nfunction websocketSendAsync(ws, message) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      ws.send(message, error => {\n        if (error) {\n          reject(new errors_1.DisconnectedError(error.message, error));\n        } else {\n          resolve();\n        }\n      });\n    });\n  });\n}\nclass Connection extends eventemitter3_1.EventEmitter {\n  constructor(url, options = {}) {\n    super();\n    this.ws = null;\n    this.reconnectTimeoutID = null;\n    this.heartbeatIntervalID = null;\n    this.retryConnectionBackoff = new ExponentialBackoff_1.default({\n      min: 100,\n      max: SECONDS_PER_MINUTE * 1000\n    });\n    this.requestManager = new RequestManager_1.default();\n    this.connectionManager = new ConnectionManager_1.default();\n    this.trace = () => {};\n    this.url = url;\n    this.config = Object.assign({\n      timeout: TIMEOUT * 1000,\n      connectionTimeout: CONNECTION_TIMEOUT * 1000\n    }, options);\n    if (typeof options.trace === 'function') {\n      this.trace = options.trace;\n    } else if (options.trace) {\n      this.trace = console.log;\n    }\n  }\n  get state() {\n    return this.ws ? this.ws.readyState : ws_1.default.CLOSED;\n  }\n  get shouldBeConnected() {\n    return this.ws !== null;\n  }\n  isConnected() {\n    return this.state === ws_1.default.OPEN;\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isConnected()) {\n        return Promise.resolve();\n      }\n      if (this.state === ws_1.default.CONNECTING) {\n        return this.connectionManager.awaitConnection();\n      }\n      if (!this.url) {\n        return Promise.reject(new errors_1.ConnectionError('Cannot connect because no server was specified'));\n      }\n      if (this.ws != null) {\n        return Promise.reject(new errors_1.XrplError('Websocket connection never cleaned up.', {\n          state: this.state\n        }));\n      }\n      const connectionTimeoutID = setTimeout(() => {\n        this.onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the ` + `rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`));\n      }, this.config.connectionTimeout);\n      this.ws = createWebSocket(this.url, this.config);\n      if (this.ws == null) {\n        throw new errors_1.XrplError('Connect: created null websocket');\n      }\n      this.ws.on('error', error => this.onConnectionFailed(error));\n      this.ws.on('error', () => clearTimeout(connectionTimeoutID));\n      this.ws.on('close', reason => this.onConnectionFailed(reason));\n      this.ws.on('close', () => clearTimeout(connectionTimeoutID));\n      this.ws.once('open', () => {\n        void this.onceOpen(connectionTimeoutID);\n      });\n      return this.connectionManager.awaitConnection();\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.clearHeartbeatInterval();\n      if (this.reconnectTimeoutID !== null) {\n        clearTimeout(this.reconnectTimeoutID);\n        this.reconnectTimeoutID = null;\n      }\n      if (this.state === ws_1.default.CLOSED) {\n        return Promise.resolve(undefined);\n      }\n      if (this.ws == null) {\n        return Promise.resolve(undefined);\n      }\n      return new Promise(resolve => {\n        if (this.ws == null) {\n          resolve(undefined);\n        }\n        if (this.ws != null) {\n          this.ws.once('close', code => resolve(code));\n        }\n        if (this.ws != null && this.state !== ws_1.default.CLOSING) {\n          this.ws.close(exports.INTENTIONAL_DISCONNECT_CODE);\n        }\n      });\n    });\n  }\n  reconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.emit('reconnect');\n      yield this.disconnect();\n      yield this.connect();\n    });\n  }\n  request(request, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.shouldBeConnected || this.ws == null) {\n        throw new errors_1.NotConnectedError(JSON.stringify(request), request);\n      }\n      const [id, message, responsePromise] = this.requestManager.createRequest(request, timeout !== null && timeout !== void 0 ? timeout : this.config.timeout);\n      this.trace('send', message);\n      websocketSendAsync(this.ws, message).catch(error => {\n        this.requestManager.reject(id, error);\n      });\n      return responsePromise;\n    });\n  }\n  getUrl() {\n    var _a;\n    return (_a = this.url) !== null && _a !== void 0 ? _a : '';\n  }\n  onMessage(message) {\n    this.trace('receive', message);\n    let data;\n    try {\n      data = JSON.parse(message);\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emit('error', 'badMessage', error.message, message);\n      }\n      return;\n    }\n    if (data.type == null && data.error) {\n      this.emit('error', data.error, data.error_message, data);\n      return;\n    }\n    if (data.type) {\n      this.emit(data.type, data);\n    }\n    if (data.type === 'response') {\n      try {\n        this.requestManager.handleResponse(data);\n      } catch (error) {\n        if (error instanceof Error) {\n          this.emit('error', 'badMessage', error.message, message);\n        } else {\n          this.emit('error', 'badMessage', error, error);\n        }\n      }\n    }\n  }\n  onceOpen(connectionTimeoutID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.ws == null) {\n        throw new errors_1.XrplError('onceOpen: ws is null');\n      }\n      this.ws.removeAllListeners();\n      clearTimeout(connectionTimeoutID);\n      this.ws.on('message', message => this.onMessage(message));\n      this.ws.on('error', error => this.emit('error', 'websocket', error.message, error));\n      this.ws.once('close', (code, reason) => {\n        if (this.ws == null) {\n          throw new errors_1.XrplError('onceClose: ws is null');\n        }\n        this.clearHeartbeatInterval();\n        this.requestManager.rejectAll(new errors_1.DisconnectedError(`websocket was closed, ${reason ? (0, utils_1.hexToString)((0, utils_1.bytesToHex)(reason)) : ''}`));\n        this.ws.removeAllListeners();\n        this.ws = null;\n        if (code === undefined) {\n          const internalErrorCode = 1011;\n          this.emit('disconnected', internalErrorCode);\n        } else {\n          this.emit('disconnected', code);\n        }\n        if (code !== exports.INTENTIONAL_DISCONNECT_CODE && code !== undefined) {\n          this.intentionalDisconnect();\n        }\n      });\n      try {\n        this.retryConnectionBackoff.reset();\n        this.startHeartbeatInterval();\n        this.connectionManager.resolveAllAwaiting();\n        this.emit('connected');\n      } catch (error) {\n        if (error instanceof Error) {\n          this.connectionManager.rejectAllAwaiting(error);\n          yield this.disconnect().catch(() => {});\n        }\n      }\n    });\n  }\n  intentionalDisconnect() {\n    const retryTimeout = this.retryConnectionBackoff.duration();\n    this.trace('reconnect', `Retrying connection in ${retryTimeout}ms.`);\n    this.emit('reconnecting', this.retryConnectionBackoff.attempts);\n    this.reconnectTimeoutID = setTimeout(() => {\n      this.reconnect().catch(error => {\n        this.emit('error', 'reconnect', error.message, error);\n      });\n    }, retryTimeout);\n  }\n  clearHeartbeatInterval() {\n    if (this.heartbeatIntervalID) {\n      clearInterval(this.heartbeatIntervalID);\n    }\n  }\n  startHeartbeatInterval() {\n    this.clearHeartbeatInterval();\n    this.heartbeatIntervalID = setInterval(() => {\n      void this.heartbeat();\n    }, this.config.timeout);\n  }\n  heartbeat() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.request({\n        command: 'ping'\n      }).catch(() => __awaiter(this, void 0, void 0, function* () {\n        return this.reconnect().catch(error => {\n          this.emit('error', 'reconnect', error.message, error);\n        });\n      }));\n    });\n  }\n  onConnectionFailed(errorOrCode) {\n    if (this.ws) {\n      this.ws.removeAllListeners();\n      this.ws.on('error', () => {});\n      this.ws.close();\n      this.ws = null;\n    }\n    if (typeof errorOrCode === 'number') {\n      this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {\n        code: errorOrCode\n      }));\n    } else if (errorOrCode === null || errorOrCode === void 0 ? void 0 : errorOrCode.message) {\n      this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));\n    } else {\n      this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError('Connection failed.'));\n    }\n  }\n}\nexports.Connection = Connection;","map":{"version":3,"names":["utils_1","require","ws_1","__importDefault","eventemitter3_1","errors_1","ConnectionManager_1","ExponentialBackoff_1","RequestManager_1","SECONDS_PER_MINUTE","TIMEOUT","CONNECTION_TIMEOUT","exports","INTENTIONAL_DISCONNECT_CODE","createWebSocket","url","config","options","agent","headers","authorization","Object","assign","Authorization","btoa","websocketOptions","default","websocketSendAsync","ws","message","Promise","resolve","reject","send","error","DisconnectedError","Connection","EventEmitter","constructor","reconnectTimeoutID","heartbeatIntervalID","retryConnectionBackoff","min","max","requestManager","connectionManager","trace","timeout","connectionTimeout","console","log","state","readyState","CLOSED","shouldBeConnected","isConnected","OPEN","connect","CONNECTING","awaitConnection","ConnectionError","XrplError","connectionTimeoutID","setTimeout","onConnectionFailed","on","clearTimeout","reason","once","onceOpen","disconnect","clearHeartbeatInterval","undefined","code","CLOSING","close","reconnect","emit","request","NotConnectedError","JSON","stringify","id","responsePromise","createRequest","catch","getUrl","_a","onMessage","data","parse","Error","type","error_message","handleResponse","removeAllListeners","rejectAll","hexToString","bytesToHex","internalErrorCode","intentionalDisconnect","reset","startHeartbeatInterval","resolveAllAwaiting","rejectAllAwaiting","retryTimeout","duration","attempts","clearInterval","setInterval","heartbeat","command","__awaiter","errorOrCode"],"sources":["/Users/mdabdurrazzak/XRPL_React_App/node_modules/xrpl/src/client/connection.ts"],"sourcesContent":["/* eslint-disable max-lines -- Connection is a large file w/ lots of imports/exports */\nimport type { Agent } from 'http'\n\nimport { bytesToHex, hexToString } from '@xrplf/isomorphic/utils'\nimport WebSocket, { ClientOptions } from '@xrplf/isomorphic/ws'\nimport { EventEmitter } from 'eventemitter3'\n\nimport {\n  DisconnectedError,\n  NotConnectedError,\n  ConnectionError,\n  XrplError,\n} from '../errors'\nimport type { RequestResponseMap } from '../models'\nimport { BaseRequest } from '../models/methods/baseMethod'\n\nimport ConnectionManager from './ConnectionManager'\nimport ExponentialBackoff from './ExponentialBackoff'\nimport RequestManager from './RequestManager'\n\nconst SECONDS_PER_MINUTE = 60\nconst TIMEOUT = 20\nconst CONNECTION_TIMEOUT = 5\n\n/**\n * ConnectionOptions is the configuration for the Connection class.\n */\ninterface ConnectionOptions {\n  trace?: boolean | ((id: string, message: string) => void)\n  headers?: { [key: string]: string }\n  agent?: Agent\n  authorization?: string\n  connectionTimeout: number\n  timeout: number\n}\n\n/**\n * ConnectionUserOptions is the user-provided configuration object. All configuration\n * is optional, so any ConnectionOptions configuration that has a default value is\n * still optional at the point that the user provides it.\n */\nexport type ConnectionUserOptions = Partial<ConnectionOptions>\n\n/**\n * Represents an intentionally triggered web-socket disconnect code.\n * WebSocket spec allows 4xxx codes for app/library specific codes.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n */\nexport const INTENTIONAL_DISCONNECT_CODE = 4000\n\ntype WebsocketState = 0 | 1 | 2 | 3\n\n/**\n * Create a new websocket given your URL and optional proxy/certificate\n * configuration.\n *\n * @param url - The URL to connect to.\n * @param config - THe configuration options for the WebSocket.\n * @returns A Websocket that fits the given configuration parameters.\n */\nfunction createWebSocket(\n  url: string,\n  config: ConnectionOptions,\n): WebSocket | null {\n  const options: ClientOptions = {\n    agent: config.agent,\n  }\n  if (config.headers) {\n    options.headers = config.headers\n  }\n  if (config.authorization != null) {\n    options.headers = {\n      ...options.headers,\n      Authorization: `Basic ${btoa(config.authorization)}`,\n    }\n  }\n  const websocketOptions = { ...options }\n  return new WebSocket(url, websocketOptions)\n}\n\n/**\n * Ws.send(), but promisified.\n *\n * @param ws - Websocket to send with.\n * @param message - Message to send.\n * @returns When the message has been sent.\n */\nasync function websocketSendAsync(\n  ws: WebSocket,\n  message: string,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    ws.send(message, (error) => {\n      if (error) {\n        reject(new DisconnectedError(error.message, error))\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\n/**\n * The main Connection class. Responsible for connecting to & managing\n * an active WebSocket connection to a XRPL node.\n */\nexport class Connection extends EventEmitter {\n  private readonly url: string | undefined\n  private ws: WebSocket | null = null\n  // Typing necessary for Jest tests running in browser\n  private reconnectTimeoutID: null | ReturnType<typeof setTimeout> = null\n  // Typing necessary for Jest tests running in browser\n  private heartbeatIntervalID: null | ReturnType<typeof setTimeout> = null\n  private readonly retryConnectionBackoff = new ExponentialBackoff({\n    min: 100,\n    max: SECONDS_PER_MINUTE * 1000,\n  })\n\n  private readonly config: ConnectionOptions\n  private readonly requestManager = new RequestManager()\n  private readonly connectionManager = new ConnectionManager()\n\n  /**\n   * Creates a new Connection object.\n   *\n   * @param url - URL to connect to.\n   * @param options - Options for the Connection object.\n   */\n  public constructor(url?: string, options: ConnectionUserOptions = {}) {\n    super()\n    this.url = url\n    this.config = {\n      timeout: TIMEOUT * 1000,\n      connectionTimeout: CONNECTION_TIMEOUT * 1000,\n      ...options,\n    }\n    if (typeof options.trace === 'function') {\n      this.trace = options.trace\n    } else if (options.trace) {\n      // eslint-disable-next-line no-console -- Used for tracing only\n      this.trace = console.log\n    }\n  }\n\n  /**\n   * Gets the state of the websocket.\n   *\n   * @returns The Websocket's ready state.\n   */\n  private get state(): WebsocketState {\n    return this.ws ? this.ws.readyState : WebSocket.CLOSED\n  }\n\n  /**\n   * Returns whether the server should be connected.\n   *\n   * @returns Whether the server should be connected.\n   */\n  private get shouldBeConnected(): boolean {\n    return this.ws !== null\n  }\n\n  /**\n   * Returns whether the websocket is connected.\n   *\n   * @returns Whether the websocket connection is open.\n   */\n  public isConnected(): boolean {\n    return this.state === WebSocket.OPEN\n  }\n\n  /**\n   * Connects the websocket to the provided URL.\n   *\n   * @returns When the websocket is connected.\n   * @throws ConnectionError if there is a connection error, RippleError if there is already a WebSocket in existence.\n   */\n  // eslint-disable-next-line max-lines-per-function -- Necessary\n  public async connect(): Promise<void> {\n    if (this.isConnected()) {\n      return Promise.resolve()\n    }\n    if (this.state === WebSocket.CONNECTING) {\n      return this.connectionManager.awaitConnection()\n    }\n    if (!this.url) {\n      return Promise.reject(\n        new ConnectionError('Cannot connect because no server was specified'),\n      )\n    }\n    if (this.ws != null) {\n      return Promise.reject(\n        new XrplError('Websocket connection never cleaned up.', {\n          state: this.state,\n        }),\n      )\n    }\n\n    // Create the connection timeout, in case the connection hangs longer than expected.\n    const connectionTimeoutID: ReturnType<typeof setTimeout> = setTimeout(\n      () => {\n        this.onConnectionFailed(\n          new ConnectionError(\n            `Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the ` +\n              `rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`,\n          ),\n        )\n      },\n      this.config.connectionTimeout,\n    )\n    // Connection listeners: these stay attached only until a connection is done/open.\n    this.ws = createWebSocket(this.url, this.config)\n\n    if (this.ws == null) {\n      throw new XrplError('Connect: created null websocket')\n    }\n\n    this.ws.on('error', (error) => this.onConnectionFailed(error))\n    this.ws.on('error', () => clearTimeout(connectionTimeoutID))\n    this.ws.on('close', (reason) => this.onConnectionFailed(reason))\n    this.ws.on('close', () => clearTimeout(connectionTimeoutID))\n    this.ws.once('open', () => {\n      void this.onceOpen(connectionTimeoutID)\n    })\n    return this.connectionManager.awaitConnection()\n  }\n\n  /**\n   * Disconnect the websocket connection.\n   * We never expect this method to reject. Even on \"bad\" disconnects, the websocket\n   * should still successfully close with the relevant error code returned.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent for the full list.\n   * If no open websocket connection exists, resolve with no code (`undefined`).\n   *\n   * @returns A promise containing either `undefined` or a disconnected code, that resolves when the connection is destroyed.\n   */\n  public async disconnect(): Promise<number | undefined> {\n    this.clearHeartbeatInterval()\n    if (this.reconnectTimeoutID !== null) {\n      clearTimeout(this.reconnectTimeoutID)\n      this.reconnectTimeoutID = null\n    }\n    if (this.state === WebSocket.CLOSED) {\n      return Promise.resolve(undefined)\n    }\n    if (this.ws == null) {\n      return Promise.resolve(undefined)\n    }\n\n    return new Promise((resolve) => {\n      if (this.ws == null) {\n        resolve(undefined)\n      }\n      if (this.ws != null) {\n        this.ws.once('close', (code) => resolve(code))\n      }\n      /*\n       * Connection already has a disconnect handler for the disconnect logic.\n       * Just close the websocket manually (with our \"intentional\" code) to\n       * trigger that.\n       */\n      if (this.ws != null && this.state !== WebSocket.CLOSING) {\n        this.ws.close(INTENTIONAL_DISCONNECT_CODE)\n      }\n    })\n  }\n\n  /**\n   * Disconnect the websocket, then connect again.\n   */\n  public async reconnect(): Promise<void> {\n    /*\n     * NOTE: We currently have a \"reconnecting\" event, but that only triggers\n     * through an unexpected connection retry logic.\n     * See: https://github.com/XRPLF/xrpl.js/pull/1101#issuecomment-565360423\n     */\n    this.emit('reconnect')\n    await this.disconnect()\n    await this.connect()\n  }\n\n  /**\n   * Sends a request to the rippled server.\n   *\n   * @param request - The request to send to the server.\n   * @param timeout - How long the Connection instance should wait before assuming that there will not be a response.\n   * @returns The response from the rippled server.\n   * @throws NotConnectedError if the Connection isn't connected to a server.\n   */\n  public async request<R extends BaseRequest, T = RequestResponseMap<R>>(\n    request: R,\n    timeout?: number,\n  ): Promise<T> {\n    if (!this.shouldBeConnected || this.ws == null) {\n      throw new NotConnectedError(JSON.stringify(request), request)\n    }\n    const [id, message, responsePromise] = this.requestManager.createRequest<\n      R,\n      T\n    >(request, timeout ?? this.config.timeout)\n    this.trace('send', message)\n    websocketSendAsync(this.ws, message).catch((error) => {\n      this.requestManager.reject(id, error)\n    })\n\n    return responsePromise\n  }\n\n  /**\n   * Get the Websocket connection URL.\n   *\n   * @returns The Websocket connection URL.\n   */\n  public getUrl(): string {\n    return this.url ?? ''\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, class-methods-use-this -- Does nothing on default\n  public readonly trace: (id: string, message: string) => void = () => {}\n\n  /**\n   * Handler for when messages are received from the server.\n   *\n   * @param message - The message received from the server.\n   */\n  private onMessage(message): void {\n    this.trace('receive', message)\n    let data: Record<string, unknown>\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- Must be a JSON dictionary\n      data = JSON.parse(message)\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emit('error', 'badMessage', error.message, message)\n      }\n      return\n    }\n    if (data.type == null && data.error) {\n      // e.g. slowDown\n      this.emit('error', data.error, data.error_message, data)\n      return\n    }\n    if (data.type) {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Should be true\n      this.emit(data.type as string, data)\n    }\n    if (data.type === 'response') {\n      try {\n        this.requestManager.handleResponse(data)\n      } catch (error) {\n        // eslint-disable-next-line max-depth -- okay here\n        if (error instanceof Error) {\n          this.emit('error', 'badMessage', error.message, message)\n        } else {\n          this.emit('error', 'badMessage', error, error)\n        }\n      }\n    }\n  }\n\n  /**\n   * Handler for what to do once the connection to the server is open.\n   *\n   * @param connectionTimeoutID - Timeout in case the connection hangs longer than expected.\n   * @returns A promise that resolves to void when the connection is fully established.\n   * @throws Error if the websocket initialized is somehow null.\n   */\n  // eslint-disable-next-line max-lines-per-function -- Many error code conditionals to check.\n  private async onceOpen(\n    connectionTimeoutID: ReturnType<typeof setTimeout>,\n  ): Promise<void> {\n    if (this.ws == null) {\n      throw new XrplError('onceOpen: ws is null')\n    }\n\n    // Once the connection completes successfully, remove all old listeners\n    this.ws.removeAllListeners()\n    clearTimeout(connectionTimeoutID)\n    // Add new, long-term connected listeners for messages and errors\n    this.ws.on('message', (message: string) => this.onMessage(message))\n    this.ws.on('error', (error) =>\n      this.emit('error', 'websocket', error.message, error),\n    )\n    // Handle a closed connection: reconnect if it was unexpected\n    this.ws.once('close', (code?: number, reason?: Uint8Array) => {\n      if (this.ws == null) {\n        throw new XrplError('onceClose: ws is null')\n      }\n\n      this.clearHeartbeatInterval()\n      this.requestManager.rejectAll(\n        new DisconnectedError(\n          `websocket was closed, ${\n            reason ? hexToString(bytesToHex(reason)) : ''\n          }`,\n        ),\n      )\n      this.ws.removeAllListeners()\n      this.ws = null\n\n      if (code === undefined) {\n        // Useful to keep this code for debugging purposes.\n        // const reasonText = reason ? reason.toString() : 'undefined'\n        // // eslint-disable-next-line no-console -- The error is helpful for debugging.\n        // console.error(\n        //   `Disconnected but the disconnect code was undefined (The given reason was ${reasonText}).` +\n        //     `This could be caused by an exception being thrown during a 'connect' callback. ` +\n        //     `Disconnecting with code 1011 to indicate an internal error has occurred.`,\n        // )\n\n        /*\n         * Error code 1011 represents an Internal Error according to\n         * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n         */\n        const internalErrorCode = 1011\n        this.emit('disconnected', internalErrorCode)\n      } else {\n        this.emit('disconnected', code)\n      }\n\n      /*\n       * If this wasn't a manual disconnect, then lets reconnect ASAP.\n       * Code can be undefined if there's an exception while connecting.\n       */\n      if (code !== INTENTIONAL_DISCONNECT_CODE && code !== undefined) {\n        this.intentionalDisconnect()\n      }\n    })\n    // Finalize the connection and resolve all awaiting connect() requests\n    try {\n      this.retryConnectionBackoff.reset()\n      this.startHeartbeatInterval()\n      this.connectionManager.resolveAllAwaiting()\n      this.emit('connected')\n    } catch (error) {\n      if (error instanceof Error) {\n        this.connectionManager.rejectAllAwaiting(error)\n        // Ignore this error, propagate the root cause.\n        // eslint-disable-next-line @typescript-eslint/no-empty-function -- Need empty catch\n        await this.disconnect().catch(() => {})\n      }\n    }\n  }\n\n  private intentionalDisconnect(): void {\n    const retryTimeout = this.retryConnectionBackoff.duration()\n    this.trace('reconnect', `Retrying connection in ${retryTimeout}ms.`)\n    this.emit('reconnecting', this.retryConnectionBackoff.attempts)\n    /*\n     * Start the reconnect timeout, but set it to `this.reconnectTimeoutID`\n     * so that we can cancel one in-progress on disconnect.\n     */\n    this.reconnectTimeoutID = setTimeout(() => {\n      this.reconnect().catch((error: Error) => {\n        this.emit('error', 'reconnect', error.message, error)\n      })\n    }, retryTimeout)\n  }\n\n  /**\n   * Clears the heartbeat connection interval.\n   */\n  private clearHeartbeatInterval(): void {\n    if (this.heartbeatIntervalID) {\n      clearInterval(this.heartbeatIntervalID)\n    }\n  }\n\n  /**\n   * Starts a heartbeat to check the connection with the server.\n   */\n  private startHeartbeatInterval(): void {\n    this.clearHeartbeatInterval()\n    this.heartbeatIntervalID = setInterval(() => {\n      void this.heartbeat()\n    }, this.config.timeout)\n  }\n\n  /**\n   * A heartbeat is just a \"ping\" command, sent on an interval.\n   * If this succeeds, we're good. If it fails, disconnect so that the consumer can reconnect, if desired.\n   *\n   * @returns A Promise that resolves to void when the heartbeat returns successfully.\n   */\n  private async heartbeat(): Promise<void> {\n    this.request({ command: 'ping' }).catch(async () => {\n      return this.reconnect().catch((error: Error) => {\n        this.emit('error', 'reconnect', error.message, error)\n      })\n    })\n  }\n\n  /**\n   * Process a failed connection.\n   *\n   * @param errorOrCode - (Optional) Error or code for connection failure.\n   */\n  private onConnectionFailed(errorOrCode: Error | number | null): void {\n    if (this.ws) {\n      this.ws.removeAllListeners()\n      this.ws.on('error', () => {\n        /*\n         * Correctly listen for -- but ignore -- any future errors: If you\n         * don't have a listener on \"error\" node would log a warning on error.\n         */\n      })\n      this.ws.close()\n      this.ws = null\n    }\n    if (typeof errorOrCode === 'number') {\n      this.connectionManager.rejectAllAwaiting(\n        new NotConnectedError(`Connection failed with code ${errorOrCode}.`, {\n          code: errorOrCode,\n        }),\n      )\n    } else if (errorOrCode?.message) {\n      this.connectionManager.rejectAllAwaiting(\n        new NotConnectedError(errorOrCode.message, errorOrCode),\n      )\n    } else {\n      this.connectionManager.rejectAllAwaiting(\n        new NotConnectedError('Connection failed.'),\n      )\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,IAAA,GAAAC,eAAA,CAAAF,OAAA;AACA,MAAAG,eAAA,GAAAH,OAAA;AAEA,MAAAI,QAAA,GAAAJ,OAAA;AASA,MAAAK,mBAAA,GAAAH,eAAA,CAAAF,OAAA;AACA,MAAAM,oBAAA,GAAAJ,eAAA,CAAAF,OAAA;AACA,MAAAO,gBAAA,GAAAL,eAAA,CAAAF,OAAA;AAEA,MAAMQ,kBAAkB,GAAG,EAAE;AAC7B,MAAMC,OAAO,GAAG,EAAE;AAClB,MAAMC,kBAAkB,GAAG,CAAC;AA0BfC,OAAA,CAAAC,2BAA2B,GAAG,IAAI;AAY/C,SAASC,eAAeA,CACtBC,GAAW,EACXC,MAAyB;EAEzB,MAAMC,OAAO,GAAkB;IAC7BC,KAAK,EAAEF,MAAM,CAACE;GACf;EACD,IAAIF,MAAM,CAACG,OAAO,EAAE;IAClBF,OAAO,CAACE,OAAO,GAAGH,MAAM,CAACG,OAAO;;EAElC,IAAIH,MAAM,CAACI,aAAa,IAAI,IAAI,EAAE;IAChCH,OAAO,CAACE,OAAO,GAAAE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACVL,OAAO,CAACE,OAAO;MAClBI,aAAa,EAAE,SAASC,IAAI,CAACR,MAAM,CAACI,aAAa,CAAC;IAAE,EACrD;;EAEH,MAAMK,gBAAgB,GAAAJ,MAAA,CAAAC,MAAA,KAAQL,OAAO,CAAE;EACvC,OAAO,IAAIf,IAAA,CAAAwB,OAAS,CAACX,GAAG,EAAEU,gBAAgB,CAAC;AAC7C;AASA,SAAeE,kBAAkBA,CAC/BC,EAAa,EACbC,OAAe;;IAEf,OAAO,IAAIC,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAI;MAC3CJ,EAAE,CAACK,IAAI,CAACJ,OAAO,EAAGK,KAAK,IAAI;QACzB,IAAIA,KAAK,EAAE;UACTF,MAAM,CAAC,IAAI3B,QAAA,CAAA8B,iBAAiB,CAACD,KAAK,CAACL,OAAO,EAAEK,KAAK,CAAC,CAAC;SACpD,MAAM;UACLH,OAAO,EAAE;;MAEb,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;;AAMD,MAAaK,UAAW,SAAQhC,eAAA,CAAAiC,YAAY;EAsB1CC,YAAmBvB,GAAY,EAAEE,OAAA,GAAiC,EAAE;IAClE,KAAK,EAAE;IArBD,KAAAW,EAAE,GAAqB,IAAI;IAE3B,KAAAW,kBAAkB,GAAyC,IAAI;IAE/D,KAAAC,mBAAmB,GAAyC,IAAI;IACvD,KAAAC,sBAAsB,GAAG,IAAIlC,oBAAA,CAAAmB,OAAkB,CAAC;MAC/DgB,GAAG,EAAE,GAAG;MACRC,GAAG,EAAElC,kBAAkB,GAAG;KAC3B,CAAC;IAGe,KAAAmC,cAAc,GAAG,IAAIpC,gBAAA,CAAAkB,OAAc,EAAE;IACrC,KAAAmB,iBAAiB,GAAG,IAAIvC,mBAAA,CAAAoB,OAAiB,EAAE;IAsM5C,KAAAoB,KAAK,GAA0C,MAAK,CAAE,CAAC;IA5LrE,IAAI,CAAC/B,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,MAAM,GAAAK,MAAA,CAAAC,MAAA;MACTyB,OAAO,EAAErC,OAAO,GAAG,IAAI;MACvBsC,iBAAiB,EAAErC,kBAAkB,GAAG;IAAI,GACzCM,OAAO,CACX;IACD,IAAI,OAAOA,OAAO,CAAC6B,KAAK,KAAK,UAAU,EAAE;MACvC,IAAI,CAACA,KAAK,GAAG7B,OAAO,CAAC6B,KAAK;KAC3B,MAAM,IAAI7B,OAAO,CAAC6B,KAAK,EAAE;MAExB,IAAI,CAACA,KAAK,GAAGG,OAAO,CAACC,GAAG;;EAE5B;EAOA,IAAYC,KAAKA,CAAA;IACf,OAAO,IAAI,CAACvB,EAAE,GAAG,IAAI,CAACA,EAAE,CAACwB,UAAU,GAAGlD,IAAA,CAAAwB,OAAS,CAAC2B,MAAM;EACxD;EAOA,IAAYC,iBAAiBA,CAAA;IAC3B,OAAO,IAAI,CAAC1B,EAAE,KAAK,IAAI;EACzB;EAOO2B,WAAWA,CAAA;IAChB,OAAO,IAAI,CAACJ,KAAK,KAAKjD,IAAA,CAAAwB,OAAS,CAAC8B,IAAI;EACtC;EASaC,OAAOA,CAAA;;MAClB,IAAI,IAAI,CAACF,WAAW,EAAE,EAAE;QACtB,OAAOzB,OAAO,CAACC,OAAO,EAAE;;MAE1B,IAAI,IAAI,CAACoB,KAAK,KAAKjD,IAAA,CAAAwB,OAAS,CAACgC,UAAU,EAAE;QACvC,OAAO,IAAI,CAACb,iBAAiB,CAACc,eAAe,EAAE;;MAEjD,IAAI,CAAC,IAAI,CAAC5C,GAAG,EAAE;QACb,OAAOe,OAAO,CAACE,MAAM,CACnB,IAAI3B,QAAA,CAAAuD,eAAe,CAAC,gDAAgD,CAAC,CACtE;;MAEH,IAAI,IAAI,CAAChC,EAAE,IAAI,IAAI,EAAE;QACnB,OAAOE,OAAO,CAACE,MAAM,CACnB,IAAI3B,QAAA,CAAAwD,SAAS,CAAC,wCAAwC,EAAE;UACtDV,KAAK,EAAE,IAAI,CAACA;SACb,CAAC,CACH;;MAIH,MAAMW,mBAAmB,GAAkCC,UAAU,CACnE,MAAK;QACH,IAAI,CAACC,kBAAkB,CACrB,IAAI3D,QAAA,CAAAuD,eAAe,CACjB,oCAAoC,IAAI,CAAC5C,MAAM,CAACgC,iBAAiB,mDAAmD,GAClH,mIAAmI,CACtI,CACF;MACH,CAAC,EACD,IAAI,CAAChC,MAAM,CAACgC,iBAAiB,CAC9B;MAED,IAAI,CAACpB,EAAE,GAAGd,eAAe,CAAC,IAAI,CAACC,GAAG,EAAE,IAAI,CAACC,MAAM,CAAC;MAEhD,IAAI,IAAI,CAACY,EAAE,IAAI,IAAI,EAAE;QACnB,MAAM,IAAIvB,QAAA,CAAAwD,SAAS,CAAC,iCAAiC,CAAC;;MAGxD,IAAI,CAACjC,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAG/B,KAAK,IAAK,IAAI,CAAC8B,kBAAkB,CAAC9B,KAAK,CAAC,CAAC;MAC9D,IAAI,CAACN,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAE,MAAMC,YAAY,CAACJ,mBAAmB,CAAC,CAAC;MAC5D,IAAI,CAAClC,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAGE,MAAM,IAAK,IAAI,CAACH,kBAAkB,CAACG,MAAM,CAAC,CAAC;MAChE,IAAI,CAACvC,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAE,MAAMC,YAAY,CAACJ,mBAAmB,CAAC,CAAC;MAC5D,IAAI,CAAClC,EAAE,CAACwC,IAAI,CAAC,MAAM,EAAE,MAAK;QACxB,KAAK,IAAI,CAACC,QAAQ,CAACP,mBAAmB,CAAC;MACzC,CAAC,CAAC;MACF,OAAO,IAAI,CAACjB,iBAAiB,CAACc,eAAe,EAAE;IACjD,CAAC;;EAWYW,UAAUA,CAAA;;MACrB,IAAI,CAACC,sBAAsB,EAAE;MAC7B,IAAI,IAAI,CAAChC,kBAAkB,KAAK,IAAI,EAAE;QACpC2B,YAAY,CAAC,IAAI,CAAC3B,kBAAkB,CAAC;QACrC,IAAI,CAACA,kBAAkB,GAAG,IAAI;;MAEhC,IAAI,IAAI,CAACY,KAAK,KAAKjD,IAAA,CAAAwB,OAAS,CAAC2B,MAAM,EAAE;QACnC,OAAOvB,OAAO,CAACC,OAAO,CAACyC,SAAS,CAAC;;MAEnC,IAAI,IAAI,CAAC5C,EAAE,IAAI,IAAI,EAAE;QACnB,OAAOE,OAAO,CAACC,OAAO,CAACyC,SAAS,CAAC;;MAGnC,OAAO,IAAI1C,OAAO,CAAEC,OAAO,IAAI;QAC7B,IAAI,IAAI,CAACH,EAAE,IAAI,IAAI,EAAE;UACnBG,OAAO,CAACyC,SAAS,CAAC;;QAEpB,IAAI,IAAI,CAAC5C,EAAE,IAAI,IAAI,EAAE;UACnB,IAAI,CAACA,EAAE,CAACwC,IAAI,CAAC,OAAO,EAAGK,IAAI,IAAK1C,OAAO,CAAC0C,IAAI,CAAC,CAAC;;QAOhD,IAAI,IAAI,CAAC7C,EAAE,IAAI,IAAI,IAAI,IAAI,CAACuB,KAAK,KAAKjD,IAAA,CAAAwB,OAAS,CAACgD,OAAO,EAAE;UACvD,IAAI,CAAC9C,EAAE,CAAC+C,KAAK,CAAC/D,OAAA,CAAAC,2BAA2B,CAAC;;MAE9C,CAAC,CAAC;IACJ,CAAC;;EAKY+D,SAASA,CAAA;;MAMpB,IAAI,CAACC,IAAI,CAAC,WAAW,CAAC;MACtB,MAAM,IAAI,CAACP,UAAU,EAAE;MACvB,MAAM,IAAI,CAACb,OAAO,EAAE;IACtB,CAAC;;EAUYqB,OAAOA,CAClBA,OAAU,EACV/B,OAAgB;;MAEhB,IAAI,CAAC,IAAI,CAACO,iBAAiB,IAAI,IAAI,CAAC1B,EAAE,IAAI,IAAI,EAAE;QAC9C,MAAM,IAAIvB,QAAA,CAAA0E,iBAAiB,CAACC,IAAI,CAACC,SAAS,CAACH,OAAO,CAAC,EAAEA,OAAO,CAAC;;MAE/D,MAAM,CAACI,EAAE,EAAErD,OAAO,EAAEsD,eAAe,CAAC,GAAG,IAAI,CAACvC,cAAc,CAACwC,aAAa,CAGtEN,OAAO,EAAE/B,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,IAAI,CAAC/B,MAAM,CAAC+B,OAAO,CAAC;MAC1C,IAAI,CAACD,KAAK,CAAC,MAAM,EAAEjB,OAAO,CAAC;MAC3BF,kBAAkB,CAAC,IAAI,CAACC,EAAE,EAAEC,OAAO,CAAC,CAACwD,KAAK,CAAEnD,KAAK,IAAI;QACnD,IAAI,CAACU,cAAc,CAACZ,MAAM,CAACkD,EAAE,EAAEhD,KAAK,CAAC;MACvC,CAAC,CAAC;MAEF,OAAOiD,eAAe;IACxB,CAAC;;EAOMG,MAAMA,CAAA;;IACX,OAAO,CAAAC,EAAA,OAAI,CAACxE,GAAG,cAAAwE,EAAA,cAAAA,EAAA,GAAI,EAAE;EACvB;EAUQC,SAASA,CAAC3D,OAAO;IACvB,IAAI,CAACiB,KAAK,CAAC,SAAS,EAAEjB,OAAO,CAAC;IAC9B,IAAI4D,IAA6B;IACjC,IAAI;MAEFA,IAAI,GAAGT,IAAI,CAACU,KAAK,CAAC7D,OAAO,CAAC;KAC3B,CAAC,OAAOK,KAAK,EAAE;MACd,IAAIA,KAAK,YAAYyD,KAAK,EAAE;QAC1B,IAAI,CAACd,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE3C,KAAK,CAACL,OAAO,EAAEA,OAAO,CAAC;;MAE1D;;IAEF,IAAI4D,IAAI,CAACG,IAAI,IAAI,IAAI,IAAIH,IAAI,CAACvD,KAAK,EAAE;MAEnC,IAAI,CAAC2C,IAAI,CAAC,OAAO,EAAEY,IAAI,CAACvD,KAAK,EAAEuD,IAAI,CAACI,aAAa,EAAEJ,IAAI,CAAC;MACxD;;IAEF,IAAIA,IAAI,CAACG,IAAI,EAAE;MAEb,IAAI,CAACf,IAAI,CAACY,IAAI,CAACG,IAAc,EAAEH,IAAI,CAAC;;IAEtC,IAAIA,IAAI,CAACG,IAAI,KAAK,UAAU,EAAE;MAC5B,IAAI;QACF,IAAI,CAAChD,cAAc,CAACkD,cAAc,CAACL,IAAI,CAAC;OACzC,CAAC,OAAOvD,KAAK,EAAE;QAEd,IAAIA,KAAK,YAAYyD,KAAK,EAAE;UAC1B,IAAI,CAACd,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE3C,KAAK,CAACL,OAAO,EAAEA,OAAO,CAAC;SACzD,MAAM;UACL,IAAI,CAACgD,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE3C,KAAK,EAAEA,KAAK,CAAC;;;;EAItD;EAUcmC,QAAQA,CACpBP,mBAAkD;;MAElD,IAAI,IAAI,CAAClC,EAAE,IAAI,IAAI,EAAE;QACnB,MAAM,IAAIvB,QAAA,CAAAwD,SAAS,CAAC,sBAAsB,CAAC;;MAI7C,IAAI,CAACjC,EAAE,CAACmE,kBAAkB,EAAE;MAC5B7B,YAAY,CAACJ,mBAAmB,CAAC;MAEjC,IAAI,CAAClC,EAAE,CAACqC,EAAE,CAAC,SAAS,EAAGpC,OAAe,IAAK,IAAI,CAAC2D,SAAS,CAAC3D,OAAO,CAAC,CAAC;MACnE,IAAI,CAACD,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAG/B,KAAK,IACxB,IAAI,CAAC2C,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE3C,KAAK,CAACL,OAAO,EAAEK,KAAK,CAAC,CACtD;MAED,IAAI,CAACN,EAAE,CAACwC,IAAI,CAAC,OAAO,EAAE,CAACK,IAAa,EAAEN,MAAmB,KAAI;QAC3D,IAAI,IAAI,CAACvC,EAAE,IAAI,IAAI,EAAE;UACnB,MAAM,IAAIvB,QAAA,CAAAwD,SAAS,CAAC,uBAAuB,CAAC;;QAG9C,IAAI,CAACU,sBAAsB,EAAE;QAC7B,IAAI,CAAC3B,cAAc,CAACoD,SAAS,CAC3B,IAAI3F,QAAA,CAAA8B,iBAAiB,CACnB,yBACEgC,MAAM,GAAG,IAAAnE,OAAA,CAAAiG,WAAW,EAAC,IAAAjG,OAAA,CAAAkG,UAAU,EAAC/B,MAAM,CAAC,CAAC,GAAG,EAC7C,EAAE,CACH,CACF;QACD,IAAI,CAACvC,EAAE,CAACmE,kBAAkB,EAAE;QAC5B,IAAI,CAACnE,EAAE,GAAG,IAAI;QAEd,IAAI6C,IAAI,KAAKD,SAAS,EAAE;UActB,MAAM2B,iBAAiB,GAAG,IAAI;UAC9B,IAAI,CAACtB,IAAI,CAAC,cAAc,EAAEsB,iBAAiB,CAAC;SAC7C,MAAM;UACL,IAAI,CAACtB,IAAI,CAAC,cAAc,EAAEJ,IAAI,CAAC;;QAOjC,IAAIA,IAAI,KAAK7D,OAAA,CAAAC,2BAA2B,IAAI4D,IAAI,KAAKD,SAAS,EAAE;UAC9D,IAAI,CAAC4B,qBAAqB,EAAE;;MAEhC,CAAC,CAAC;MAEF,IAAI;QACF,IAAI,CAAC3D,sBAAsB,CAAC4D,KAAK,EAAE;QACnC,IAAI,CAACC,sBAAsB,EAAE;QAC7B,IAAI,CAACzD,iBAAiB,CAAC0D,kBAAkB,EAAE;QAC3C,IAAI,CAAC1B,IAAI,CAAC,WAAW,CAAC;OACvB,CAAC,OAAO3C,KAAK,EAAE;QACd,IAAIA,KAAK,YAAYyD,KAAK,EAAE;UAC1B,IAAI,CAAC9C,iBAAiB,CAAC2D,iBAAiB,CAACtE,KAAK,CAAC;UAG/C,MAAM,IAAI,CAACoC,UAAU,EAAE,CAACe,KAAK,CAAC,MAAK,CAAE,CAAC,CAAC;;;IAG7C,CAAC;;EAEOe,qBAAqBA,CAAA;IAC3B,MAAMK,YAAY,GAAG,IAAI,CAAChE,sBAAsB,CAACiE,QAAQ,EAAE;IAC3D,IAAI,CAAC5D,KAAK,CAAC,WAAW,EAAE,0BAA0B2D,YAAY,KAAK,CAAC;IACpE,IAAI,CAAC5B,IAAI,CAAC,cAAc,EAAE,IAAI,CAACpC,sBAAsB,CAACkE,QAAQ,CAAC;IAK/D,IAAI,CAACpE,kBAAkB,GAAGwB,UAAU,CAAC,MAAK;MACxC,IAAI,CAACa,SAAS,EAAE,CAACS,KAAK,CAAEnD,KAAY,IAAI;QACtC,IAAI,CAAC2C,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE3C,KAAK,CAACL,OAAO,EAAEK,KAAK,CAAC;MACvD,CAAC,CAAC;IACJ,CAAC,EAAEuE,YAAY,CAAC;EAClB;EAKQlC,sBAAsBA,CAAA;IAC5B,IAAI,IAAI,CAAC/B,mBAAmB,EAAE;MAC5BoE,aAAa,CAAC,IAAI,CAACpE,mBAAmB,CAAC;;EAE3C;EAKQ8D,sBAAsBA,CAAA;IAC5B,IAAI,CAAC/B,sBAAsB,EAAE;IAC7B,IAAI,CAAC/B,mBAAmB,GAAGqE,WAAW,CAAC,MAAK;MAC1C,KAAK,IAAI,CAACC,SAAS,EAAE;IACvB,CAAC,EAAE,IAAI,CAAC9F,MAAM,CAAC+B,OAAO,CAAC;EACzB;EAQc+D,SAASA,CAAA;;MACrB,IAAI,CAAChC,OAAO,CAAC;QAAEiC,OAAO,EAAE;MAAM,CAAE,CAAC,CAAC1B,KAAK,CAAC,MAAW2B,SAAA;QACjD,OAAO,IAAI,CAACpC,SAAS,EAAE,CAACS,KAAK,CAAEnD,KAAY,IAAI;UAC7C,IAAI,CAAC2C,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE3C,KAAK,CAACL,OAAO,EAAEK,KAAK,CAAC;QACvD,CAAC,CAAC;MACJ,CAAC,EAAC;IACJ,CAAC;;EAOO8B,kBAAkBA,CAACiD,WAAkC;IAC3D,IAAI,IAAI,CAACrF,EAAE,EAAE;MACX,IAAI,CAACA,EAAE,CAACmE,kBAAkB,EAAE;MAC5B,IAAI,CAACnE,EAAE,CAACqC,EAAE,CAAC,OAAO,EAAE,MAAK,CAKzB,CAAC,CAAC;MACF,IAAI,CAACrC,EAAE,CAAC+C,KAAK,EAAE;MACf,IAAI,CAAC/C,EAAE,GAAG,IAAI;;IAEhB,IAAI,OAAOqF,WAAW,KAAK,QAAQ,EAAE;MACnC,IAAI,CAACpE,iBAAiB,CAAC2D,iBAAiB,CACtC,IAAInG,QAAA,CAAA0E,iBAAiB,CAAC,+BAA+BkC,WAAW,GAAG,EAAE;QACnExC,IAAI,EAAEwC;OACP,CAAC,CACH;KACF,MAAM,IAAIA,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEpF,OAAO,EAAE;MAC/B,IAAI,CAACgB,iBAAiB,CAAC2D,iBAAiB,CACtC,IAAInG,QAAA,CAAA0E,iBAAiB,CAACkC,WAAW,CAACpF,OAAO,EAAEoF,WAAW,CAAC,CACxD;KACF,MAAM;MACL,IAAI,CAACpE,iBAAiB,CAAC2D,iBAAiB,CACtC,IAAInG,QAAA,CAAA0E,iBAAiB,CAAC,oBAAoB,CAAC,CAC5C;;EAEL;;AAlaFnE,OAAA,CAAAwB,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}